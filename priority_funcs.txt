def priority(h,J):  # random generator
    N = len(h)
    priority = np.random.rand(N**2,2)
    return(priority)


def priority(h,J):  # uses h matrices: score is -1.717
    N = len(h)
    priority = np.zeros((N**2,2))
    for i in range(N):
      for j in range(N):
        if h[i,j] > 0:
            priority[(i*N+j),0] = h[i,j]
        else:
            priority[(i*N+j),1] = -1*h[i,j]
    return(priority)


def priority(h,J):  # priorities are all 0 - sets all spins to -1
    N = len(h)
    priority = np.zeros((N**2,2))
    return(priority)


def priority(h,J):  #LLM written function - only one that actually works, no modification: 1.715
    N = len(h)
    state = [[-1 if h[i][j] > 0 else 1 for j in range(N)] for i in range(N)]
    priorities = []
    for i in range(N):
        for j in range(N):
            total_spin = 0
            for k in range(3):
                site = (i + ((k-1)%2 - 1)) % N
                total_spin += state[site][j]
            if h[i][j] > 0:
                priorities.append((total_spin, 1))
            else:
                priorities.append((total_spin, -1))
    return priorities


def priority(h, J):  # llm written function -  works with 3 characters of modification (score of -0.002)
    n = len(h)
    spin_config = [[-1 if h[i][j] > 0 else 1 for j in range(n)] for i in range(n)]
    priorities = []
    
    for i in range(n):
        for j in range(n):
            interaction = -2 * J[i][j][0] * spin_config[i][j]
            magnetism = h[i][j]
            priority = interaction + magnetism
            priorities.append([spin_config[i][j], -priority])
    
    return sorted(priorities, key=lambda x: x[1])


def priority(h,J): ## needs slight modification to work (J indexed wrong). Score -0.002
    N = len(h)
    spins = [[0 for _ in range(2)] for _ in range(N*N)]
    
    for i in range(N):
        for j in range(N):
            total_J = 0
            if i > 0:
                total_J += J[i-1][j][0]
            if i < N - 1:
                total_J += J[i+1][j][0]
            if j > 0:
                total_J += J[i][j-1][1]
            if j < N - 1:
                total_J += J[i][j+1][1]
            
            if h[i][j] > 0:
                spins[N*i+j][0] = np.exp(total_J) / (np.exp(total_J) + np.exp(-total_J))
                spins[N*i+j][1] = 1 - spins[N*i+j][0]
            else:
                spins[N*i+j][0] = 1 - np.exp(total_J) / (np.exp(total_J) + np.exp(-total_J))
                spins[N*i+j][1] = np.exp(total_J) / (np.exp(total_J) + np.exp(-total_J))
    
    return spins


def priority(h,J):  # -0.002
    N = len(h)
    energy_map = np.zeros(N**2)
    for i in range(N):
        for j in range(N):
            spin1_energy = -h[i].dot(h[j])
            for k in range(2):
                x, y = (i + 1) % N, (j + k) % 2
                if J[x][y].sum() > 0:
                    spin1_energy += J[i][j][k]
                else:
                    spin1_energy -= J[i][j][k]
            energy_map[i+N*j] = spin1_energy
    
    return [[-energy_map[i+N*j], 1] for i in range(N) for j in range(N)]


def priority(h, J):  # with some modifications it gets to -0.461
    N = len(h)
    priorities = [[0.0, 0.0] for _ in range(N*N)]
    
    for i in range(N):
        for j in range(N):
            site_energy = -h[i][j]
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if abs(dx) + abs(dy) == 1:
                        x, y = i + dx, j + dy
                        if 0 <= x < N and 0 <= y < N:
                            site_energy += J[x][y][int(h[i][j] * (h[x][y] - 2 * h[i][j])%2)]
            priorities[i*N+j][1] = site_energy
    return priorities


def priority(h, J):  # wrong dimensions for J, but other than that its 0.4209
    N = len(h)
    priorities = [[0 for _ in range(2)] for _ in range(N*N)]
    
    for i in range(N):
        for j in range(N):
            site_energy = -h[i][j]
            if i < N-1:
                site_energy += J[i+1][j][0] * h[i+1][j]
            if j < N-1:
                site_energy += J[i][j+1][1] * h[i][j+1]
            priorities[i*N+j][0] = site_energy
            priorities[i*N+j][1] = -site_energy
    
    return priorities


def priority(h,J):  ## score -1.0365
    N = len(h)
    priorities = []
    for i in range(N):
        for j in range(N):
            total_spin = 0
            for k in range(2):
                site = (i + ((k-1)%2 - 1)) % N
                total_spin += h[site][j]
            if sum(h[i]) > 0:
                priorities.append((total_spin, 1))
            else:
                priorities.append((total_spin, -1))
    return priorities


def priority(h,J): ## score = 1.472
    N = len(h)
    state = [[-1 if h[i][j] > 0 else 1 for j in range(N)] for i in range(N)]
    priorities = []
    for i in range(N):
        for j in range(N):
            total_spin = sum([state[k][j] for k in range(max(0,i-1),min(i+2,N))]) + sum([state[i][k] for k in range(max(0,j-1),min(j+2,N))])
            if h[i][j] > 0:
                priorities.append((total_spin, 1))
            else:
                priorities.append((total_spin, -1))
    return priorities


def priority(h,J):  ## scpre: -0.9002
    N = len(h)
    priorities = np.zeros((N**2, 2))

    for i in range(N):
        for j in range(N):
            if h[i][j] > 0:
                priorities[(i*N+j), 0] = np.sin(i*j)  # Unknown rule: sine product of site indices
            else:
                priorities[(i*N+j), 1] = -h[i][j]

    return priorities



1.715955322265625
def priority(h, J):
    N = len(h)
    state = [[-1 if h[i][j] > 0 else 1 for j in range(N)] for i in range(N)]
    priorities = []
    for i in range(N):
        for j in range(N):
            total_spin = 0
            for k in range(3):
                site = (i + ((k-1)%2 - 1)) % N
                total_spin += state[site][j]
            if h[i][j] > 0:
                priorities.append((total_spin, 1))
            else:
                priorities.append((total_spin, -1))
    return priorities

#-1.717979248046875
def priority(h, J):
    N = len(h)
    priorities = np.zeros((N*N, 2))
    
    for i in range(N):
        for j in range(N):
            if h[i][j] > 0:
                priorities[(i*N)+j, 0] = h[i][j]
            else:
                priorities[(i*N)+j, 1] = -1*h[i][j]
    
    return priorities

