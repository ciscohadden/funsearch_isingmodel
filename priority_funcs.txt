def priority(h,J):
    N = len(h)
    priority = np.random.rand(N**2,2)
    return(priority)

def priority(h,J):
    N = len(h)
    priority = np.zeros((N**2,2))
    for i in range(N):
      for j in range(N):
        if h[i,j] > 0:
            priority[(i*N+j),0] = h[i,j]
        else:
            priority[(i*N+j),1] = -1*h[i,j]
    return(priority)

def priority(h,J):
    N = len(h)
    priority = np.zeros((N**2,2))
    return(priority)

def priority(h,J):
    N = len(h)
    state = [[-1 if h[i][j] > 0 else 1 for j in range(N)] for i in range(N)]
    priorities = []
    for i in range(N):
        for j in range(N):
            total_spin = 0
            for k in range(3):
                site = (i + ((k-1)%2 - 1)) % N
                total_spin += state[site][j]
            if h[i][j] > 0:
                priorities.append((total_spin, 1))
            else:
                priorities.append((total_spin, -1))
    return priorities

def priority(h, J):  # Note from Megan: appears to be simulated annealing
    N = len(h)
    result = [[0.0, 0.0] for _ in range(N**2)]
    
    def calculate_energy(state, J):
        energy = 0
        for i in range(N):
            for j in range(N):
                if state[i][j] == -1:
                    neighbor_sum = sum([J[neighbor_i][neighbor_j] * state[neighbor_i][neighbor_j] for neighbor_i, neighbor_j in [(i-1)%N, j], [(i+1)%N, j], [i, (j-1)%N], [i, (j+1)%N]])
                else:
                    neighbor_sum = sum([J[neighbor_i][neighbor_j] * state[neighbor_i][neighbor_j] for neighbor_i, neighbor_j in [(i-1)%N, j], [(i+1)%N, j], [i, (j-1)%N], [i, (j+1)%N]])
                energy += -h[i][j]*state[i][j] - J[i][j]*state[i][j]*neighbor_sum
        return energy
    
    def calculate_delta_energy(state, next_state, J):
        delta_energy = calculate_energy(next_state, J) - calculate_energy(state, J)
        return delta_energy
    
    current_state = [[h[i][j] > 0 if np.random.rand() < 0.5 else -1 for j in range(N)] for i in range(N)]
    
    def generate_next_state(current_state):
        next_state = [row[:] for row in current_state]
        i, j = np.random.randint(0, N), np.random.randint(0, N)
        if np.random.rand() < 0.5:
            next_state[i][j] *= -1
        return next_state
    
    T = 100.0
    Tmin = 0.01
    current_energy = calculate_energy(current_state, J)
    
    while T > Tmin:
        next_state = generate_next_state(current_state)
        delta_energy = calculate_delta_energy(current_state, next_state, J)
        
        if delta_energy < 0 or np.exp(-delta_energy / T) > np.random.rand():
            current_state = next_state
            current_energy = calculate_energy(current_state, J)
        T *= 0.9
    
    for i in range(N):
        for j in range(N):
            if current_state[i][j] == -1:
                result[i*N+j] = [current_energy + h[i][j], current_energy]
            else:
                result[i*N+j] = [current_energy, current_energy + h[i][j]]
    
    return result

def priority(h, J):
    N = len(h)
    spin_config = [[-1 if h[i][j] > 0 else 1 for j in range(N)] for i in range(N)]
    priorities = []
    
    for i in range(N):
        for j in range(N):
            interaction = -2 * J[0][i][j] * spin_config[i][j]
            magnetism = h[i][j]
            priority = interaction + magnetism
            priorities.append([spin_config[i][j], -priority])
    
    return sorted(priorities, key=lambda x: x[1])