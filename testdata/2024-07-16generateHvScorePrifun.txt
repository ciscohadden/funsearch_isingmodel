#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time09:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': 0.07122021604938274}
#island_id: 2
#version_generated: 2
#generate time09:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    # Calculate the total spin based on magnetism and energy
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k, site_nbr in enumerate(site_nbrs):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 4
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  return(priorities)




#score: {'data2D.txt': 0.07122021604938274}
#island_id: 2
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    # Calculate the total spin based on magnetism and energy
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k, site_nbr in enumerate(site_nbrs):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 4
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  return(priorities)




#score: {'data2D.txt': -0.001662191358024692}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -abs(total_spin) + h[i//N][i%N]
    priorities[i][1] = abs(total_spin) + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.003076697530864198}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        priorities[i][k] = total_spin - h[i//N][i%N]
      else:
        priorities[i][k] = total_spin + h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.24699305555555537}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][1] = -total_spin - h[i//N][i%N]
    priorities[i][0] = -priorities[i][1]
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001631018518518519}
#island_id: 1
#version_generated: 2
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on site magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.031172993827160513}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for k in [2,3]:
      total_spin += np.sum(J[[k],i//N,i//N])
    total_spin /= 4
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin + np.sum(J[[2,3],i//N,i//N]), -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin + np.sum(J[[2,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i][0] += np.prod(J[[0,1,2,3],i//N,i//N])
     priorities[i][1] -= np.prod(J[[0,1,2,3],i//N,i//N])
    else:
     priorities[i][0] -= np.prod(J[[0,1,2,3],i//N,i//N])
     priorities[i][1] += np.prod(J[[0,1,2,3],i//N,i//N])
  return(priorities)




#score: {'data2D.txt': -0.0021044753086419763}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction sum
    interaction_sum = np.sum(J[[0,3],i//N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_sum, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + interaction_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.1462020061728397}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interaction
    total_spin = h[site_nbr][i%N]
    for k in [0,1,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[[0,3],i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[[0,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] -= np.prod(J[[0,1,3],i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] += np.prod(J[[0,1,3],i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.13548688271604956}
#island_id: 0
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for k in [2,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1/np.sqrt(2)
      else:
        total_spin -= 1/np.sqrt(2)
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[[0,3],i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[[0,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] -= np.prod(J[[0,1,3],i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] += np.prod(J[[0,1,3],i//N,i//N])
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += sum(J[k,i//N,i%N] for k in range(4))
      priorities[i][1] -= sum(J[k,i//N,i%N] for k in range(4))
    else:
      priorities[i][0] -= sum(J[k,i//N,i%N] for k in range(4))
      priorities[i][1] += sum(J[k,i//N,i%N] for k in range(4))
    
    if h[site_nbr2][i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate site priorities based on interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the spin priority considering the nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the magnetism contribution
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+N-1)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.3309180555555546}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.0009016975308641979}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin * np.exp(-np.sum(J[:,i//N,:]*h[:,i%N])) 
    priorities[i][1] = total_spin * np.exp(np.sum(J[:,i//N,:]*h[:,i%N]))
  
  return(priorities)




#score: {'data2D.txt': -0.009956635802469136}
#island_id: 3
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site-wise magnetism and neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = np.exp(total_spin) / (np.exp(total_spin) + np.exp(-total_spin))
    priorities[i][1] = 1 - priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.18908132716049394}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias for sites with no neighbors
    if i % N == 0 or i % N == N-1 or (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(0, total_spin)
      priorities[i][1] = min(0, total_spin)
    else:
      priorities[i][0] = min(0, -total_spin)
      priorities[i][1] = max(0, -total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.199283487654321}
#island_id: 0
#version_generated: 2
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
    # Calculate the priority based on the total spin
    if total_spin > 0.5:
      priorities[i][1] *= 2
    elif total_spin < -0.5:
      priorities[i][0] *= 2
    
  return priorities




#score: {'data2D.txt': 0.10365787037037048}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
  # Normalize the priorities
  priorities /= np.linalg.norm(priorities, axis=1)[:,None]
  
  return priorities




#score: {'data2D.txt': 0.03151219135802463}
#island_id: 2
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)) - np.sum(h), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4)) - np.sum(h)]
    
  # Normalize the priorities
  priorities /= np.linalg.norm(priorities, axis=1)[:,None]
  
  return priorities




#score: {'data2D.txt': 0.16313719135802496}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[::2,i//N,i//N]), total_spin + np.sum(J[1::2,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.002899228395061729}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if np.sum(J[:,i//N,i//N]) < 0: 
      priorities[i] = [-total_spin + np.sum(-J[0::2,i//N,i//N]), total_spin + np.sum(-J[1::2,i//N,i//N])]
    else:
      priorities[i] = [total_spin + np.sum(J[0::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.005316820987654321}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    magnetism = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i//N] > 0:
        magnetism += 1
      else:
        magnetism -= 1
    
    # Calculate priority based on magnetism and interaction
    if magnetism > 0:
      priorities[i] = [magnetism + np.sum(J[0::2,i//N,i//N]), -magnetism + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-magnetism + np.sum(J[0::2,i//N,i//N]), magnetism + np.sum(J[1::2,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16313719135802496}
#island_id: 0
#version_generated: 2
#generate time09:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[0::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[0::2,i//N,i//N]), total_spin + np.sum(J[1::2,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.25736126543209853}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    total_spin += np.sum(J[:,i%N,i//N])
    
    # Prioritize spin based on magnetism, energy, and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin - 3]
    else:
      priorities[i] = [-total_spin - 1, total_spin + 3]
  
  return(priorities)




#score: {'data2D.txt': -0.0033297839506172843}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    neighbor_interactions = 0
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    priorities[i][0] = total_spin + neighbor_interactions
    priorities[i][1] = -total_spin - neighbor_interactions
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
  
  return(priorities)




#score: {'data2D.txt': -0.0012057098765432099}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the interactions with the four nearest neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.04342052469135802}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the interaction with the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0027711419753086424}
#island_id: 2
#version_generated: 2
#generate time09:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(h[i//N][i:i+N]) - i/N, -total_spin]
    else:
      priorities[i] = [-total_spin + N*np.sum(h[i//N][i:i+N]) - i, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.2957699074074068}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [1 - np.exp(-total_spin), -np.exp(total_spin)]
    else:
      priorities[i] = [-1 + np.exp(total_spin), np.exp(-1 + total_spin)]
  return(priorities)




#score: {'data2D.txt': -0.0008177469135802467}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = np.tanh(total_spin) * 10
    priorities[i][1] = -np.tanh(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.08264151234567901}
#island_id: 3
#version_generated: 2
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spins = np.zeros((N,N))

  # Calculate the total spin of each site based on its magnetism and neighbor interactions
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      J_sum = J[:, i, :].sum()
      for k in [0, 1]:
        if J[k,i,j] > 0:
          total_spin += J[k,k,i]
        else:
          total_spin -= J[k,k,i]
      total_spins[i,j] = total_spin / (J_sum + 2)

  # Calculate the priority based on the total spin of each site
  for i in range(N**2):
    priorities[i] = [total_spins[i//N][i%N], -total_spins[i//N][i%N]]

  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate magnetism at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.32729861111111025}
#island_id: 0
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Count neighbors with same spin and opposite spin
    same_spin_count = 0
    opp_spin_count = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Count interactions with sites above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        if h[j][i%N] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        if h[i//N][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Count interactions with sites diagonally above and below (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        if h[j][l] == h[i//N][i%N]:
          same_spin_count += 1
        else:
          opp_spin_count += 1
    
    # Calculate priority based on interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [same_spin_count, -opp_spin_count]
    else:
      priorities[i] = [-same_spin_count, opp_spin_count]
  
  return(priorities)




#score: {'data2D.txt': 0.16580972222222246}
#island_id: 2
#version_generated: 2
#generate time09:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.14306342592592614}
#island_id: 2
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Consider the site's own spin in case of tie
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.05705015432098766}
#island_id: 2
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the site's own spin in case of tie
    if total_spin > 0.5:
      priorities[i][0] += 1
    elif total_spin < -0.5:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.04013935185185186}
#island_id: 1
#version_generated: 2
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for site_nbr in site_nbrs:
      if J[3,i%N,site_nbr] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.13823163580246933}
#island_id: 1
#version_generated: 2
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i//N+1)%N) if i%N == 0 else (i % N)
    total_spin = h[site_nbr1][i%N] + J[3, i%N, i//N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002361882716049383}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the sum of all interactions from this site
    total_spin += np.sum(J[:,i//N,i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11251898148148162}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1270094135802471}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr1 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr1][j]
        priorities[i][1] -= h[site_nbr1][j]
      else:
        priorities[i][0] -= h[site_nbr1][j]
        priorities[i][1] += h[site_nbr1][j]
    
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 1
#version_generated: 2
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the total magnetism at each site
  h_sum = h.sum(axis=1)
  
  # Iterate over all sites
  for i in range(N**2):
    # Get the row and column indices of the current site
    i_row, i_col = divmod(i, N)
    
    # Calculate the total magnetism at this site, including its neighbors
    total_spin = h_sum[i_row] + J[:,i_row,i_col].sum()
    
    # Calculate the priority for each spin direction (1 and -1)
    priorities[i][0] = abs(total_spin)  # -1 is more likely if there are many negative interactions
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.02166064814814815}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    
    for k in [0, 1]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin[i] += 1
      else:
        total_spin[i] -= 1
      
      priorities[i][0] += J[k,i%N,i//N]
      priorities[i][1] -= J[k,i%N,i//N]
    
    # Normalize by the number of interacting neighbors
    priorities[i][0] /= (np.sum(J[:,i//N,:].flatten()) + 1)
    priorities[i][1] /= (np.sum(J[:,i//N,:].flatten()) + 1)
  
  return(priorities)




#score: {'data2D.txt': 0.33164953703703604}
#island_id: 3
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with next neighbor sites
      for l in [2,3]:
        if (l == 2 and i % N != 0) or (l == 3 and i % N != N-1):
          if J[l,i%N,i//N] > 0:
            total_spin += 1
          else:
            total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 4)
    
    # Calculate priority based on magnetism and neighbor interactions
    if total_spin > 0.5:
      priorities[i] = [total_spin - h[i//N][i%N], total_spin]
    else:
      priorities[i] = [total_spin, total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.3389890432098755}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum(h[site_nbr][j] for j in range(N)) / N
    neighbor_alignment = sum(J[k,i%N,i//N] * (-1 if J[k,i%N,i//N] < 0 else 1) for k in range(4))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_alignment, -total_spin - neighbor_alignment]
    else:
      priorities[i] = [-total_spin - neighbor_alignment, total_spin + neighbor_alignment]
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
  
  # Reorder the priority based on the total spin and energy
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = sorted(priorities[i])
    else:
      priorities[i] = sorted(priorities[i], reverse=True)
  
  return(priorities)




#score: {'data2D.txt': 0.16840077160493838}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16722083333333349}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N]) * h[site_nbr][i%N]

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.1821489197530865}
#island_id: 0
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += J[3,i%N,j]
        priorities[i][1] -= J[3,i%N,j]
      else:
        priorities[i][0] -= J[3,i%N,j]
        priorities[i][1] += J[3,i%N,j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total spin with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate priority with nearest neighbors
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate priority with next nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16640416666666694}
#island_id: 1
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0791992283950618}
#island_id: 3
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
    
    # Add the effect of the site's own interaction with its neighbors
    if i % N > 0:
      priorities[i, 0] -= J[1, i%N, i//N]
      priorities[i, 1] += J[1, i%N, i//N]
    if i % N < N - 1:
      priorities[i, 0] -= J[0, i%N, i//N]
      priorities[i, 1] += J[0, i%N, i//N]
    if (i // N) % 2 == 0:
      priorities[i, 0] -= J[1, i//N, i%N]
      priorities[i, 1] += J[1, i//N, i%N]
    else:
      priorities[i, 0] -= J[0, i//N, i%N]
      priorities[i, 1] += J[0, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.3440853395061718}
#island_id: 3
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + 2 * h[i//N][i%N]
      priorities[i][0] = total_spin
    else:
      priorities[i][0] = -total_spin + 2 * abs(h[i//N][i%N])
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
    else:
      priorities[i] = [-total_spin, -total_spin]
 
  return(priorities)




#score: {'data2D.txt': 0.002077932098765432}
#island_id: 1
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  for i in range(N**2):
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.0942760802469137}
#island_id: 1
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(3):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += 2*h[site_nbr][i%N]
        priorities[i][1] -= 2*h[site_nbr][i%N]
      else:
        priorities[i][0] -= 2*h[site_nbr][i%N]
        priorities[i][1] += 2*h[site_nbr][i%N]
    
    for j in range(N):
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[(j-1)%N][i//N]
        priorities[i][1] -= h[(j-1)%N][i//N]
      else:
        priorities[i][0] -= h[(j-1)%N][i//N]
        priorities[i][1] += h[(j-1)%N][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.00126466049382716}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin + h[site_nbr][i%N]
  
  return priorities




#score: {'data2D.txt': -0.004388734567901235}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += h[site_nbr][i%N]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': 0.0002807098765432099}
#island_id: 0
#version_generated: 2
#generate time09:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    neighbor_interactions = 0
    
    # Calculate magnetism contribution
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k][i//N, i%N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Calculate priority based on magnetism and interaction
    priorities[i] = [total_spin + neighbor_interactions, -total_spin + neighbor_interactions]
  
  return(priorities)




#score: {'data2D.txt': 0.05398935185185188}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Additional adjustment based on the interaction with diagonal neighbors
    site_nbr_diagonal = (i % N + ((i//N-2)%2 - 1)) % N
    if i % N > 0:
      priorities[i][0] += J[3, i//N, i%N]
    else:
      priorities[i][1] -= J[3, i//N, i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.06162947530864202}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Adjust the priority based on the interaction with diagonal neighbors
  for i in range(N**2):
    site_nbr_diagonal = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_diagonal][i%N] > 0:
      priorities[i][1] -= J[3, i//N, i%N]
    else:
      priorities[i][0] += J[3, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.053111265432098785}
#island_id: 0
#version_generated: 2
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
        2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Additional adjustment based on the interaction with diagonal neighbors
    site_nbr_diagonal = (i % N + ((i//N-2)%2 - 1)) % N
    if i % N > 0:
      priorities[i][0] += J[3, i//N, i%N]
    else:
      priorities[i][1] -= J[3, i//N, i%N]
    
  # Calculate the priority based on the sum of the magnetism and interaction with nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
        2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.04353101851851851}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher absolute value of magnetism
    if abs(h[i//N][i%N]) > abs(h[site_nbr][i%N]):
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0012726851851851849}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.0569729938271605}
#island_id: 2
#version_generated: 2
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0038356481481481484}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Reorder the priority based on the total spin and energy
    if h[i//N][i%N] > 0:
      priorities[i] = sorted(priorities[i])
    else:
      priorities[i] = sorted(priorities[i], reverse=True)
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Reorder the priority based on the total spin and energy
    if h[i//N][i%N] > 0:
      priorities[i] = np.array(sorted(priorities[i])).reshape(-1,2)
    else:
      priorities[i] = np.array(sorted(priorities[i], reverse=True)).reshape(-1,2)
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
    
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.3390578703703694}
#island_id: 2
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    
    # Prioritize based on the number of aligned neighbors
    total_alignment = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_alignment += 1
      elif J[k,i%N,i//N] < 0:
        total_alignment -= 1
    
    priorities[i][0] += total_alignment
    priorities[i][1] -= total_alignment
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total_spin based on nearest neighbors
    total_spin = 0
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust total_spin based on magnetism at the site
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009285493827160493}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        for j in range(N):
          if h[site_nbrs[j]][i%N] > 0:
            priorities[i][0] += h[site_nbrs[j]][i%N]
            priorities[i][1] -= h[site_nbrs[j]][i%N]
          else:
            priorities[i][0] -= h[site_nbrs[j]][i%N]
            priorities[i][1] += h[site_nbrs[j]][i%N]
      else:
        for j in range(N):
          if h[site_nbrs[j]][i%N] > 0:
            priorities[i][0] -= h[site_nbrs[j]][i%N]
            priorities[i][1] += h[site_nbrs[j]][i%N]
          else:
            priorities[i][0] += h[site_nbrs[j]][i%N]
            priorities[i][1] -= h[site_nbrs[j]][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time09:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr_col = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_col][j]
      else:
        total_spin -= h[site_nbr_col][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
      site_nbrs.append(site_nbr)
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2768421296296292}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -np.abs(total_spin) - h[i//N][i%N]
    priorities[i][1] = np.abs(total_spin) + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0012967592592592588}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin**2 * np.tanh(total_spin) 
    priorities[i][1] = total_spin**2 * np.tanh(-total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.0023671296296296296}
#island_id: 3
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 4)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time09:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.06960848765432101}
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[i//N][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N-1)%2 - 1)) % N

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -3.070987654320912e-05}
#island_id: 1
#version_generated: 2
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + J[0,i%N,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
     site_nbr1 = (i % N + ((j-1)%2 - 1)) % N
     site_nbr2 = (i // N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       total_spin += h[site_nbr1][j] + J[3,i%N,j]
     else:
       total_spin -= h[site_nbr1][j] + J[3,i%N,j]
    
    priorities[i][0] = min(priorities[i][0], -priorities[i][1])
    priorities[i][1] = max(-priorities[i][0], priorities[i][1])
  
  return(priorities)




#score: {'data2D.txt': -0.009849845679012348}
#island_id: 1
#version_generated: 2
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][total_spin>0] = [abs(total_spin), -abs(total_spin)]
    
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09304922839506181}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.0012405864197530864}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the interactions with neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the site's magnetism
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Calculate the priority based on the site's interactions with its nearest neighbors
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate the priority based on the site's interactions with its next nearest neighbors
    for k in range(2):
      if i % N > 0:
        if J[k,i%N-1,i//N] > 0:
          priorities[i][0] += h[site_nbr][i%N-1]
          priorities[i][1] -= h[site_nbr][i%N-1]
        else:
          priorities[i][0] -= h[site_nbr][i%N-1]
          priorities[i][1] += h[site_nbr][i%N-1]
      if i % N < N - 1:
        if J[k,i%N+1,i//N] > 0:
          priorities[i][0] += h[site_nbr][i%N+1]
          priorities[i][1] -= h[site_nbr][i%N+1]
        else:
          priorities[i][0] -= h[site_nbr][i%N+1]
          priorities[i][1] += h[site_nbr][i%N+1]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # sum up interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.20125848765432114}
#island_id: 1
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif i%N == 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+1)%N] > 0:
      total_spin += 1
    elif i%N == N-1:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.33199367283950515}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.0010084876543209876}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in [0, 1, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate site magnetism and neighbor interactions
  site_magnetisms = h.flatten()
  neighbor_interactions = (J[:, :, :].sum(axis=0) + 1)
  
  # Iterate over each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total magnetism at this site
    total_magnetism = site_magnetisms[i] + neighbor_interactions[i//N].dot(h[site_nbr])
    
    # Calculate priority based on magnetism and interactions
    priorities[i] = [total_magnetism - h[i//N][i%N], total_magnetism + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.04959706790123461}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.0631498456790124}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
    # Additional improvement: consider the majority vote of neighbors
    neighbor_votes = [neighbor > 0 for neighbor in neighbors]
    if sum(neighbor_votes) > len(neighbor_votes) / 2:
      priorities[i] += np.array([1, -1])
  return(priorities)




#score: {'data2D.txt': -0.014500771604938276}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
  # Calculate a secondary priority based on the total magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.012826080246913616}
#island_id: 0
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
    # Add the magnetism of the site to the priority
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.04357978395061728}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on their local energy
    site_energy = h[site_nbr][i%N] * (h[i//N][i%N] > 0) - total_spin
    if site_energy > 0:
      priorities[i][1] += 1
    elif site_energy < 0:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.04344336419753086}
#island_id: 2
#version_generated: 2
#generate time09:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on the number of aligned neighbors
    aligned_neighbors = sum(neighbor_spins)
    if aligned_neighbors > 0:
      priorities[i][1] += 1
    elif aligned_neighbors < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.19855848765432105}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0,0]
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin[1] -= 1
    else:
      total_spin[0] += 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[0] += 1
    
    # Normalize by the number of neighbors
    total_spin[0] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    total_spin[1] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[0], -total_spin[1]]
    else:
      priorities[i] = [-total_spin[1], total_spin[0]]
  
  return(priorities)




#score: {'data2D.txt': 0.11373533950617293}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(3):
      j = i//N + ((k-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(3):
      j = i//N + ((k-1)%2 - 1)
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16610015432098788}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time09:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1022430555555557}
#island_id: 3
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    # Add a penalty term for sites with large magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.04365077160493827}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0014699074074074074}
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    return(priorities)




#score: {'data2D.txt': 0.0019214506172839504}
#island_id: 2
#version_generated: 2
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that are closer to the boundary and more stable
    site_edge = int((i % (N*N)) ** 0.5)
    if site_edge > 0:
      edge_dist = min(site_edge, N - site_edge)
      priorities[i][1] += edge_dist
    
  return(priorities)




#score: {'data2D.txt': 0.07178873456790126}
#island_id: 2
#version_generated: 2
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
      else:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with up to 4 nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * 2 - N
      priorities[i][1] = -(total_spin * 2 - N)
    else:
      priorities[i][0] = -(total_spin * 2 - N)
      priorities[i][1] = total_spin * 2 - N
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_priority = [total_spin, -total_spin]
    site_magnetism = h[i//N][i%N]
    
    for k in range(3):
      if J[k,i%N,i//N] > 0:
        if h[(i % N + ((k-1)%2 - 1)) % N][i%N] > 0:
          spin_priority[1] -= 1
        else:
          spin_priority[0] += 1
      else:
        if h[(i % N + ((k-1)%2 - 1)) % N][i%N] > 0:
          spin_priority[0] -= 1
        else:
          spin_priority[1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        spin_priority[1] -= 1
      else:
        spin_priority[0] += 1
    
    priorities[i] = spin_priority
  
  return(priorities)




#score: {'data2D.txt': -0.0007010802469135806}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N)
    site_nbr_col = ((i//N) % N)
    
    total_spin = 0
    for k in range(4):
      if k == 0:
        total_spin += J[k,i%N,i//N]
      elif k == 1:
        total_spin += J[k,(i-1)%N,site_nbr_row]
      elif k == 2:
        total_spin += J[k,i%N,(i//N-1)%N]
      else:
        total_spin += J[k,(i+1)%N,site_nbr_col]
    
    # Add magnetism term
    total_spin += h[i//N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1384973765432101}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Calculate the priority based on the distance from the boundary
  for i in range(N**2):
    x, y = (i % N), (i // N)
    dist_to_boundary = min(x, y, N - x, N - y)
    priorities[i][0] += 2 * dist_to_boundary / N
    priorities[i][1] -= 2 * dist_to_boundary / N
  
  return(priorities)




#score: {'data2D.txt': -0.0011359567901234571}
#island_id: 3
#version_generated: 2
#generate time09:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort sites based on their priority
  sorted_indices = np.argsort(priorities[:, 0])
  sorted_priorities = priorities[sorted_indices]
  
  return(sorted_priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.03011620370370369}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + len([j for j in range(4) if J[j,i//N,i%N]]))
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Calculate the priority based on the distance from the boundary
  for i in range(N**2):
    x, y = (i % N), (i // N)
    dist_to_boundary = min(x, y, N - x, N - y)
    priorities[i][0] += 4 * dist_to_boundary / N
    priorities[i][1] -= 4 * dist_to_boundary / N
  
  return(priorities)




#score: {'data2D.txt': 0.11390324074074087}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the number of nearest neighbors in the same state
    for k in range(4):
      neighbor_site_nbr = ((i % N + (k-1)%2) % N + ((i//N-1)%2 - 1)) % N
      if h[neighbor_site_nbr][(i%N + k)%N] == h[i//N][i%N]:
        priorities[i][0] += 1
        priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1145109567901236}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority based on the number of nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i % N != k // 2 and (i // N) != (k - 1) // 2:
        priorities[i][0] += 2 * total_spin / 3
        priorities[i][1] -= 2 * total_spin / 3
  
  return(priorities)




#score: {'data2D.txt': 0.14858410493827182}
#island_id: 3
#version_generated: 2
#generate time09:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a term to account for magnetism
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to account for the boundary
    x, y = (i % N), (i // N)
    if x == 0 or y == 0 or x == N-1 or y == N-1:
      priorities[i][0] += 3
      priorities[i][1] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.0004723765432098761}
#island_id: 2
#version_generated: 2
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0012967592592592597}
#island_id: 2
#version_generated: 2
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + len([j for j in range(N) if J[3,i//N,j] < 0]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + len([j for j in range(N) if J[3,i//N,j] > 0])]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += len([j for j in neighbor_spins if j > 0])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= len([j for j in neighbor_spins if j < 0])
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += len([j for j in range(N) if J[3,i//N,j] < 0])
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= len([j for j in range(N) if J[3,i//N,j] > 0])
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += len([j for j in range(N) if h[j//N][j%N] > 0])
    else:
      priorities[i][0] -= len([j for j in range(N) if h[j//N][j%N] < 0])
  
  return(priorities)




#score: {'data2D.txt': -0.1718915123456791}
#island_id: 2
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] > 0), -total_spin - sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] < 0)]
    else:
      priorities[i] = [-total_spin - sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] > 0), total_spin + sum(1 for j in range(N) if J[(k-1)%4,i%N,j//N] < 0)]
    
  return(priorities)




#score: {'data2D.txt': -0.0017131172839506142}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    total_spin += np.sum(J[:,i//N,i//N])
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.009499228395061728}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N])
    
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
      
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    # Add site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16448225308641998}
#island_id: 2
#version_generated: 2
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum([1 if J[k,i%N,i//N]>0 else -1 for k in range(4)])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum([1 if J[k,i%N,i//N]<0 else -1 for k in range(4)])
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.16840077160493838}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19888163580246918}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19583719135802471}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N - 1
    l = i%N
    if J[2, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    j = i//N + 1
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19706620370370376}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.15204645061728414}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.14029058641975328}
#island_id: 0
#version_generated: 2
#generate time09:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = []
    for k in range(4):  
      if J[k, i//N, i%N] > 0:
        neighbors.append(1)
      else:
        neighbors.append(-1)
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + sum(J[::, i//N, i%N]), -spin]
    else:
      priorities[i] = [-spin, spin + sum(J[::, i//N, i%N])]
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.12143287037037051}
#island_id: 0
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i%N], -total_spin + J[1, i//N, i%N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i%N], total_spin + J[3, i//N, i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    # Add bias term to prioritize -1 spin if h[i//N][i%N] > 0
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - N, -total_spin - N]
    else:
      priorities[i] = [-total_spin + N, total_spin + N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.11073472222222233}
#island_id: 3
#version_generated: 2
#generate time09:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    spin_h = h[i//N][i%N]
    
    for k in range(4):
      jnbr = (i // N + ((k-1)%2 - 1)) % N
      if J[k,i//N,jnbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin + spin_h
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0014699074074074074}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
    return(priorities)




#score: {'data2D.txt': 0.043781944444444436}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.045489660493827154}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have lower entropy
    if abs(total_spin) < N**2 / 4:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.16766280864197558}
#island_id: 2
#version_generated: 2
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0012615740740740745}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum(np.abs(neighbor_spins))
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum(np.abs(neighbor_spins))
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.032313117283950615}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority of each spin
    if total_spin > 0.5:
      priorities[i][1] += 3
    elif total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have higher magnetism
    if h[site_nbr][i%N] > 0 and total_spin > 0.25:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and total_spin < -0.25:
      priorities[i][0] -= 2
    
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1156964506172841}
#island_id: 1
#version_generated: 2
#generate time09:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': -0.0012245370370370368}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = J[3,i//N,i%N]
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -J[3,i//N,i%N]
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time09:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.count_nonzero(neighbor_spins)
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.count_nonzero(neighbor_spins)

  return(priorities)




#score: {'data2D.txt': 0.16766280864197558}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.14854645061728414}
#island_id: 2
#version_generated: 2
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins based on the interactions with their neighbors
    neighbor_interactions = [J[0,i%N,i//N], J[1,i%N,i//N], J[2,i%N,i//N], J[3,i%N,i//N]]
    if sum(neighbor_interactions) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_interactions) < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.05008287037037037}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.12791435185185202}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    spin_direction = np.sign(np.sum(neighbor_spins))
    if spin_direction > 0:
      priorities[i][1] += 2
    elif spin_direction < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 2
#version_generated: 2
#generate time09:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]>0]), 
               -total_spin - sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]<0])]
    else:
      priorities[i] = [-total_spin - sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]>0]), 
               total_spin + sum([J[j,i//N,i//N] for j in range(4) if J[j,i//N,i//N]<0])]
    
  return(priorities)




#score: {'data2D.txt': 0.043781944444444436}
#island_id: 2
#version_generated: 2
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

    # Add a term to prioritize spins that have higher magnetism and lower entropy
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 2
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16575601851851876}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][0] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum(np.abs(h[site_nbr]))
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum(np.abs(h[site_nbr]))

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2

    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001486574074074074}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006193364197530864}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if J[0,i//N,i//N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]) - h[site_nbr][i%N])
    
    if total_spin > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.183339351851852}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same row (if exists)
    if i % N < N - 1:
      j = i//N
      if J[0, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)) + (int(i % N < N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.183339351851852}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same row (if exists)
    if i % N < N - 1:
      j = i//N
      if J[0, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)) + (int(i % N < N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.05971126543209882}
#island_id: 0
#version_generated: 2
#generate time10:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(J[:,i%N,:], axis=0)[l]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.07022854938271607}
#island_id: 2
#version_generated: 2
#generate time10:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate magnetism-based priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += abs(total_spin)
      priorities[i][1] -= abs(total_spin)
    else:
      priorities[i][0] -= abs(total_spin)
      priorities[i][1] += abs(total_spin)
  
  # Calculate interaction-based priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_interactions = [J[0,i%N,i//N], J[1,(i+1)%N,i//N], J[2,i%N,(i+N-1)%N], J[3,(i+N-1)%N,i//N]]
    
    if sum(neighbor_interactions) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_interactions) < 0:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.05008287037037037}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    neighbor_energy = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_energy += 1
      else:
        neighbor_energy -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_energy, -total_spin - neighbor_energy]
    else:
      priorities[i] = [-total_spin - neighbor_energy, total_spin + neighbor_energy]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2

    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2

  return(priorities)




#score: {'data2D.txt': 0.12793811728395077}
#island_id: 2
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
  return(priorities)




#score: {'data2D.txt': -0.27832638888888905}
#island_id: 1
#version_generated: 2
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum(h[i//N][i%N])
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.04221311728395062}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = np.sum(h[i//N])
    
    priorities[i] = [total_spin + magnetism, -total_spin - magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.15648533950617302}
#island_id: 1
#version_generated: 2
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + ((i+N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N] + h[site_nbr3][i%N] + h[site_nbr4][i//N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,(i+N-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0014427469135802472}
#island_id: 1
#version_generated: 2
#generate time10:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Initialize total spin based on magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with next-nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Sort priorities by total spin
    priorities[i] = np.sort(priorities[i])
  
  return(priorities)




#score: {'data2D.txt': 0.16501589506172862}
#island_id: 1
#version_generated: 2
#generate time10:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.008586882716049384}
#island_id: 2
#version_generated: 2
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
    
    # Check for the case where the magnetism at site is high and energy is low, prioritize the spin with lower entropy
    if h[i//N][i%N] > 0.5 and total_spin < -0.1:
      if np.random.rand() < 0.5:
        priorities[i][0] -= 4
      else:
        priorities[i][1] += 4
    
    # Check for the case where the magnetism at site is low and energy is high, prioritize the spin with higher entropy
    elif h[i//N][i%N] < -0.5 and total_spin > 0.1:
      if np.random.rand() < 0.5:
        priorities[i][0] += 4
      else:
        priorities[i][1] -= 4
  
  return(priorities)




#score: {'data2D.txt': 0.0004180555555555553}
#island_id: 2
#version_generated: 2
#generate time10:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0.5:
      priorities[i][1] += 3
    elif h[i//N][i%N] < 0 and total_spin < -0.5:
      priorities[i][0] -= 3
    
    # Add a term to prioritize spins that have lower entropy
    if total_spin > 0.25:
      priorities[i][1] += 2
    elif total_spin < -0.25:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0011143518518518523}
#island_id: 2
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum([abs(p) for p in neighbor_spins])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum([abs(p) for p in neighbor_spins])
    
  return(priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # Prioritize spins based on magnetism and interactions
    if h[site_nbr][i % N] > 0:
      priorities[i][1] += abs(total_spin)
    else:
      priorities[i][0] += abs(total_spin)
  
  return (priorities)




#score: {'data2D.txt': 0.15370756172839525}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
    # Add magnetism and interaction information for each site
    if h[site_nbr][i % N] > 0:
      priorities[i][1] -= 2 * np.sum(neighbors_spin)
    else:
      priorities[i][0] -= 2 * np.sum(neighbors_spin)
  return (priorities)




#score: {'data2D.txt': -0.3429427469135792}
#island_id: 0
#version_generated: 2
#generate time10:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] += abs(total_spin) * (total_spin > 0) + 2
      priorities[i][1] -= abs(total_spin) * (total_spin < 0) - 2
    else:
      priorities[i][0] -= abs(total_spin) * (total_spin < 0) - 2
      priorities[i][1] += abs(total_spin) * (total_spin > 0) + 2
      
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(0, total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -max(0, total_spin)
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and the site magnetism
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])) + abs(h[site_nbr][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and their strengths
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.024325771604938297}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    total_spin /= np.sum([int(J[0, i%N, l]) + int(J[1, i%N, l]) + int(J[2, i%N, l]) + int(J[3, i%N, l]) for l in range(N)])

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.22146126543209874}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate magnetism at each site
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10403287037037046}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priority based on magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.035832870370370355}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]

  # Combine interactions with magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])
      priorities[i][1] -= priorities[i][0]
    else:
      priorities[i][0] -= sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1398489197530865}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.10403287037037046}
#island_id: 3
#version_generated: 2
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] < 0])) * N
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum([J[k,i%N,i//N] for k in range(4) if J[k,i%N,i//N] > 0])) * N
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0006538580246913579}
#island_id: 1
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin-1]
    else:
      priorities[i] = [-total_spin-1, total_spin+1]
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 2
#version_generated: 2
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 2
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    priorities[i][0] = max(-1, min(1, total_spin))  # prioritize -1 if spin is close to -1 and vice versa
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.02115385802469136}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.10365416666666676}
#island_id: 3
#version_generated: 2
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
    
    # Add a correction term based on the number of neighbors
    num_neighbors = len(neighbors)
    priorities[i][0] += (num_neighbors - sum([J[j,i//N,i%N] for j in range(4)])) / 2
    priorities[i][1] -= priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.09228379629629638}
#island_id: 1
#version_generated: 2
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 2
      priorities[i][1] += 2
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11428132716049395}
#island_id: 1
#version_generated: 2
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.11441219135802481}
#island_id: 1
#version_generated: 2
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site interactions and magnetism
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,j] > 0:
        priorities[i][0] += h[site][j]
        priorities[i][1] -= h[site][j]
      else:
        priorities[i][0] -= h[site][j]
        priorities[i][1] += h[site][j]
  
  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2119233024691358}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 3
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.009270524691358023}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= sum(np.abs(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.15358595679012366}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])) * N
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])) * N
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.3390458333333323}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0]) - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.3009668209876545}
#island_id: 3
#version_generated: 2
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0] or [-x for x in [J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0]])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] < 0])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[j,i//N,i%N] for j in range(4) if J[j,i//N,i%N] > 0])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.22308996913580237}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    num_neighbors = 4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i%8<4))
    total_spin /= num_neighbors
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14239521604938285}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      j, l = i//N + k, k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19795262345679016}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if j < N - 1 or ((i % N == 0 or i % N == N - 1)):
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16599336419753097}
#island_id: 0
#version_generated: 2
#generate time10:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += h[j][i%N]
      else:
        total_spin -= h[j][i%N]
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += h[i//N][l]
      else:
        total_spin -= h[i//N][l]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0010128086419753087}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total spin based on J and h
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    num_neighbors = sum([1 for k in [0, 1, 2] if i//N + ((k-1)%2 - 1) % N >= 0 and i//N + ((k-1)%2 - 1) % N < N])
    priorities[i] = [-total_spin/num_neighbors, total_spin/num_neighbors]
  
  return(priorities)




#score: {'data2D.txt': 0.16632453703703712}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
        
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
        
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': -0.002005709876543209}
#island_id: 0
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    for k in [0,2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    n_neighbors = 4 if i % N > 0 or i % N == N - 1 else 3
    priorities[i] = [total_spin + total_spin/n_neighbors, -total_spin - total_spin/n_neighbors]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction from all four neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priority based on site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.07096990740740745}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with the site's own magnetism
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interactions with the site's own spin
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum the interactions from the four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust based on site magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.001962191358024691}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_top = (i - N) % N
    site_nbr_bot = (i + N) % N
    site_nbr_left = i % N
    site_nbr_right = (i // N * N + (i % N + 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.0037131172839506175}
#island_id: 1
#version_generated: 2
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in [0,1]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.02346929012345679}
#island_id: 1
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin += np.sum(h[i//N][:]) + np.sum([J[3,j,i//N] for j in range(N)])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.14643966049382717}
#island_id: 1
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_val = h[site_nbr][i%N] + J[0,i%N,i//N]
    else:
      h_val = h[site_nbr][i%N] - J[0,i%N,i//N]

    if J[1,i%N,i//N] > 0:
      h_val += J[1,i//N,i%N]
    else:
      h_val -= J[1,i//N,i%N]

    if J[2,i//N,i%N] > 0:
      h_val += J[2,i//N,i%N]
    else:
      h_val -= J[2,i//N,i%N]

    if J[3,(i+1)%N,i//N] > 0:
      h_val += J[3,(i+1)%N,i//N]
    elif i % N != (N-1):
      h_val -= J[3,i%N,i//N]
    
    priorities[i][0] = -h_val
    priorities[i][1] = h_val
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16709645061728406}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.2179081790123457}
#island_id: 3
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
    # Add the magnetism as a priority
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 2 - J[j,i//N,i%N]
      else:
        total_spin -= J[j,i//N,i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.000672993827160493}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, (i+1)%N] > 0:
      total_spin += 1
    elif J[0, i%N, (i+1)%N] < 0:
      total_spin -= 1
    
    if J[1, i%N, ((i-1)%N+N)%N] > 0:
      total_spin += 1
    elif J[1, i%N, ((i-1)%N+N)%N] < 0:
      total_spin -= 1
    
    if J[2, (i//N)%N, i%N] > 0:
      total_spin += 1
    elif J[2, (i//N)%N, i%N] < 0:
      total_spin -= 1
    
    if J[3, ((i-1)%N+N)//N, i%N] > 0:
      total_spin += 1
    elif J[3, ((i-1)%N+N)//N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017390432098765443}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009427469135802467}
#island_id: 0
#version_generated: 2
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        
    if total_spin > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
      
  return(priorities)




#score: {'data2D.txt': 5.910493827160484e-05}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[k,i%N,i//N] for k in range(4))
      priorities[i][1] -= sum(J[k,i%N,i//N] for k in range(4))
    else:
      priorities[i][0] -= sum(J[k,i%N,i//N] for k in range(4))
      priorities[i][1] += sum(J[k,i%N,i//N] for k in range(4))
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[3,i%N,j] for j in range(N))
      priorities[i][1] -= sum(J[3,i%N,j] for j in range(N))
    else:
      priorities[i][0] -= sum(J[3,i%N,j] for j in range(N))
      priorities[i][1] += sum(J[3,i%N,j] for j in range(N))
  
  return(priorities)




#score: {'data2D.txt': -0.01202145061728395}
#island_id: 1
#version_generated: 2
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbrs = []
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((i % N + ((k-1)%2 - 1)) % N)
      else:
        site_nbrs.append(-1)
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        site_nbrs.append(site_nbr)
      else:
        site_nbrs.append(-1)
    if h[i//N][i%N] > 0:
      for spin in site_nbrs:
        total_spin += h[spin][i%N]
      priorities[i] = [total_spin, -total_spin]
    else:
      for spin in site_nbrs:
        total_spin -= h[spin][i%N]
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.05661404320987656}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]

    if J[2,(i+1)%N,i//N] > 0:
      priorities[i][0] += h[(i+1)%N][i%N]
      priorities[i][1] -= h[(i+1)%N][i%N]
    else:
      priorities[i][0] -= h[(i+1)%N][i%N]
      priorities[i][1] += h[(i+1)%N][i%N]

    if J[3,(i+N)%N//N,i%N] > 0:
      priorities[i][0] += h[(i+N)%N//N][(i%N+N)%N]
      priorities[i][1] -= h[(i+N)%N//N][(i%N+N)%N]
    else:
      priorities[i][0] -= h[(i+N)%N//N][(i%N+N)%N]
      priorities[i][1] += h[(i+N)%N//N][(i%N+N)%N]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin from magnetism and nearest neighbor interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0008415123456790122}
#island_id: 0
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for d in [(i//N-1, i%N), (i//N+1, i%N)]:
      if 0 <= d[0] < N:
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Add interaction with the site diagonally above and below (if exists)
    for d in [(i//N-1, (i%N+1) % N), (i//N+1, (i%N-1) % N)]:
      if 0 <= d[0] < N and 0 <= d[1] < N:
        if J[3, i%N, d[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i//N+1)%N > 0) + int((i%N+1) % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': -0.00027268518518518516}
#island_id: 0
#version_generated: 2
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin = np.zeros((N*N, 1))

  # Calculate the total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[i] = np.sum([J[k, i%N, j] for k in range(4) for j in [(k+1)%2, (k-2)%2]])
      total_spin[i] += np.sum([J[3, i%N, j] for j in [(i//N-1)%N, (i//N+1)%N]] if 0 <= (i//N-1) < N and 0 <= (i%N-1) < N else [] if 0 <= (i//N+1) < N and 0 <= (i%N+1) % N < N else [])
    else:
      total_spin[i] = -np.sum([J[k, i%N, j] for k in range(4) for j in [(k+1)%2, (k-2)%2]])
      total_spin[i] -= np.sum([J[3, i%N, j] for j in [(i//N-1)%N, (i//N+1)%N]] if 0 <= (i//N-1) < N and 0 <= (i%N-1) < N else [] if 0 <= (i//N+1) < N and 0 <= (i%N+1) % N < N else [])

  # Assign priorities based on the total spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin[i]
      priorities[i][1] = -total_spin[i]
    else:
      priorities[i][0] = -total_spin[i]
      priorities[i][1] = total_spin[i]

  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]

  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Compute magnetism and interaction sums
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin[i][j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin[i//N][i%N][0] += 1
        total_spin[i//N][i%N][1] -= 1
      else:
        total_spin[i//N][i%N][0] -= 1
        total_spin[i//N][i%N][1] += 1
    
    # Normalize by the number of neighbors
    for j in range(2):
      total_spin[i//N][i%N][j] /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N][i%N][0], -total_spin[i//N][i%N][1]]
    else:
      priorities[i] = [-total_spin[i//N][i%N][0], total_spin[i//N][i%N][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0020319444444444443}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    total_spin += np.sum(np.sign(J[:,i%N,i//N]) * (np.abs(J[:,i%N,i//N])))
    total_spin /= 2 + np.sum(np.abs(J[:,i%N,i//N]))
    
    # Add magnetism term and normalize by the number of neighbors
    total_spin += h[i//N][i%N]
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11321929012345697}
#island_id: 2
#version_generated: 2
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.06548163580246916}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(2):
     site_nbr = (i % N + ((k)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
     site_nbr = (i % N + ((j)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       priorities[i][0] += h[site_nbr][j]
       priorities[i][1] -= h[site_nbr][j]
     else:
       priorities[i][0] -= h[site_nbr][j]
       priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.0006479938271604933}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in [(i//N-1)%N if i%N > 0 else N-1, (i//N+1)%N if i%N < N-1 else 0,
         ((i-1)//N)%N if i % N > 0 else N-1, (i+1)//N if i % N < N-1 else 0]:
      site_nbr = k*N + (i % N)
      total_spin += J[0,k//N,i//N] * h[k//N][i%N]
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.05039120370370371}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    mag = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if h[site_nbr][i%N] > 0:
        mag += 1
      else:
        mag -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - mag, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + mag]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + sum(J[:,i//N,i//N]) + abs(h[site_nbr][i%N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.13388101851851872}
#island_id: 3
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[:,i//N,i//N]))
    
    # Calculate the magnetism at this site
    mag = h[i//N][i%N]
    
    # Add a bonus for aligning with the local magnetism if it's high enough
    if abs(mag) > 0.5:
      total_spin += mag
    
    if mag > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and the magnetism at this site
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])) + np.abs(h[site_nbr][i%N]))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on J and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(total_spin)
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.16381836419753115}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
  
  return(priorities)




#score: {'data2D.txt': 0.20244336419753103}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.00038996913580246844}
#island_id: 2
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i//N].flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00019336419753086353}
#island_id: 0
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if J[0, i//N, i//N] == J[2, i//N, i//N]:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-np.abs(total_spin), total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08056558641975314}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][0] = -priorities[i][1]
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.19540756172839527}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.20244336419753103}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 1
#version_generated: 2
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(J[:,i//N,i//N])
      priorities[i][1] = -total_spin - sum(J[:,i//N,i//N])
    else:
      priorities[i][0] = -total_spin - sum(J[:,i//N,i//N])
      priorities[i][1] = total_spin + sum(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.1072547839506174}
#island_id: 1
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N]
      priorities[i][1] -= 2*h[site_nbr][i%N]
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N]
      priorities[i][1] += 2*h[site_nbr][i%N]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.15516404320987676}
#island_id: 1
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    total_spin_row = h[site_nbr_row][i%N]
    total_spin_col = J[3,i//N,i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_row + total_spin_col, -total_spin - total_spin_row - total_spin_col]
    else:
      priorities[i] = [-total_spin - total_spin_row - total_spin_col, total_spin + total_spin_row + total_spin_col]
    
  return(priorities)




#score: {'data2D.txt': 0.006115277777777777}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
      
  return(priorities)




#score: {'data2D.txt': -0.0006757716049382714}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]
  
  # Sort the priorities for each site based on their absolute value
  priorities = priorities[np.argsort(np.abs(priorities[:,0])),:]
  
  return(priorities)




#score: {'data2D.txt': 0.16381836419753115}
#island_id: 2
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    # Calculate the total spin
    total_spin = h[site_nbr][i%N]

    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - (h[site_nbr][i%N]*2), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin - (h[site_nbr][i%N]*2)]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(i+1)%N, (i-N)%N, (i+N)%N, (i-1)%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 2 * np.count_nonzero(J[:, i//N, i%N] == J[j, i//N, i%N])
      else:
        total_spin -= 2 * np.count_nonzero(J[:, i//N, i%N] == J[j, i//N, i%N])
    
    # Normalize by the number of neighbors
    total_spin /= 8
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin = np.sign(total_spin)
    
    priorities[i][0] = sum([abs(J[j,i//N,i%N]) for j in range(4) if J[j,i//N,i%N] < 0])
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.11549737654320998}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.11549737654320998}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.1661365740740742}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [0, 3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.166851388888889}
#island_id: 0
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/4, -total_spin_sum - total_spin_sum/4]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/4, total_spin_sum + total_spin_sum/4]
  
  return(priorities)




#score: {'data2D.txt': 0.12932916666666688}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + abs(h[i//N][i%N])
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + abs(h[i//N][i%N])
  
  return(priorities)




#score: {'data2D.txt': 0.18157577160493849}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
    
    # Add the interaction with the next site
    next_site_nbr = (i+1) % N
    if i%N == N - 1:
      next_site_nbr = 0
    next_site_magnetism = h[next_site_nbr//N][next_site_nbr%N]
    priorities[i][0] += abs(next_site_magnetism)
    priorities[i][1] -= abs(next_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.19540756172839527}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus term for sites that have a high magnetism value
    site_magnetism = h[i//N][i%N]
    if site_magnetism > 0:
      priorities[i][1] += site_magnetism
    else:
      priorities[i][0] -= site_magnetism
    
    # Add the interaction with the previous site
    prev_site_nbr = (i-1) % N
    if i%N == 0:
      prev_site_nbr = N - 1
    prev_site_magnetism = h[prev_site_nbr//N][prev_site_nbr%N]
    priorities[i][0] += abs(prev_site_magnetism)
    priorities[i][1] -= abs(prev_site_magnetism)
  
  return(priorities)




#score: {'data2D.txt': 0.030540277777777774}
#island_id: 2
#version_generated: 2
#generate time10:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum(abs(J[k,i%N,i//N]) for k in range(4))
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + sum(abs(J[k,i%N,i//N]) for k in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.19991188271604937}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,(k+2)%2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [3]:
      j = i//N + ((k-3)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: priorities[i][0] += total_spin
    if i % N == 0 or i % N == N - 1: priorities[i][1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0] + total_spin/2, -priorities[i][1] - total_spin/2]
    else:
      priorities[i] = [-priorities[i][0] - total_spin/2, priorities[i][1] + total_spin/2]
  
  return(priorities)




#score: {'data2D.txt': -0.14354490740740752}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = 0
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum /= 4
    if i % N == 0 or i % N == N - 1: total_spin_sum /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + 1, -total_spin_sum - 1]
    else:
      priorities[i] = [-total_spin_sum - 1, total_spin_sum + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.16507916666666678}
#island_id: 0
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + total_spin_sum/3, -total_spin_sum - total_spin_sum/3]
    else:
      priorities[i] = [-total_spin_sum - total_spin_sum/3, total_spin_sum + total_spin_sum/3]
  
  return(priorities)




#score: {'data2D.txt': 0.17828996913580272}
#island_id: 1
#version_generated: 2
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_col = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_row = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
    if J[2,i//N,i//N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    
    if J[3,i//N,N-1-i%N] > 0:
      priorities[i][0] += h[i//N][N-1-i%N]
      priorities[i][1] -= h[i//N][N-1-i%N]
    else:
      priorities[i][0] -= h[i//N][N-1-i%N]
      priorities[i][1] += h[i//N][N-1-i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.010661265432098766}
#island_id: 1
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr2][i%N]
    
    priorities[i][0] = total_spin * 0.5
    priorities[i][1] = -total_spin * 0.5
    
  return(priorities)




#score: {'data2D.txt': 0.16525478395061755}
#island_id: 1
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.07039336419753092}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    # Add interaction with the site to the left and right (if exists)
    if i % N != 0:
      j = i % N - 1
      left, right = J[1, i%N, :2]
      total_spin += left.sum()
      total_spin /= (4 + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33865015432098666}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    # Calculate the priority based on the magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - len([k for k in range(4) if J[k, i%N, l] < 0]), total_spin + len([k for k in range(4) if J[k, i%N, l] > 0])]
    else:
      priorities[i] = [-total_spin + len([k for k in range(4) if J[k, i%N, l] > 0]), -total_spin - len([k for k in range(4) if J[k, i%N, l] < 0])]
  
  return(priorities)




#score: {'data2D.txt': -0.33362978395061627}
#island_id: 0
#version_generated: 2
#generate time10:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.056942129629629655}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority = np.array([-total_spin, total_spin]) * (h[i//N][i%N] > 0)
    
    priorities[i] = priority
  
  for j in range(N):
    for i in range(N**2):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16545941358024718}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i%N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.16574398148148173}
#island_id: 1
#version_generated: 2
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_col][i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_neighbors = np.sum(np.abs(J[:,i%N,i//N]))
    total_spin /= (2 + total_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort the priorities
  for i in range(N**2):
    priorities[i][0], priorities[i][1] = sorted([priorities[i][0], priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(np.abs(J[:,i%N,i//N])))
    
    # Add magnetism to priority
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09154182098765441}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    site_magnetism = h[i//N][i%N]
    
    spin_priority = (site_magnetism + total_spin) / 2
    
    priorities[i][1] = spin_priority
    priorities[i][0] = -spin_priority
    
  return(priorities)




#score: {'data2D.txt': -0.08351682098765431}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    site_magnetism = h[i//N][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        site_magnetism += 1
      else:
        site_magnetism -= 1
        
    priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
    priorities[i][0] = -priorities[i][1]
    
  return(priorities)




#score: {'data2D.txt': 0.03718472222222224}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][0] = -priorities[i][1] - total_spin
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2
      priorities[i][1] = -priorities[i][0] + total_spin
   
  return(priorities)




#score: {'data2D.txt': 0.08133256172839512}
#island_id: 2
#version_generated: 2
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    site_magnetism = h[i//N][i%N]
    
    if site_magnetism > 0:
      priorities[i][1] = (site_magnetism + np.sum(J[:,i//N,i//N])) / 2 - J[1,i//N,i//N]
      priorities[i][0] = -priorities[i][1]
    else:
      priorities[i][0] = -(site_magnetism + np.sum(J[:,i//N,i//N])) / 2 + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.1625751543209879}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i // N) % N
    site_nbr_col = i % N
    if J[3,site_nbr_col,site_nbr_row] > 0:
      total_spin += h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin from magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Assign spin based on priority
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1980516975308642}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1982109567901235}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17393194444444451}
#island_id: 0
#version_generated: 2
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = ((i//N+k-2)%N), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for j in range(2):
      if i//N > 0:
        l = i//N - 1
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
        l = i//N + 1
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Sum up the interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism at the site
    total_spin += h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i // N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priorities based on magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11477114197530879}
#island_id: 1
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0 and J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    elif J[0,i%N,i//N] < 0 and J[3,i%N,i//N] < 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.11256959876543224}
#island_id: 1
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] /= 4
    priorities[i][1] /= 4
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.11216496913580261}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i] = [total_spin, -total_spin]
      else:
        priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = ((i//N + ((k-1)%2 - 1)) % N) * N + (i%N)
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 2
#version_generated: 2
#generate time10:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Update priorities based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0018492283950617293}
#island_id: 3
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
  return(priorities)




#score: {'data2D.txt': 0.09523441358024706}
#island_id: 0
#version_generated: 2
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a further bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] += abs(h[i//N][i%N]) * 2
    else:
      priorities[i][1] -= abs(h[i//N][i%N]) * 2
    
  return(priorities)




#score: {'data2D.txt': 0.11584243827160508}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = i // N
    site_nbr_col = i % N
    
    for j in range(N):
      if J[3,site_nbr_col,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017007716049382718}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in [0,1,2]:
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]

    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.2301239197530864}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally up and left (if exists)
    if i % N > 0 and i//N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[3, i%N-1, i//N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally up and right (if exists)
    if i % N < N-1 and i//N > 0:
      j = i//N - 1
      l = i%N + 1
      if J[3, i%N+1, i//N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally down and left (if exists)
    if i % N > 0 and i//N < N-1:
      j = i//N + 1
      l = i%N - 1
      if J[3, i%N-1, i//N+1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally down and right (if exists)
    if i % N < N-1 and i//N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[3, i%N+1, i//N+1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (8 - int(i//N > 0) - int((i%N-1)%2 == 0) - int((i%N+1)%2 == 0) - int(i//N < N-1) - int((i%N-1)%2 == 0) - int((i%N+1)%2 == 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias for sites with no neighbors
    if i % N == 0 or i % N == N-1 or (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.1872470679012347}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and adjust for boundary conditions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Adjust for boundary conditions
      if k == 0 and i//N > 0: 
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if k == 2 or k == 3: 
        j = i//N + ((k-2)%2 - 1)
        l = i%N
        if J[k, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Add a bias for sites with no neighbors
  for i in range(N**2):
    if (i % N == 0 or i % N == N-1) and (i//N) % N != 0 and (i//N) % N != N-1:
      priorities[i][0] += 0.5
      priorities[i][1] -= 0.5
      
    if (i//N) % N == 0 or (i//N) % N == N-1:
      priorities[i][0] += 0.25
      priorities[i][1] -= 0.25
        
  return(priorities)




#score: {'data2D.txt': 0.07263441358024697}
#island_id: 0
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.07079089506172843}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spins that align with local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin-1]
    else:
      priorities[i] = [-total_spin-1, total_spin+1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11559922839506186}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * (h[site_nbr][i%N] == h[i//N][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0018492283950617293}
#island_id: 3
#version_generated: 2
#generate time10:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 * N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1048091049382717}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] > 0:
        total_spin -= 1
      elif (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] < 0:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0006692901234567905}
#island_id: 3
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if J[k,i//N,N-1-(i%N)] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 1
    
  return(priorities)




#score: {'data2D.txt': -0.0007711419753086419}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  # Sort the priority list by spin value
  priorities = priorities[np.argsort(priorities[:,0])]
  
  return priorities




#score: {'data2D.txt': -0.03794737654320987}
#island_id: 2
#version_generated: 2
#generate time10:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': 0.11632885802469149}
#island_id: 1
#version_generated: 2
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[0,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with other sites on the same row and column
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Adjust priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11150694444444458}
#island_id: 1
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr1 = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr1][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism and interaction
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.005365586419753086}
#island_id: 3
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + int(i % N == 0)) * abs(h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004958179012345679}
#island_id: 3
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      if i % N == 0: 
        continue
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 - int(i % N == 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Additional consideration for the priority
    if np.sum(neighbors_spin) > 0:
      priorities[i][1] += 1
    elif np.sum(neighbors_spin) < 0:
      priorities[i][0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Sum up interactions from 4 nearest neighbors
    for j in range(4):
      total_spin += J[j,i//N,i%N]
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0036350308641975313}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum([J[k,i//N,i%N] * (h[(i+k)%N][k]%N) for k in range(4)])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2.0
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0023782407407407402}
#island_id: 1
#version_generated: 2
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][j] > 0:
        total_spin += J[3,i%N,j]
      else:
        total_spin -= J[3,i%N,j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11042916666666679}
#island_id: 3
#version_generated: 2
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in [2, 3]:
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        total_spin -= 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1048091049382717}
#island_id: 3
#version_generated: 2
#generate time10:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
     if J[k,i%N,i//N] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    for k in [2, 3]:
     if (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] > 0:
      total_spin -= 1
     elif (i + ((k-1)%2 - 1)) % N != i // N and J[k,i%N,i//N] < 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Calculate total spin from magnetism and nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[j,i%N,i//N] * h[site_nbr][i%N]
    
    # Calculate priority based on magnetism and nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time10:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0022674382716049387}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priority based on magnetism and interactions
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [h[site_nbr][i%N], -h[site_nbr][i%N]]
    else:
      priorities[i] = [-h[site_nbr][i%N], h[site_nbr][i%N]]
    
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        priorities[i][0] += J[k, i//N, i%N]
        priorities[i][1] -= J[k, i//N, i%N]
      else:
        priorities[i][0] -= J[k, i//N, i%N]
        priorities[i][1] += J[k, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_1 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr_2 = (i % N + ((i//N-1)%2 - 1)) % N
    if i%N > 0:
      total_spin += h[site_nbr_1][i%N]
      total_spin -= h[site_nbr_2][i%N]
    
    if i//N < N-1:
      site_nbr = (i % N + ((i//N+1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10953719135802481}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_list = []
    
    # Sum interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      site_nbr_list.append((i % N + ((k-1)%2 - 1)) % N)
    
    # Sum magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interactions with next nearest neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        site_nbr_list.append(site_nbr)
      else:
        total_spin -= h[site_nbr][j]
    
    # Determine priority for each possible spin assignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.03256558641975308}
#island_id: 1
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = sum(J[:,i//N,i%N]) - 2 * J[3,i//N,i%N]
      priorities[i] = [total_spin, -total_spin]
    else:
      total_spin = sum(J[:,i//N,i%N]) + 2 * J[3,i//N,i%N]
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.01840200617283945}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  # Calculate total spin at each site
  total_spin_sum = np.zeros(2)
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.3359726851851842}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above
    k = 0
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    k = 2
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.000977623456790119}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    neighbor_contributions = []
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        contribution = np.sign(J[k,i%N,l]) * np.sign(h[site_nbr][i%N])
        neighbor_contributions.append(contribution)
    
    for k in [0, 2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        contribution = np.sign(J[k,i%N,l]) * np.sign(h[site_nbr][i%N])
        neighbor_contributions.append(contribution)
    
    total_spin += sum(neighbor_contributions)
    total_spin_sum[0] += sum(x for x in neighbor_contributions if x > 0) / len(neighbor_contributions)
    total_spin_sum[1] += sum(x for x in neighbor_contributions if x < 0) / len(neighbor_contributions)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 7.299382716049382e-05}
#island_id: 0
#version_generated: 2
#generate time10:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = 0
    
    # Add neighbor interactions
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Normalize by the number of neighbors
    priorities[i][0] = total_spin_sum + h[site_nbr][i%N]
    priorities[i][1] = -total_spin_sum - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0003649691358024707}
#island_id: 1
#version_generated: 2
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[s][i%N] if J[k,i%N,i//N]>0 else -h[s][i%N] for s,k in zip(site_nbrs, [3]+list(range(4))))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add the interaction from neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (np.count_nonzero(J[:,i//N,i%N]) + 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k+2,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i] = [h[site_nbr][i%N], -h[site_nbr][i%N]]
  
  # Add interactions with nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i] += np.sum(J[:,i//N,i%N], axis=0)
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16626990740740763}
#island_id: 1
#version_generated: 2
#generate time10:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_top = (i % N + ((N-1)%2 - 1)) % N
    site_nbr_bottom = (i % N + ((0)%2 - 1)) % N
    if J[3,i%N,N-1-i//N] > 0:
      total_spin += h[site_nbr_top][i%N]
      total_spin -= h[site_nbr_bottom][i%N]
    else:
      total_spin -= h[site_nbr_top][i%N]
      total_spin += h[site_nbr_bottom][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time11:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        for j in range(N):
          if i == j*N + site_nbrs[j]:
            priorities[i][0] += h[site_nbrs[j]][j]
            priorities[i][1] -= h[site_nbrs[j]][j]
      else:
        for j in range(N):
          if i == j*N + site_nbrs[j]:
            priorities[i][0] -= h[site_nbrs[j]][j]
            priorities[i][1] += h[site_nbrs[j]][j]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1954961419753089}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.0
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11292361111111124}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Add site magnetism term
    total_spin += h[i//N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.0
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.10487638888888899}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i + ((3)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Add diagonal interactions
    site_nbr3 = (i + ((4)%2 - 1)) % N
    if J[3,i//N,i%N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[3,i//N,i%N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11529614197530878}
#island_id: 3
#version_generated: 2
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i + ((2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
      total_spin -= 1
    elif J[2,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.3373822530864187}
#island_id: 0
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above
    k = 0
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    k = 2
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    k = 3
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    k = 1
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.06651898148148154}
#island_id: 1
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction spin from left and right
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate interaction spin from top and bottom
    for k in range(N):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[3,i%N,k] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    # Set priority based on magnetism and interaction spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 1
#version_generated: 2
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin_sum = np.sum(J[:,i%N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + site_spin_sum, -total_spin - site_spin_sum]
    else:
      priorities[i] = [-total_spin - site_spin_sum, total_spin + site_spin_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.16527083333333356}
#island_id: 1
#version_generated: 2
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Magnetism contribution from site's own magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with next-nearest neighbors (if applicable)
    site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    # Update priorities
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16623780864197557}
#island_id: 1
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr_row][i%N]
    total_spin -= h[site_nbr_col][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
    
    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]

    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin

  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
    
    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16241712962962987}
#island_id: 2
#version_generated: 2
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Swap spin values if total_spin is close to 0
    if np.abs(total_spin) < 0.5:
      priorities[i] = [total_spin, -total_spin]
    elif h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Swap spin order if there is no net magnetism
    if abs(total_spin) < 1e-6:
      priorities[i] = [total_spin, -total_spin]
    elif h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    priorities[i][0] = -abs(total_spin)  # Priority for spin up
    priorities[i][1] = abs(total_spin)     # Priority for spin down
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 2
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin_value = -1 if total_spin < 0 else 1
    priorities[i] = [total_spin, 0]
    
  return(priorities)




#score: {'data2D.txt': 0.22919058641975318}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
    
    # Apply nearest neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += J[1,i%N,i//N]
      priorities[i][1] -= J[1,i%N,i//N]
    elif J[3,i%N,i//N] < 0:
      priorities[i][0] += J[3,i%N,i//N]
      priorities[i][1] -= J[3,i%N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  # Add interactions between next nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (2.0 * N)
    
    # Apply magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin / (abs(total_spin) + 1)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - total_spin / (abs(total_spin) + 1)
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Improve spin assignments based on current assignment
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i // N % 2 == (i % N + k) % 2:
        priorities[i][1] -= 1
      elif J[k,i%N,i//N] < 0 and i // N % 2 != (i % N + k) % 2:
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16771527777777787}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for k in range(2):
      j = (i//N + ((k-1)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate priority
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': -0.0005606481481481476}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    # Normalize by the number of neighbors
    priorities[i][0] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    priorities[i][1] /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
  
  return(priorities)




#score: {'data2D.txt': 0.1980516975308642}
#island_id: 0
#version_generated: 2
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.10791990740740752}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.16137145061728422}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i] = [total_spin, -total_spin]
    else:
      total_spin = -h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1737368827160496}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,(i+1)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if J[2,(i+N)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if J[3,(i+1)%N,i//N] > 0:
      total_spin += 1
    elif i%N == N-1 and (i+N)%N != 0:
        total_spin += h[i//N][0]
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0017473765432098767}
#island_id: 1
#version_generated: 2
#generate time11:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time11:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      site_nbr = ((i//N + (k%2 - 1)) % N) * N + (i%N + (k//2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0012526234567901238}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]

  # Sorting the spins based on their energy values
  sorted_indices = np.argsort(priorities, axis=1)
  for i in range(N**2):
    priorities[i] = priorities[i][sorted_indices[i]]

  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [(total_spin + np.sum(neighbors_spin)) * 2, -(total_spin + np.sum(neighbors_spin))]
    else:
      priorities[i] = [-(total_spin + np.sum(neighbors_spin)), (total_spin + np.sum(neighbors_spin)) * 2]
  return (priorities)




#score: {'data2D.txt': -0.3431294753086409}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] += np.sum(neighbors_spin) ** 2
      priorities[i][1] -= np.sum(neighbors_spin) ** 2
    else:
      priorities[i][0] -= np.sum(neighbors_spin) ** 2
      priorities[i][1] += np.sum(neighbors_spin) ** 2
  
  return priorities




#score: {'data2D.txt': 5.540123456790158e-05}
#island_id: 0
#version_generated: 2
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[0, i // N, i % N] * h[site_nbr][i % N]
    total_spin = h[i // N][i % N] + neighbors_spin
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2193884259259259}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.34276959876543106}
#island_id: 0
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += J[2, i%N, l]
      else:
        total_spin -= J[2, i%N, l]
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += J[0, i%N, l]
      else:
        total_spin -= J[0, i%N, l]
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.197765277777778}
#island_id: 1
#version_generated: 2
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # sum the magnetism of all neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # assign higher priority to sites with larger magnetism or more interacting neighbors
    if total_spin > 0 and np.sum([J[k,i%N,i//N] for k in range(4)]) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif total_spin < 0 and np.sum([J[k,i%N,i//N] for k in range(4)]) < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.16518225308641996}
#island_id: 1
#version_generated: 2
#generate time11:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-i%N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.026023302469135808}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if J[3,i//N,i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.00010694444444444484}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
      else:
        if h[site_nbr][i%N] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        if h[site_nbr][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
          priorities[i][1] += 1
      else:
        if h[site_nbr][j] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          priorities[i][1] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time11:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin * 2
    priorities[i][1] = -total_spin * 2
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
        
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust priorities at the boundary sites
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      j = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0, 1), (1, 3), (2, 3), (3, 1)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for neighboring sites and adjust priority
    if i > N:
      site_nbr = (i - N) % N
      total_spin += h[site_nbr][i%N]
    elif i < N*N-N:
      site_nbr = (i + N) % N
      total_spin -= h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust boundary sites' priorities
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    site_state = h[i//N][i%N]
    
    if site_state > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.12433750000000014}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = 0
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        neighbor_sum += 1
      else:
        neighbor_sum -= 1
    total_spin += neighbor_sum/4
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and distance from border sites
    neighbor_count = len(neighbors)
    if i % N == 0 or i % N == N-1 or (i // N) % N == 0 or (i // N) % N == N-1:
      neighbor_count -= 2
    
    total_spin /= neighbor_count
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14076867283950636}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (-1,0), (0,-1)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N, i*N+(i//N+1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
 
  return(priorities)




#score: {'data2D.txt': 0.11547731481481495}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on the total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total spin at each site considering nearest neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate magnetism contribution from neighboring sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 2.237654320987448e-05}
#island_id: 1
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,(i-1)%N] > 0:
      total_spin += 1
    elif J[1,i%N,(i-1)%N] < 0:
      total_spin -= 1
    
    if J[2,i%N,(i+1)%N] > 0:
      total_spin += 1
    elif J[2,i%N,(i+1)%N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.2236711419753086}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2236711419753086}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22321496913580244}
#island_id: 0
#version_generated: 2
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.06527608024691361}
#island_id: 0
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += h[j][l]
      else:
        total_spin -= h[j][l]
    
    priorities[i][0] = total_spin / (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1402807098765434}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00553503086419753}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0), (0,-1), (-1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on J
    for j in [(i-1)%N*N + i%N, (i+1)%N*N + i%N, i*N+(i//N-1)%N]:
      if J[0, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [(0,1), (1,0)]:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11553688271604948}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [0, 1] + [(k+1)%2 for k in range(3)]
    for j in neighbors:
      if J[j,i%N,(j+1)%2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.33063626543209784}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      j, l = i//N + k, k
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add diagonal interactions
    for k in [2, 3]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Normalize by the number of neighbors
    total_spin /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + (k-1)%2, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N

    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]

    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.23836249999999995}
#island_id: 1
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_bias = 0
    if h[i//N][i%N] > 0:
      spin_bias = -1
    else:
      spin_bias = 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]*h[site_nbr][j]
    
    priorities[i] = [total_spin, total_spin*spin_bias]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33579182098765337}
#island_id: 0
#version_generated: 2
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2, 3]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][total_spin>0] = -sum(np.array([abs(J[j,i//N,i//N]) for j in range(4)])) + abs(total_spin)
    priorities[i][total_spin<0] = sum(np.array([abs(J[j,i//N,i//N]) for j in range(4)]))
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      j = i // N
      if J[k, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority
    priority = [total_spin, -total_spin]
    
    priorities[i] = priority
  
  return(priorities)




#score: {'data2D.txt': -0.004007253086419754}
#island_id: 3
#version_generated: 2
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term to prioritize sites with higher magnetism
    if abs(total_spin) > N//4:
      if h[i//N][i%N] > 0:
        priorities[i][0] -= (abs(total_spin) - N//4)
      else:
        priorities[i][1] += (abs(total_spin) - N//4)
    
  return(priorities)




#score: {'data2D.txt': 0.2033467592592595}
#island_id: 0
#version_generated: 2
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin + h[i//N][i%N]
    priorities[i][1] = -total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.002278858024691359}
#island_id: 3
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      j = (k + 2*i%2) % N
      total_spin += J[k,i//N,j]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.025498919753086418}
#island_id: 1
#version_generated: 2
#generate time11:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(np.sign(J[:,i//N,i//N]))
      priorities[i][1] = -total_spin - np.sum(np.sign(1-J[:,i//N,i//N]))
    else:
      priorities[i][0] = -total_spin - np.sum(np.sign(J[:,i//N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.sign(1-J[:,i//N,i//N]))
    
  return(priorities)




#score: {'data2D.txt': 0.16262885802469157}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N//N-1] > 0:
      priorities[i][0] += h[site_nbr][N//N-1]
      priorities[i][1] -= h[site_nbr][N//N-1]
    else:
      priorities[i][0] -= h[site_nbr][N//N-1]
      priorities[i][1] += h[site_nbr][N//N-1]
  
  return(priorities)




#score: {'data2D.txt': -0.273673919753086}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = np.sum([J[k,i%N,i//N] * h[(site_nbr+k)%N][k%N] for k in range(4)])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism
    priorities[i][0] += h[i//N][i%N]
    priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.06789922839506175}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism and adjust spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[i//N][i%N]
      priorities[i][1] = -total_spin - h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + h[i//N][i%N]
      priorities[i][1] = total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.12994429012345693}
#island_id: 3
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin - J[0,i//N,i//N]]
    else:
      priorities[i] = [-total_spin - J[0,i//N,i//N], total_spin + J[0,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.11256959876543224}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.009599845679012346}
#island_id: 1
#version_generated: 2
#generate time11:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11429429012345692}
#island_id: 1
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0019047839506172869}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at each site
    spin_bias = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        spin_bias += J[k][i%N][l]
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        spin_bias += J[k][i%N][l]
    
    # Normalize by the number of neighbors
    if i//N > 0: spin_bias /= N
    if i % N == 0 or i % N == N - 1: spin_bias /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [spin_bias + spin_bias/2, -spin_bias - spin_bias/2]
    else:
      priorities[i] = [-spin_bias - spin_bias/2, spin_bias + spin_bias/2]
  
  return(priorities)




#score: {'data2D.txt': 0.1149436728395063}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_sum = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin_sum += 1
        else:
          total_spin_sum -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = (i//N + ((k-1)%2 - 1)) % N
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin_sum += J[k,i%N,l] * h[j][i%N]
    
    # Normalize by the number of neighbors
    if i//N > 0: 
      priorities[i][0] += total_spin_sum / 4
      priorities[i][1] -= total_spin_sum / 4
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin_sum/2
      priorities[i][1] -= total_spin_sum/2
    else:
      priorities[i][0] -= total_spin_sum/2
      priorities[i][1] += total_spin_sum/2
  
  return(priorities)




#score: {'data2D.txt': -0.00132175925925926}
#island_id: 0
#version_generated: 2
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k,i%N,l]
    
    # Add interactions with the site above, below, left and right
    for k in range(4):
     j = i//N + ((k-1)%2 - 1)
     if j >= 0 and j < N:
      l = (k+1)%2
      total_spin += J[k,i%N,l]
    
    # Normalize by the number of neighbors
    n_neighbors = sum(1 for _ in range(4) if i//N + ((i%N+k-1)%2 - 1) % N == site_nbr)
    priorities[i] = [total_spin/n_neighbors, -(total_spin+1)/n_neighbors]
  
  return(priorities)




#score: {'data2D.txt': 0.0045078703703703695}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = (k+1)%2, ((k-2)%2 - 1)
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = (site_nbr + N) % N
    if i//N < N - 1:
      if J[2, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    j = (site_nbr + N) % N
    if i//N < N - 1 or i%N in [0, N-1]:
      if J[3, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    j = (i//N*N + i%N) % N
    if i % N < N - 1:
      if J[1, i%N, j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N < N-1) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19743904320987662}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above diagonally (if exists)
    if i % N == 0 or i % N == N - 1 and i//N > 0:
      j = i//N - 1
      if J[3, 0 if i % N == 0 else N-1, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19755416666666673}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time11:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.17700972222222236}
#island_id: 0
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0

    # Add magnetism and nearest neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 3
    else:
      total_spin -= 3

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Add interactions with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Add interactions with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    # Normalize by the number of neighbors
    total_spin /= 5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -0.002411882716049382}
#island_id: 0
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i%N,i//N], axis=0)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Adjust the boundary sites
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': -0.012104166666666668}
#island_id: 2
#version_generated: 2
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total magnetism and interactions for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbor_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_spin += 1
      else:
        neighbor_spin -= 1
    
    # Calculate priority based on magnetism, interactions and neighbors' spin
    priorities[i][0] = total_spin + neighbor_spin/2
    priorities[i][1] = -total_spin - neighbor_spin/2
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
  
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
    
  return(priorities)




#score: {'data2D.txt': 0.16579922839506195}
#island_id: 2
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
    
    # Check for degenerate cases
    if np.isclose(total_spin, 0):
      priorities[i][0] = -0.1
      priorities[i][1] = 0.1
  
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a penalty for having different spins in neighboring sites
    site_spin = np.where(J[:, :, i//N] > 0, -1, 1).flatten()[site_nbr]
    if site_spin == h[site_nbr][i%N]:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.3427356481481471}
#island_id: 0
#version_generated: 2
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.34275262345678903}
#island_id: 0
#version_generated: 2
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  return(priorities)




#score: {'data2D.txt': -0.0011652777777777783}
#island_id: 0
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = len([k for k in range(4) if J[k, i%N, :].sum() < 0]) - len([k for k in range(4) if J[k, i%N, :].sum() > 0])
    else:
      total_spin = len([k for k in range(4) if J[k, i%N, :].sum() > 0]) - len([k for k in range(4) if J[k, i%N, :].sum() < 0])

    priorities[i][1] = -total_spin
    priorities[i][0] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.14076867283950636}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11532453703703717}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(-1, 2):
      for j in range(-1, 2):
        if (k != 0 and j != 0) or abs(k)+abs(j)>1:
          continue
        if J[k + 1, i%N, i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0010739197530864222}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      total_spin += J[k[0], i%N, site_nbr]
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
 
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3297538580246904}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 2 * J[k[0], i%N, site_nbr]
      else:
        total_spin -= 2 * J[k[0], i%N, site_nbr]
    
    # Normalize by the number of neighbors
    total_spin /= (len(neighbors) + 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14072608024691374}
#island_id: 3
#version_generated: 2
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(0,1), (1,0), (0,-1), (-1,0)]
    for k in neighbors:
      if J[k[0], i%N, site_nbr] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize the opposite spin when it's high
    if priorities[i][1] > 0.5:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      site_nbr = ((i//N + (k%2 - 1)) % N) * N + (i%N + (k//2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += 1
        site_nbr_sum -= 1
      else:
        total_spin -= 1
        site_nbr_sum += 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + abs(total_spin))
    site_nbr_sum /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.17819398148148172}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Add magnetism and neighbor interactions
    for k in [(0,i//N,i%N),(1,N-1-i//N,i%N),(2,i//N,0),(3,i//N,N-1-i%N)]:
      if J[k[0],k[1],k[2]] > 0:
        site_nbrs.append(1)
      else:
        site_nbrs.append(-1)
    
    # Normalize by the number of neighbors
    total_spin = np.sum(site_nbrs) / len(site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.16603842592592616}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of interactions
    total_spin /= (2 + (h[site_nbr][i%N] > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3390458333333323}
#island_id: 3
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i//N + (k%2 - 1)) % N * N + (i%N + (k//2 - 1)) % N 
                for k in range(4)]
    site_nbrs_weights = [J[k,i//N,i%N] if J[k,i//N,i%N] > 0 else -J[k,i//N,i%N]
                        for k in range(4)]
    
    total_spin = sum(site_nbrs_weights)
    # Normalize by the number of neighbors
    total_spin /= len(site_nbrs_weights)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11702669753086434}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Compute total spin based on site interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Adjust total spin based on magnetism and nearest neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(h[site_nbr])
      priorities[i][1] = -total_spin - np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    
    total_spin = h[site_nbr_row][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.165265277777778}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add contributions from horizontal and vertical neighbors
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add contribution from diagonal neighbor (if exists)
    if i % N < N // 2:  # check if diagonal neighbor exists
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priorities based on magnetism at site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001289043209876543}
#island_id: 1
#version_generated: 2
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[k,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on site interactions and magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on site magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return priorities




#score: {'data2D.txt': -0.0011791666666666663}
#island_id: 1
#version_generated: 2
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is at the boundary, adjust the priority
    if i < N or i >= N*N-N:
      priorities[i][1] += 0.5 * priorities[i][0]
    elif i < 2*N or i >= 2*N-1:
      priorities[i][0] += 0.5 * priorities[i][1]
  
  return(priorities)




#score: {'data2D.txt': 0.33460077160493734}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33460077160493734}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.03704861111111115}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Iterate over each site
  for i in range(N**2):
    total_spin_sum = 0
    # Add interactions with nearest neighbors
    for k in [(i-1)%N if i%N != 0 else N-1, (i+1)%N if i%N != N-1 else 0]:
      j = k % N + ((k//N-1)%2 - 1) * N
      if J[0,k,N-1-i%N] > 0:
        total_spin_sum += 1
      else:
        total_spin_sum -= 1
    # Add magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum + 1, -total_spin_sum - 1]
    else:
      priorities[i] = [-total_spin_sum - 1, total_spin_sum + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.018259413580246867}
#island_id: 0
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  # Initialize neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k][i%N][l]
    
    # Add interactions with the site above, below, left and right
    for k in [0, 1, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        total_spin += J[k][i%N][l]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + sum(J[j, i % N, i // N] > 0 for j in range(4)) + abs(h[site_nbr][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] *= -1

  return(priorities)




#score: {'data2D.txt': -0.11470540123456803}
#island_id: 1
#version_generated: 2
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    elif magnetism < 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i // N].flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.342745524691357}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # calculate additional term based on site's own spin
    if h[i // N][i % N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return (priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Prioritize spins with larger absolute value of the magnetism
  for i in range(N**2):
    if np.abs(priorities[i][1]) > np.abs(priorities[i][0]):
      priorities[i] = [priorities[i][1], -priorities[i][1]]
  
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.22671929012345685}
#island_id: 3
#version_generated: 2
#generate time11:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on total spin and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add an additional term that favors the same spin as the site above
    if i % N > 0:
      if h[(i-1)//N][(i-1)%N] > 0 and h[i//N][i%N] > 0:
        priorities[i][1] += 1
      elif h[(i-1)//N][(i-1)%N] < 0 and h[i//N][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add an additional term that favors the same spin as the site to the left
    if i % N > 0:
      if h[(i-1)//N][(i-1)%N] > 0 and h[i//N][i%N] > 0:
        priorities[i][1] += 1
      elif h[(i-1)//N][(i-1)%N] < 0 and h[i//N][i%N] > 0:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.0013797839506172838}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    
    # Calculate the total spin based on magnetism and interactions
    total_spin = h[site_nbr][i%N] + np.sum(neighbors)
    
    # Calculate priority for each possible spin value
    if total_spin > 0:
      priorities[i] = [total_spin - J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
      
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and neighbor interactions
    total_spin = h[site_nbr][i%N]
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Add a bias towards the site's own magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1620356481481484}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr_left = (i % N - 1 + ((i//N)%2 - 1)) % N
    site_nbr_right = (i % N + 1 + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_up][i%N]
      priorities[i][1] -= h[site_nbr_up][i%N]
    else:
      priorities[i][0] -= h[site_nbr_up][i%N]
      priorities[i][1] += h[site_nbr_up][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_down][i%N]
      priorities[i][1] -= h[site_nbr_down][i%N]
    else:
      priorities[i][0] -= h[site_nbr_down][i%N]
      priorities[i][1] += h[site_nbr_down][i%N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.04053657407407407}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if sum(J[k,i%N,j] for k, j in zip([3], site_nbrs)) > 0:
      priorities[i][0] += sum(h[j][i%N] for j in site_nbrs)
      priorities[i][1] -= sum(h[j][i%N] for j in site_nbrs)
    else:
      priorities[i][0] -= sum(h[j][i%N] for j in site_nbrs)
      priorities[i][1] += sum(h[j][i%N] for j in site_nbrs)
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    site_nbr_neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.04450416666666667}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.sum(J[:,site_nbr,i//N])
      priorities[i][1] -= np.sum(J[1:,site_nbr,i//N])
    else:
      priorities[i][0] -= np.sum(J[1:,site_nbr,i//N])
      priorities[i][1] += np.sum(J[:,site_nbr,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.3368229938271595}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
  
  # Improve the algorithm by considering the global magnetism
  global_magnetism = np.sum(h)
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] += [global_magnetism, -global_magnetism]
    else:
      priorities[i] += [-global_magnetism, global_magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i][0] = spin_bias
      priorities[i][1] = -spin_bias
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i][0] = -spin_bias
      priorities[i][1] = spin_bias
  return(priorities)




#score: {'data2D.txt': 0.20269583333333338}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int(i//N < N//2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21019614197530864}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left and right (if exists)
    if i%N > 0:
      j = i//N
      if J[3, i%N-1, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[2, i%N, i%N-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 + int(i//N > 0) + int(i//N < N//2) + int(i%N > 0) + int(i%N < N-1))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.1371208333333335}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        if h[j][l] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
      else:
        if h[j][l] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1
          
  return(priorities)




#score: {'data2D.txt': 0.18250725308641982}
#island_id: 0
#version_generated: 2
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int(i//N < N//2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.09038688271604947}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.sum(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.013313117283950618}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.5
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.07541188271604941}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    total_magnetism = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        total_magnetism += h[site_nbr][i%N]
      else:
        total_spin -= 1
        total_magnetism -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= 4
    total_magnetism /= N
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+total_magnetism, -total_spin+total_magnetism]
    else:
      priorities[i] = [-total_spin+total_magnetism, total_spin+total_magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.0062541666666666666}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.147665277777778}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.0771467592592593}
#island_id: 0
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[0:i//N+1,i//N]), -total_spin + np.sum(J[1:i//N+1,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[2:i//N+1,i//N]), total_spin + np.sum(J[3:i//N+1,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.exp(total_spin + np.sum(J[:,i//N,i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.exp(-total_spin - np.sum(J[:,i//N,i//N]))
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time11:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
    else:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.09038688271604947}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    
    # Add a term to favor the same spin as neighboring sites
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][h[site_nbr][i%N] > 0] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.06419830246913585}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[[0,1],i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - np.sum(J[[0,1],i//N,i//N])
      priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0033665123456790126}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (4 + np.sum(np.abs(h.flatten())))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    up_spin = 0
    down_spin = 0
    left_spin = 0
    right_spin = 0
    
    # Calculate the spin contributions from each neighbor
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if k == 0: 
          up_spin += 1
        elif k == 1: 
          right_spin += 1
        elif k == 2: 
          down_spin += 1
        else: 
          left_spin += 1
      else:
        if k == 0: 
          up_spin -= 1
        elif k == 1: 
          right_spin -= 1
        elif k == 2: 
          down_spin -= 1
        else: 
          left_spin -= 1
    
    # Calculate the total spin and assign priorities based on it
    if h[i//N][i%N] > 0:
      priorities[i] = [up_spin + right_spin + down_spin + left_spin, -(up_spin + right_spin + down_spin + left_spin)]
    else:
      priorities[i] = [-up_spin - right_spin - down_spin - left_spin, up_spin + right_spin + down_spin + left_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.33873533950617185}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    num_neighbors = np.count_nonzero(J[:,i%N,i//N])
    if num_neighbors > 0:
      total_spin /= (2 * num_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time11:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Iterate over each site in the grid
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Set priorities based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.12571805555555574}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1613186728395064}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.12582453703703717}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] > 0:
          total_spin_up += 1
        else:
          total_spin_down -= 1
      else:
        if h[site_nbr][i%N] > 0:
          total_spin_down -= 1
        else:
          total_spin_up += 1
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up + 1, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down + 1]
  
  return(priorities)




#score: {'data2D.txt': -0.06056157407407407}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
    for j in range(4):
      site_nbr2 = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] += total_spin / 4
    priorities[i][1] -= total_spin / 4
  
  return(priorities)




#score: {'data2D.txt': 0.2242226851851853}
#island_id: 2
#version_generated: 2
#generate time11:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.19855169753086427}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    for k in [2,3]:
      j = (i//N + ((k-2)%2 - 1)) % N
      if J[k,i%N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19957824074074076}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    if i//N > 0:
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i//N - 1) * N + ((i%N+1)%N)
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below, taking into account edge cases
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.20052824074074077}
#island_id: 0
#version_generated: 2
#generate time11:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    for k in range(2):
      j = (i//N + ((k-1)%2 - 1)) % N
      if i//N > 0:
        if J[k,i%N,i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33865015432098666}
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
     j = i//N - 1
     above, below = J[3, i%N, :2]
     total_spin += above.sum()
     total_spin /= (4 + int(i//N > 0))
    
    # Calculate the priority based on the magnetism and interaction
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin - len([k for k in range(4) if J[k, i%N, l] < 0]), total_spin + len([k for k in range(4) if J[k, i%N, l] > 0])]
    else:
     priorities[i] = [-total_spin + len([k for k in range(4) if J[k, i%N, l] > 0]), -total_spin - len([k for k in range(4) if J[k, i%N, l] < 0])]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin_up += 1
        total_spin_down -= 1
      else:
        total_spin_up -= 1
        total_spin_down += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down]
  
  return(priorities)




#score: {'data2D.txt': -0.13874243827160512}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interaction = 0
    magnetism = h[i//N][i%N]
    
    if J[0,i%N,i//N] > 0:
      interaction += 1
    else:
      interaction -= 1
    
    if i % N < N-1 and J[1,i%N,i//N] > 0:
      interaction += 1
    elif i % N < N-1 and J[1,i%N,i//N] <= 0:
      interaction -= 1
    
    if i // N < N-1 and J[2,i//N,i%N] > 0:
      interaction += 1
    elif i // N < N-1 and J[2,i//N,i%N] <= 0:
      interaction -= 1
    
    if (i+1) % N < N and (i+N) % N < N*N and J[3,(i+1)%N,i//N] > 0:
      interaction += 1
    elif (i+1) % N < N and (i+N) % N < N*N and J[3,(i+1)%N,i//N] <= 0:
      interaction -= 1
    
    if magnetism > 0:
      priorities[i][0] = -interaction
      priorities[i][1] = interaction
    else:
      priorities[i][0] = interaction
      priorities[i][1] = -interaction
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Check the magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin+1]
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the magnetism term and sum the interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
    
    priorities[i][0] = total_spin + h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.001706327160493827}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] += 1
    
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.08174182098765438}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute the interaction with the left and right neighbors
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if i % N != 0: 
      site_nbr = (i-1)%N
      if J[0,i%N,site_nbr//N] > 0:
        total_spin += h[site_nbr][site_nbr%N]
      else:
        total_spin -= h[site_nbr][site_nbr%N]

    # Compute the interaction with the top and bottom neighbors
    if i // N != 0: 
      site_nbr = (i - N) % (N*N)
      if J[1,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    # Compute the interaction with the top-left and bottom-right neighbors
    if i % N != 0 and i // N != 0: 
      site_nbr = (i - N - 1) % (N*N)
      if J[2,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    # Compute the interaction with the top-right and bottom-left neighbors
    if i % N != N - 1 and i // N != 0: 
      site_nbr = (i - N + 1) % (N*N)
      if J[3,i//N,site_nbr//N] > 0:
        total_spin += h[site_nbr//N][site_nbr%N]
      else:
        total_spin -= h[site_nbr//N][site_nbr%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = ((i + (N-1)) % N)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.07918101851851858}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + J[0, i//N, i%N]]
  
  return priorities




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.12847638888888907}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_up = 1
    else:
      priority_up = -1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        priority_nbr = 1
      else:
        priority_nbr = -1

      priorities[i][0] += h[site_nbr][i%N] + priority_up * J[3, i%N, (i+1)%N] + J[k, i%N, l] * priority_nbr
      if h[i//N][i%N] > 0:
        priorities[i][1] -= 1 - 2 * priority_up * priority_nbr
      else:
        priorities[i][1] += 1 - 2 * priority_up * priority_nbr

  return(priorities)




#score: {'data2D.txt': 0.22053749999999994}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N - 1
    l = i%N
    if i//N > 0 and J[2, i%N, i%N] > 0:
      total_spin += 1
    elif i//N > 0:
      total_spin -= 1
    
    j = i//N - 1
    l = (i%N + 1) % N
    if i//N > 0 and i % N < N-1 and J[3, i%N, l] > 0:
      total_spin += 1
    elif i//N > 0 and i % N < N-1:
      total_spin -= 1
    
    j = i//N - 1
    l = (i%N - 1) % N
    if i//N > 0 and i % N < N-1 and J[2, i%N, l] > 0:
      total_spin += 1
    elif i//N > 0 and i % N < N-1:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 6.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.05670416666666667}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum(J[:,i//N,i%N]) + 1, -np.sum(J[:,i//N,i%N]) - 1]
    else:
      priorities[i] = [-np.sum(J[:,i//N,i%N]), np.sum(J[:,i//N,i%N])]
  
  return(priorities)




#score: {'data2D.txt': 0.06911898148148155}
#island_id: 0
#version_generated: 2
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    up_spin = 0
    down_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          up_spin += 1
        else:
          up_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          up_spin += 1
        else:
          up_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          down_spin += 1
        else:
          down_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + up_spin - down_spin, -total_spin - up_spin + down_spin]
    else:
      priorities[i] = [-total_spin - up_spin + down_spin, total_spin + up_spin - down_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(1 if J[k,i%N,i//N] > 0 else -1 for k in range(4))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.004379166666666667}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i%N,i//N] * (h[i//N][i%N] > 0) - J[1,i%N,i//N] * (h[i//N][i%N] < 0)
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term to priority
    priorities[i][int(h[i//N][i%N]>0)] += np.abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 1.0030864197531186e-05}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin = 1
    elif J[0,i%N,i//N] < 0:
      total_spin = -1
    else:
      total_spin = np.tanh(J[1,i%N,i//N]*h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.045272376543209904}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
    
    # Add a bias term based on the current magnetization
    if np.sum(priorities[:i]) > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    elif np.sum(priorities[:i]) < 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.07995231481481486}
#island_id: 2
#version_generated: 2
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 4
    priorities[i][0] = total_spin * sum([J[k,i%N,i//N] for k in range(4)]) / (1.0 * sum(h[i//N]))
    if h[i//N][i%N] > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.34273410493827056}
#island_id: 0
#version_generated: 2
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
    # Add a bonus for aligning with the spins of neighboring sites
    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[float('-inf'), float('inf')] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.34273873456790016}
#island_id: 0
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the average spin of neighbors
    avg_spin = np.mean(neighbors_spin)
    if avg_spin > 0:
      priorities[i][1] += avg_spin
    else:
      priorities[i][0] -= avg_spin
  
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3-i%N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16467577160493851}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i-1)%N if i % N != 0 else N-1, (i+1)%N if i % N != N-1 else 0]
    
    for j in site_nbrs:
      if J[3,i%N,j] > 0:
        total_spin += h[j][i%N]
        priorities[i][0] += h[j][i%N]
        priorities[i][1] -= h[j][i%N]
      else:
        total_spin -= h[j][i%N]
        priorities[i][0] -= h[j][i%N]
        priorities[i][1] += h[j][i%N]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0006436728395061725}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': -0.004466203703703703}
#island_id: 1
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate the magnetism
    mag = np.sign(total_spin)
    
    # Calculate the priority based on the site interactions and magnetism
    priorities[i] = [total_spin - mag, -total_spin + mag]
  
  return(priorities)




#score: {'data2D.txt': 0.007536574074074074}
#island_id: 1
#version_generated: 2
#generate time11:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbr_sum += h[(i + ((k-1)%2 - 1)) % N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr_sum += h[(i + ((j-1)%2 - 1)) % N][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    site_nbr_sum /= 4.0
    for k in range(2):
      if J[k,i%N,i//N] > 0:
        priorities[i][k] += site_nbr_sum
      else:
        priorities[i][k] -= site_nbr_sum
  
  return(priorities)




#score: {'data2D.txt': -0.0012908950617283954}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias / (2 * np.abs(spin_bias)), -(spin_bias / (2 * np.abs(spin_bias)))]
    else:
      spin_bias = -np.sum(neighbors_spin) - J[2, i//N, i//N]
      priorities[i] = [-(spin_bias / (2 * np.abs(spin_bias))), spin_bias / (2 * np.abs(spin_bias))]
  
  return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': 0.3427442901234557}
#island_id: 0
#version_generated: 2
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias = np.sum(neighbors_spin) + J[3, i//N, i//N]
      priorities[i] = [spin_bias, -spin_bias]
      for j in range(2):
        if h[i//N][i%N] > 0 and j == 1 or h[i//N][i%N] < 0 and j == 0:
          spin_bias += np.sum(neighbors_spin)
          priorities[i] = [spin_bias, -spin_bias]
    else:
      spin_bias = np.sum(neighbors_spin) + J[2, i//N, i//N]
      priorities[i] = [-spin_bias, spin_bias]
    
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1655828703703706}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    site_nbr = (i // N + ((i%N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.14108225308641995}
#island_id: 1
#version_generated: 2
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(h[:(i//N)+1,(i)%N])
      priorities[i][1] = -total_spin + np.sum(h[:(i//N)+1,(i)%N])
    else:
      priorities[i][0] = -total_spin + np.sum(h[:(i//N)+1,(i)%N])
      priorities[i][1] = total_spin - np.sum(h[:(i//N)+1,(i)%N])
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1.5, -(total_spin + 1.5)]
    else:
      priorities[i] = [-(total_spin - 1.5), total_spin + 1.5]
  
  return priorities




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': -0.338945524691357}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += J[j, i//N, i%N]
      else:
        total_spin -= J[j, i//N, i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.338945524691357}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += J[j, i//N, i%N]
      else:
        total_spin -= J[j, i//N, i%N]
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_neighbors = np.count_nonzero(J[:,i%N,i//N])
    total_spin /= (2 * total_neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.30459336419753014}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_neighbors = np.count_nonzero(J[:,i%N,i//N])
    if total_neighbors == 0:
      total_spin /= (2 * np.count_nonzero(J[0,:,i//N]))
    else:
      total_spin /= total_neighbors
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04645447530864198}
#island_id: 3
#version_generated: 2
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - sum([J[k,i%N,i//N] for k in [0, 1]]), 
               -total_spin + sum([J[k,i%N,i//N] for k in [0, 1]])]
    else:
      priorities[i] = [-total_spin + sum([J[k,i%N,i//N] for k in [0, 1]]), 
               total_spin - sum([J[k,i%N,i//N] for k in [0, 1]])]
  
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.20476959876543233}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]

  # Additional improvement: If the site has more positive interactions, prioritize 1
  for i in range(N**2):
    pos_interactions = np.sum([J[k,i%N,i//N] > 0 for k in range(4)])
    if pos_interactions > 1:
      priorities[i][0] += (pos_interactions - 1) / 4.0
      priorities[i][1] -= (pos_interactions - 1) / 4.0

  return(priorities)




#score: {'data2D.txt': 0.0729418209876544}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  # Normalize by the number of neighbors in the row
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N]
      priorities[i][1] += J[1,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.2242226851851853}
#island_id: 2
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbrs = []
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = ((i // N + ((k-1)%2 - 1)) % N) * N + (i % N)
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append(site_nbr)
    
    # Normalize by the number of neighbors and magnetism
    neighbor_count = len(set([j % N for j in site_nbrs]))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin / (2 * neighbor_count + abs(total_spin)), -total_spin / (2 * neighbor_count + abs(total_spin))]
    else:
      priorities[i] = [-total_spin / (2 * neighbor_count + abs(total_spin)), total_spin / (2 * neighbor_count + abs(total_spin))]
  
  return priorities




#score: {'data2D.txt': -0.01437175925925926}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = h[i//N][i%N]
    for k in range(4):
      site_nbr = (i // N + ((k-1)%2 - 1)) % N * N + (i % N)
      site_nbrs.append((site_nbr, J[k, i//N, i%N]))
    
    site_nbrs.sort(key=lambda x: abs(x[1]))
    for _,spin in site_nbrs:
      total_spin += spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.014080092592592592}
#island_id: 3
#version_generated: 2
#generate time11:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    site_nbrs = [(i // N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_interactions = [J[k, i//N, i%N] for k in range(4)]
    total_spin += sum(site_interactions)
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * len([k for k in site_interactions if k != 0]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time11:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time11:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.3427199074074064}
#island_id: 0
#version_generated: 2
#generate time12:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Calculate the priority based on the majority of neighbors
    neighbor_spin = np.where(neighbors_spin > 0, 1, -1).sum()
    if neighbor_spin > 0:
      priorities[i][1] += 3
    elif neighbor_spin < 0:
      priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': 0.17484830246913605}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i // N + (k % 2) - 1) % N * N + (i % N) for k in range(4)]
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for j, site_nbr in enumerate(site_nbrs):
      if J[j, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 * np.count_nonzero(J[:, i//N, i%N]) + abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 1e-3, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1e-3]
  
  return priorities




#score: {'data2D.txt': 0.0537054012345679}
#island_id: 3
#version_generated: 2
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  # Add an additional term to prioritize spins that align with the majority of their neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_spin = np.sum(J[:,i%N,i//N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.16135570987654346}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i%N]), -total_spin + np.sum(J[:,i//N,i%N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i%N]), total_spin + np.sum(J[:,i//N,i%N])]
  
  return(priorities)




#score: {'data2D.txt': 0.09926157407407418}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin at each site based on magnetism and interaction
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[:, i//N, i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[:, i//N, i%N])]
  
  return(priorities)




#score: {'data2D.txt': -0.0031671296296296295}
#island_id: 0
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = J[0,site_nbr,i//N] - J[1,site_nbr,i//N]
    else:
      total_spin = J[2,site_nbr,i//N] - J[3,site_nbr,i//N]
    
    priorities[i][0] = total_spin + 2*h[i%N][i//N]
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.000942438271604938}
#island_id: 2
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(J[:,i//N,i//N])
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': -0.011984722222222221}
#island_id: 2
#version_generated: 2
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2.5
    
    # Apply a threshold to determine the priority
    threshold = 0.5
    if abs(total_spin) >= threshold:
      priorities[i][0] = -1 if total_spin > 0 else 1
    else:
      neighbor_total_spin = 0
      for k in range(4):
        site_nbr = (i % N + ((k-1)%2 - 1)) % N
        neighbor_total_spin += J[k,i%N,i//N]*h[site_nbr][i%N]
      
      if neighbor_total_spin > threshold:
        priorities[i] = [-1, 1]
      else:
        priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.11368595679012358}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site][i%N]
        priorities[i][1] -= h[site][i%N]
      else:
        priorities[i][0] -= h[site][i%N]
        priorities[i][1] += h[site][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.03866651234567904}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  return(priorities)




#score: {'data2D.txt': -0.006605709876543209}
#island_id: 1
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      spin_bias = 1
    else:
      spin_bias = -1
      
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += spin_bias * (J[k,i%N,i//N] - h[site_nbr][i%N])
        priorities[i][1] -= spin_bias * (J[k,i%N,i//N] - h[site_nbr][i%N])
      else:
        priorities[i][0] -= spin_bias * (J[k,i%N,i//N] + h[site_nbr][i%N])
        priorities[i][1] += spin_bias * (J[k,i%N,i//N] + h[site_nbr][i%N])
    
  return(priorities)




#score: {'data2D.txt': 0.21453348765432118}
#island_id: 2
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(np.array([J[k,i//N,i//N]/4 for k in range(4)]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(np.array([J[k,i//N,i//N]/4 for k in range(4)]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.18130015432098787}
#island_id: 2
#version_generated: 2
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
    
  return(priorities)




#score: {'data2D.txt': -0.002830401234567901}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin - 2 * np.sum(neighbors_spin)
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin + 2 * np.sum(neighbors_spin)

  return (priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
    
    # Sort the neighbors based on their spins
    sorted_neighbors = np.argsort(neighbors_spin)
    sorted_neighbors_spin = neighbors_spin[sorted_neighbors]
    
    # Update the priority based on the neighbor's spin
    if sorted_neighbors_spin[0] > 0:
      priorities[i][1] -= 2 * len(sorted_neighbors_spin)
    else:
      priorities[i][0] += 2 * len(sorted_neighbors_spin)

  return (priorities)




#score: {'data2D.txt': -0.002361882716049383}
#island_id: 0
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities=np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=(i%N+((i//N-1)%2-1))%N
    neighbors_spin=J[:,i//N,i%N].flatten()
    total_spin=h[site_nbr][i%N]+np.sum(neighbors_spin)
    
    if h[i//N][i%N]>0:
      priorities[i]=[total_spin+np.sum(neighbors_spin),-total_spin+np.sum(neighbors_spin)]
    else:
      priorities[i]=[-total_spin+np.sum(neighbors_spin),total_spin+np.sum(neighbors_spin)]

  return priorities




#score: {'data2D.txt': -0.0015020061728395061}
#island_id: 2
#version_generated: 2
#generate time12:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[k,i//N,i//N] * (1 if h[site_nbr][i%N] > 0 else -1) for k in range(4))
    priorities[i][0] = total_spin + sum(J[:,i//N,i//N]) / len(J)
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    magnetism = h[i//N][i%N]
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if magnetism > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (magnetism) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (magnetism) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.2205279320987656}
#island_id: 2
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its interaction with neighboring sites
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + sum(J[:,i//N,i//N]) / len(J)) + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + sum(J[:,i//N,i//N]) / len(J)) - (h[i//N][i%N]) / (1.0 * sum(h[i//N]))
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.020227006172839505}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin) - total_spin, -(abs(neighbor_spin) - total_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin) + total_spin, (abs(neighbor_spin) - total_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.0537054012345679}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
  
  return(priorities)




#score: {'data2D.txt': -0.020227006172839505}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i%N,i//N])
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(neighbor_spin), -abs(neighbor_spin)]
    else:
      priorities[i] += [-abs(neighbor_spin), abs(neighbor_spin)]
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] += [abs(total_spin), -abs(total_spin)]
    else:
      priorities[i] += [-abs(total_spin), abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': -0.03358132716049383}
#island_id: 3
#version_generated: 2
#generate time12:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2 * np.count_nonzero(J[:,i%N,i//N]))
    
    # Add a bias term to favor spins in the same direction as the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] = total_spin + abs(total_spin)
      priorities[i][0] = -total_spin
    else:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + abs(total_spin)
    
    # Add an additional term to prioritize spins that align with the majority of their neighbors
    neighbor_spin = np.sum(J[:,i//N,i%N])
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += abs(neighbor_spin)
      priorities[i][0] -= abs(neighbor_spin)
    else:
      priorities[i][1] -= abs(neighbor_spin)
      priorities[i][0] += abs(neighbor_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.1019236111111112}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      j,l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.020300771604938275}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    # Adjust priority based on site interactions and magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time12:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    # Apply a non-linear transformation to improve prioritization
    transformed_spin = (np.tanh(2*total_spin) - np.tanh(-2*total_spin)) / (np.tanh(2) - np.tanh(-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [transformed_spin, -transformed_spin]
    else:
      priorities[i] = [-transformed_spin, transformed_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
    
    # Check for neighboring sites with the same spin and adjust the priority accordingly
    site_nbrs_with_same_spin = [(j, neighbor[1]) for j, neighbor in enumerate(site_nbrs) if flip==neighbor[1]]
    for j, spin in site_nbrs_with_same_spin:
      priorities[i][0] += J[3,i%N,j//N]
    
  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))

    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2

  return(priorities)




#score: {'data2D.txt': -0.012875771604938272}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k, i%N, i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))

    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
      # Add a penalty term proportional to the number of neighbors with the same spin
      priorities[i][0] -= sum(1 for neighbor in site_nbrs if neighbor[1]==flip)
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2

  return(priorities)




#score: {'data2D.txt': -0.03503132716049383}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = []
    
    # Find all nearest neighbors and calculate their interactions
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        site_nbrs.append((site_nbr, 1))
      else:
        site_nbrs.append((site_nbr, -1))
    
    # Calculate the priority for each possible spin assignment
    for flip in [True, False]:
      total_spin = sum(neighbor[1] for neighbor in site_nbrs if not flip or i==neighbor[0])
      
      # Adjust according to the magnetism at this site and the interaction with neighbors
      priorities[i][0] += h[i//N][i%N]*flip + sum(h[j%N][j//N]*(neighbor[1] if neighbor[1]==flip else -neighbor[1]) for j, neighbor in enumerate(site_nbrs) if i!=j)
      
      # Adjust the priority based on the total spin
      priorities[i][0] -= abs(total_spin) * 10
      
    # Normalize by the number of possible spins
    priorities[i][0] /= 2
  
  return(priorities)




#score: {'data2D.txt': 0.16086558641975332}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + h[i//N][i%N]) / (1.0 * sum(h[i//N])) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.18130015432098787}
#island_id: 2
#version_generated: 2
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        site_nbr_sum -= h[site_nbr][i%N]
      else:
        total_spin -= 1
        site_nbr_sum += h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + site_nbr_sum
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0011816358024691355}
#island_id: 2
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbrs = []
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append((site_nbr, k))
    for i in range(4):
      for j in range(i+1, 4):
        if site_nbrs[i][0] == site_nbrs[j][0]:
          total_spin += J[site_nbrs[i][1],i//N,i//N] - J[site_nbrs[j][1],i//N,i//N]
    # Normalize by the number of neighbors
    total_spin /= 4.0
    
    # Adjust according to the magnetism at this site and its nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + (h[i//N][i%N]) / (1.0 * sum(h[i//N]))) + np.sum(J[:,i//N,i//N])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.16100601851851876}
#island_id: 2
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N]) * h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1.0 / (1.0 * sum(h[site_nbr])) - np.sum(J[:,i//N,i//N])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin) - np.sum(J[:,i//N,i//N]) + 1.0 / (1.0 * sum(h[site_nbr]))
      priorities[i][1] = priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_spin = -total_spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, priority_spin]
    else:
      priorities[i] = [priority_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09142947530864205}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] = total_spin + h[site_nbr][i%N]
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
    # Prioritize -1 spin when the total spin is negative
    if priorities[i][0] < 0:
      priorities[i][::-1]
    
  return(priorities)




#score: {'data2D.txt': -0.08272731481481486}
#island_id: 3
#version_generated: 2
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the magnetism term
    priorities[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
    
    # Add the priority based on the number of neighbors with positive interaction
    total_spin_neighbors = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0 and i % N != (k-1)%N and i // N != ((k-1)//2) - 1:
        total_spin_neighbors += 1
      elif J[k,i%N,i//N] < 0 and i % N != (k-1)%N and i // N != ((k-1)//2) - 1:
        total_spin_neighbors -= 1
    
    priorities[i][0] += total_spin_neighbors
    priorities[i][1] -= total_spin_neighbors
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1123300925925927}
#island_id: 1
#version_generated: 2
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if i < N:
      site_nbr = (i % N + ((N-1)%2 - 1)) % N
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,i%N,N-1] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    
    if i >= N*(N-1):
      site_nbr = (i % N + ((0)%2 - 1)) % N
      total_spin = h[site_nbr][i%N]
      
      for k in range(4):
        if J[k,0,i//N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = np.array([total_spin, -total_spin])
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.08024675925925936}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is strong, prioritize opposite spin
    if h[i//N][i%N] > 0.5 or (h[i//N][i%N] < -0.5 and np.random.rand() < 0.1):
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_spin_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_spin_sum += 1
      else:
        neighbor_spin_sum -= 1
    total_spin = h[site_nbr][i%N] + neighbor_spin_sum
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.15409120370370386}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (site_nbr1 + 1) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += J[0,i//N,i%N]
      priorities[i][1] -= J[0,i//N,i%N]
    
    if h[site_nbr2][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]
      priorities[i][1] -= J[3,i//N,i%N]
    
    if i % N != 0:
      site_nbr = (i-1) % N
      if h[site_nbr1][i//N] > 0:
        priorities[i][0] += J[1,i//N,i%N]
        priorities[i][1] -= J[1,i//N,i%N]
    
    if i < N**2 - N:
      site_nbr = (i+N) % N
      if h[site_nbr1][i//N] > 0:
        priorities[i][0] += J[2,i//N,i%N]
        priorities[i][1] -= J[2,i//N,i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': 0.009644598765432093}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 3
#version_generated: 2
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  # Add magnetism to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.10863317901234576}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate the priority for each spin value
    if total_spin > 0:
      priorities[i][1] += np.sum(np.sign(J[:,i//N,i%N]))
      priorities[i][0] -= np.sum(np.sign(J[:,i//N,i%N]))
    else:
      priorities[i][0] += np.sum(np.sign(J[:,i//N,i%N]))
      priorities[i][1] -= np.sum(np.sign(J[:,i//N,i%N]))
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      if J[k,i%N,(i//N)%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0006791666666666671}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0: total_spin += 1
        elif k == 1: total_spin -= 1
        elif k == 2: total_spin += 1
        else: total_spin -= 1
      else:
        if k == 0: total_spin -= 1
        elif k == 1: total_spin += 1
        elif k == 2: total_spin -= 1
        else: total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.008968364197530866}
#island_id: 3
#version_generated: 2
#generate time12:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism contribution
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 1
      priorities[i][1] = -total_spin - 1
    else:
      priorities[i][0] = -total_spin - 1
      priorities[i][1] = total_spin + 1
    
  return(priorities)




#score: {'data2D.txt': -0.00310354938271605}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
      
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 1
#version_generated: 2
#generate time12:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.01884367283950617}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 2 * (h[site_nbr][k] > 0) - 1
      else:
        total_spin -= 2 * (h[site_nbr][k] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.041253549382716054}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      spin_magnetism = -1
    else:
      spin_magnetism = 1
    neighbors_spin = np.sum(J[:,i%N,i//N], axis=0)
    if neighbors_spin > 0:
      priority_1 = total_spin + spin_magnetism
      priority_2 = -total_spin - spin_magnetism
    else:
      priority_1 = total_spin - spin_magnetism
      priority_2 = -total_spin + spin_magnetism
    priorities[i] = [priority_1, priority_2]
  return(priorities)




#score: {'data2D.txt': -0.00903780864197531}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_magnetism = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        if k==0 or k==1: # top and left neighbors
          spin_magnetism -= 1
        elif k==2: # right neighbor
          spin_magnetism += 1
      else:
        total_spin -= 1
        if k==0 or k==1: # top and left neighbors
          spin_magnetism += 1
        elif k==2: # right neighbor
          spin_magnetism -= 1
    priorities[i] = [total_spin+spin_magnetism*h[site_nbr][i%N], -total_spin-spin_magnetism*h[site_nbr][i%N]]
  return(priorities)




#score: {'data2D.txt': -0.10742793209876544}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      site_nbr_nn = ((k+3)%2)*((i%N+((i//N-1)%2 - 1)) % N)
      total_spin += 2 * (J[k,i//N,i%N] > 0) * (h[site_nbr_nn][k] > 0) - 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.004043364197530864}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 2 * (h[site_nbr][k] > 0) - 1
      else:
        total_spin -= 2 * (h[site_nbr][k] > 0) + 1
    for k in range(4):
      if J[k,i%N,(i-1)%N] > 0:
        total_spin += 2 * (h[i//N][k] > 0) - 1
      else:
        total_spin -= 2 * (h[i//N][k] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.06028935185185188}
#island_id: 3
#version_generated: 2
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      site_nbr_neighbors = [(site_nbr + ((k-1)%2 - 1)) % N, (site_nbr + ((k-3)%2 - 1)) % N]
      for neighbor in site_nbr_neighbors:
        if J[0,i%N,neighbor] > 0:
          total_spin += 2 * (h[neighbor][i%N] > 0) - 1
        else:
          total_spin -= 2 * (h[neighbor][i%N] > 0) + 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.012977314814814817}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i%N,i//N]) * (h[site_nbr][i//N] > 0) - 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.19795262345679016}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if j < N - 1 or ((i % N == 0 or i % N == N - 1)):
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1990402777777778}
#island_id: 0
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N
    if j > 0:
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if j < N - 1 and ((i % N == 0 or i % N == N - 1)):
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.013054475308641976}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    total_magnetism = h[i%N][i//N]
    
    if h[i%N][i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      total_magnetism += h[site_nbr][i%N]
    
    priorities[i][0] = total_spin + total_magnetism
    priorities[i][1] = -total_spin + total_magnetism
    
  return(priorities)




#score: {'data2D.txt': 0.16013225308642}
#island_id: 1
#version_generated: 2
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.15036558641975334}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i-1)%N - 1)) % N
    site_nbr_right = (i % N + ((i+1)%N - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr_left][i%N]
      total_spin -= h[site_nbr_right][i%N]
    else:
      total_spin -= h[site_nbr_left][i%N]
      total_spin += h[site_nbr_right][i%N]
    
    if J[1,i//N,i//N] > 0:
      total_spin += h[i%N, site_nbr_left]
      total_spin -= h[i%N, site_nbr_right]
    else:
      total_spin -= h[i%N, site_nbr_left]
      total_spin += h[i%N, site_nbr_right]
    
    if J[2,i//N,(i-1)%N] > 0:
      total_spin += h[i//N, (i-1)%N]
      total_spin -= h[i//N, i%N]
    else:
      total_spin -= h[i//N, (i-1)%N]
      total_spin += h[i//N, i%N]
    
    if J[3,i//N,(i+1)%N] > 0:
      total_spin += h[i//N, (i+1)%N]
      total_spin -= h[i//N, i%N]
    else:
      total_spin -= h[i//N, (i+1)%N]
      total_spin += h[i//N, i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.18069490740740768}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  # Add interactions with next-nearest neighbors (if N is even)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if N%2 == 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001260956790123457}
#island_id: 1
#version_generated: 2
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = sum(J[k,i//N,i%N]*h[(i+k)%N][j] for j,k in [(j,(3+j)//2) for j in range(4)])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 0
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    interaction_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        interaction_sum -= 1
      else:
        total_spin -= 1
        interaction_sum += 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + interaction_sum, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + interaction_sum]
    
    return(priorities)




#score: {'data2D.txt': 0.1019365740740742}
#island_id: 0
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(np.abs(J[:,i//N,i//N]))
      priorities[i][1] -= np.prod(np.abs(J[:,i//N,i//N]))
    else:
      priorities[i][0] -= np.prod(np.abs(J[:,i//N,i//N]))
      priorities[i][1] += np.prod(np.abs(J[:,i//N,i//N]))
  return(priorities)




#score: {'data2D.txt': 0.18292021604938294}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N]) + J[3,i//N,i//N]) / 4
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N]) + J[3,i//N,i//N]) / 4)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': -0.296551080246913}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -(priorities[i][0])
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  # Add a bonus term to favor the same spin as the site's magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16435540123456818}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][i%N] - h[i//N][i%N])]
  return(priorities)




#score: {'data2D.txt': 0.08103688271604943}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetism = (site_nbr + ((site_nbr-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interaction with next nearest neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_interaction = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_interaction += 1
      else:
        total_interaction -= 1
    site_nbr_interaction = (site_nbr + ((site_nbr-1)%2 - 1)) % N
    if J[0,site_nbr,i//N] > 0:
      priorities[i][0] += total_interaction
      priorities[i][1] -= total_interaction
    else:
      priorities[i][0] -= total_interaction
      priorities[i][1] += total_interaction

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0 and i % N == site_nbr or k == 1 and i // N == site_nbr: 
          if h[i//N][i%N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
        elif k == 2 and (i+1)%N == site_nbr or k == 3 and i//N == (site_nbr-1)%N: 
          if h[i//N][i%N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
        else: 
          if J[k,i%N,i//N] > 0:
            total_spin_up += 1
          else:
            total_spin_down += 1
      else:
        if k == 0 and i % N == site_nbr or k == 1 and i // N == site_nbr: 
          if h[i//N][i%N] > 0:
            total_spin_down += 1
          else:
            total_spin_up += 1
        elif k == 2 and (i+1)%N == site_nbr or k == 3 and i//N == (site_nbr-1)%N: 
          if h[i//N][i%N] > 0:
            total_spin_down += 1
          else:
            total_spin_up += 1
        else: 
          if J[k,i%N,i//N] < 0:
            total_spin_up += 1
          else:
            total_spin_down += 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up, -total_spin_down]
    else:
      priorities[i] = [-total_spin_up, total_spin_down]

  return(priorities)




#score: {'data2D.txt': -0.21704120370370372}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.01048348765432099}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
  return(priorities)




#score: {'data2D.txt': -0.005611265432098765}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if total_spin > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if total_spin > 0:
      priorities[i] = [np.sum(J[:,i//N,i//N]) + N - 1, -N]
    elif total_spin < 0:
      priorities[i] = [-np.sum(J[:,i//N,i//N]), np.sum(J[:,i//N,i//N]) + N - 1]
    else:
      priorities[i] = [N-1, -N]
  return(priorities)




#score: {'data2D.txt': 0.024733179012345678}
#island_id: 1
#version_generated: 2
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if sum(J[3,i%N,j] > 0 for j in range(N)) > 0:
      priorities[i][0] += sum(h[s][i%N] for s in site_nbrs)
      priorities[i][1] -= sum(h[s][i%N] for s in site_nbrs)
    else:
      priorities[i][0] -= sum(h[s][i%N] for s in site_nbrs)
      priorities[i][1] += sum(h[s][i%N] for s in site_nbrs)
    
  return(priorities)




#score: {'data2D.txt': 0.002804783950617285}
#island_id: 1
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N) % N

    total_spin = h[site_nbr_row][i%N] + sum(J[k, i%N, site_nbr_row] for k in range(4)) + sum(J[3, j, i//N] for j in range(N))

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return priorities




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.02373719135802469}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_count = [0,0]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        spin_count[0] += 1
      else:
        total_spin -= 1
        spin_count[1] += 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -spin_count[1]]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.16031342592592618}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': -0.0015850308641975313}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[i//N,k]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][2] - h[i//N][1]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][2] - h[i//N][1])]
  return(priorities)




#score: {'data2D.txt': -0.0032084876543209875}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i//N])
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum((J[k,i//N,i//N]-h[site_nbr][i%N]) for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum((J[k,i//N,i//N]-h[site_nbr][i%N]) for k in range(4))]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = 0
    total_spin_down = 0
    for k in [0,1]: # Up and right neighbors
      if J[k,i%N,i//N] > 0:
        total_spin_up += 1
      else:
        total_spin_up -= 1
    for k in [2,3]: # Down and left neighbors
      if J[k,i%N,i//N] > 0:
        total_spin_down += 1
      else:
        total_spin_down -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_up + total_spin_down, -total_spin_up - total_spin_down]
    else:
      priorities[i] = [-total_spin_up - total_spin_down, total_spin_up + total_spin_down]
  return(priorities)




#score: {'data2D.txt': 0.16317052469135826}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N)
    
    total_spin = h[site_nbr1][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  for i in range(N):
   site_nbr = (i % N + ((N-1)%2 - 1)) % N
   if J[3,i,N-1] > 0:
    priorities[i*N+i][0] += h[site_nbr][N-1]
    priorities[i*N+i][1] -= h[site_nbr][N-1]
   else:
    priorities[i*N+i][0] -= h[site_nbr][N-1]
    priorities[i*N+i][1] += h[site_nbr][N-1]
  
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the site's magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16480293209876568}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0018933641975308639}
#island_id: 1
#version_generated: 2
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interaction terms
    interaction_terms = np.sum(J[:,i//N,i%N])
    
    if interaction_terms > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.12924490740740754}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin_sum = np.zeros(2)
    
    # Add interaction with the site above
    j = (i // N - 1) % N + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (1) % 2
      if J[l, i % N, 0] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below
    j = (i // N + 1) % N + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (3) % 2
      if J[l, i % N, 0] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site to the left
    j = (i % N - 1) + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (3) % 2
      if J[1, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site to the right
    j = (i % N + 1) + ((i // N - 1) % 2 - 1) * N
    if j >= 0 and j < N:
      l = (1) % 2
      if J[3, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site above-left
    j = (i // N - 1) % N + ((i // N - 2) % 2 - 1) * N
    k = (1) % 2
    if j >= 0 and j < N:
      l = (3) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site above-right
    j = (i // N - 1) % N + ((i // N - 2) % 2 - 1) * N + N
    k = (3) % 2
    if j >= 0 and j < N:
      l = (1) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below-left
    j = (i // N + 1) % N + ((i // N - 2) % 2 - 1) * N
    k = (3) % 2
    if j >= 0 and j < N:
      l = (1) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Add interaction with the site below-right
    j = (i // N + 1) % N + ((i // N - 2) % 2 - 1) * N + N
    k = (1) % 2
    if j >= 0 and j < N:
      l = (3) % 2
      if J[k, i % N, l] > 0:
        total_spin_sum[0] += 1
      else:
        total_spin_sum[0] -= 1
    
    # Normalize by the number of neighbors
    if i // N > 0: total_spin_sum[0] /= (N - 1)
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] /= (N - 1)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_sum[0] + total_spin_sum[1]/2, -total_spin_sum[0] - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin_sum[0] - total_spin_sum[1]/2, total_spin_sum[0] + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.13536959876543223}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the magnetism at this site
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    if i//N > 0:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j < N**2:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    if i % N > 0:
      l = (3)%2
      if J[1,i%N,(i-1)%N+((i//N-1)%2 - 1)] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j < N:
      l = (1)%2
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: priorities[i][0] += total_spin
    if i % N == 0 or i % N == N - 1: priorities[i][1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][1]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': -0.296551080246913}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])

  # Add a term to the priority based on the sign of the magnetism
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.18399089506172855}
#island_id: 2
#version_generated: 2
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3)
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.27273410493827177}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N]) + 
                 J[1,i//N,i%N] + J[2,i//N,(i+1)%N]) / 5
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N]) + 
                  J[1,i//N,i%N] + J[2,i//N,(i+1)%N])) / 5
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': -0.09857361111111113}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      total_spin += J[k,i%N,i//N]
    total_spin += h[site_nbr][i%N]
    
    if np.sum(J[:, i//N, i%N]) > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.26627669753086436}
#island_id: 2
#version_generated: 2
#generate time12:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': -4.589488082613272e+277}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014251543209876543}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       priorities[i][0] -= h[site_nbr][i%N]
       priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.00543719135802469}
#island_id: 1
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_spin = (total_spin >= 0).astype(int)
    
    priorities[i][0] = -site_spin
    priorities[i][1] = site_spin
  
  return(priorities)




#score: {'data2D.txt': -0.11641558641975308}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on site interactions (J)
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.2582631172839508}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Add priority based on total spin
  for i in range(N**2):
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.215968364197531}
#island_id: 2
#version_generated: 2
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on interaction strength
    if np.sum(J[:,i//N,i%N]) > 0:
      priorities[i][0] += np.sum(J[:,i//N,i%N]) / 4
      priorities[i][1] -= np.sum(J[:,i//N,i%N]) / 4
    else:
      priorities[i][0] -= np.sum(J[:,i//N,i%N]) / 4
      priorities[i][1] += np.sum(J[:,i//N,i%N]) / 4
  
  return(priorities)




#score: {'data2D.txt': -0.036693672839506176}
#island_id: 2
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
    
    # Add priority based on magnetism of neighboring sites
    for j in range(N):
      if h[(i//N)%N][j] > 0:
        priorities[i][0] += 0.5
        priorities[i][1] -= 0.5
      else:
        priorities[i][0] -= 0.5
        priorities[i][1] += 0.5
  
  return(priorities)




#score: {'data2D.txt': 0.16568070987654346}
#island_id: 1
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.05701404320987656}
#island_id: 3
#version_generated: 2
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

    # Add interaction with nearest neighbors to the priority
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.12982762345679028}
#island_id: 3
#version_generated: 2
#generate time12:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in [0,1,2]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnetic = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.2193884259259259}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.21971064814814809}
#island_id: 0
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0014455246913580293}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add priority based on spin correlations
    site_corr = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_corr += 1
      else:
        site_corr -= 1
    priorities[i][0] += site_corr / 2
    priorities[i][1] -= site_corr / 2
    
  return(priorities)




#score: {'data2D.txt': 0.28366064814814834}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.03843564814814815}
#island_id: 2
#version_generated: 2
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Additional priority based on nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k % 2 == 0:
          priorities[i][0] += J[k, i//N, i%N]
        else:
          priorities[i][1] -= J[k, i//N, i%N]
      else:
        if k % 2 == 0:
          priorities[i][0] -= J[k, i//N, i%N]
        else:
          priorities[i][1] += J[k, i//N, i%N]
    
    # Add priority based on total spin
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.2505248456790125}
#island_id: 2
#version_generated: 2
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k, i//N, i%N]
      else:
        total_spin -= J[k, i//N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Add priority based on total spin
  for i in range(N**2):
    if total_spin > 0:
      priorities[i][0] += total_spin / 2
      priorities[i][1] -= total_spin / 2
    else:
      priorities[i][0] -= total_spin / 2
      priorities[i][1] += total_spin / 2
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Calculate the magnetism at this site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate the interaction with nearest neighbors
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority for this site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.2660927469135805}
#island_id: 2
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    site_spins = [h[s] for s in site_nbrs]
    total_spin += np.sum([J[k, i//N, i%N]*s for k, s in zip(range(4), site_spins)])
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2094155864197533}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Compute total magnetism and interactions for each site
  total_spin = np.zeros(N*N)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin[i] += 1
      else:
        total_spin[i] -= 1
    
    # Add magnetism to the priority
    priorities[i][0] = total_spin[i]
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin[i]
    else:
      priorities[i][1] = total_spin[i]

  return(priorities)




#score: {'data2D.txt': 0.16004768518518542}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # Add magnetism to the priority
    site_nbr_magnet = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interactions with neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.16004768518518542}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  # Add magnetism to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  # Add interaction with nearest neighbors to the priority
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    priorities[i] = [total_spin + magnetism, -total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': 0.11822978395061744}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1644643518518521}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        priorities[i][0] += sum(h[site_nbrs[j]][i%N] for j in range(k))
        priorities[i][1] -= sum(h[site_nbrs[j]][i%N] for j in range(k))
      else:
        priorities[i][0] -= sum(h[site_nbrs[j]][i%N] for j in range(k))
        priorities[i][1] += sum(h[site_nbrs[j]][i%N] for j in range(k))
  return(priorities)




#score: {'data2D.txt': -0.0011248456790123455}
#island_id: 1
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': 0.34272206790123344}
#island_id: 0
#version_generated: 2
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
  
  return(priorities)




#score: {'data2D.txt': -0.34248070987654217}
#island_id: 0
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    if h[i//N][i%N] > 0:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [spin_bias_sum - spin_bias_diff, -spin_bias_sum + spin_bias_diff]
    else:
      spin_bias_sum = np.sum(neighbors_spin) + J[3, i//N, i//N]
      spin_bias_diff = abs(np.sum(neighbors_spin)) + J[2, i//N, i//N]
      
      priorities[i] = [-spin_bias_sum + spin_bias_diff, spin_bias_sum + spin_bias_diff]
    
    # calculate the absolute difference of neighboring spins
    diff_neighbors = np.abs(np.diff(neighbors_spin)).sum()
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += diff_neighbors * 2
      priorities[i][1] -= diff_neighbors * 2
    else:
      priorities[i][0] -= diff_neighbors * 2
      priorities[i][1] += diff_neighbors * 2
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    # Calculate total spin considering magnetism and neighbor interactions
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:, i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:, i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.2864871913580249}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.03190509259259259}
#island_id: 2
#version_generated: 2
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += h[(i+((k-1)%2 - 1)) % N][i%N]
      else:
        total_spin -= h[(i+((k-1)%2 - 1)) % N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
    # Add a bonus term based on the number of neighboring spins
    for k in range(4):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k, i//N, i%N]
      else:
        priorities[i][0] -= J[k, i//N, i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.015297993827160494}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i][0] = total_spin + N*h[i//N][i%N]
      priorities[i][1] = -total_spin
    elif h[i//N][i%N] > 0:
      priorities[i][0] = -N*h[i//N][i%N]
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = N*h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': -0.004717129629629629}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[site_nbr][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[site_nbr][i%N]]
  return(priorities)




#score: {'data2D.txt': -0.28802145061728346}
#island_id: 3
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += J[k,i//N,i%N]
      else:
        total_spin -= J[k,i//N,i%N]
    if total_spin > 0:
      priorities[i] = [total_spin + N*h[i//N][i%N], -total_spin - 2*np.sum(J[:,i//N,i%N])]
    else:
      priorities[i] = [-total_spin, total_spin + N*h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17157145061728413}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15335293209876558}
#island_id: 0
#version_generated: 2
#generate time12:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_bias = h[site_nbr][i%N]
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + spin_bias, -total_spin - spin_bias]
    else:
      priorities[i] = [-total_spin - spin_bias, total_spin + spin_bias]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + magnetism, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': -0.07695787037037041}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][i%N] - h[i//N][i%N])]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = np.flip(priorities[i])
  return(priorities)




#score: {'data2D.txt': 0.16435540123456818}
#island_id: 3
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_left = 0
    total_spin_right = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        if k == 0 or (k==1 and i%N!=0) or (k==2 and i//N!=i//N-1) or (k==3 and i%N!=N-1):
          total_spin_left += 1
        else:
          total_spin_right += 1
      else:
        if k == 0 or (k==1 and i%N!=0) or (k==2 and i//N!=i//N-1) or (k==3 and i%N!=N-1):
          total_spin_left -= 1
        else:
          total_spin_right -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin_left + (h[site_nbr][i%N] - h[i//N][i%N]), -total_spin_right]
    else:
      priorities[i] = [-total_spin_left, total_spin_right + (h[site_nbr][i%N] - h[i//N][i%N])]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin from J and magnetism
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the site interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0670405864197531}
#island_id: 1
#version_generated: 2
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for i in range(N**2) for j in range(N)]
  
  for i in range(N**2):
    total_spin = h[site_nbrs[i]][i%N]
    
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.29417854938271626}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  # Check if the spins can be aligned
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = np.sum(h[:,i%N]) / 3
    else:
      total_spin = -(np.sum(h[:,i%N]) / 3)
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.04140354938271607}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  # Compute the priority difference
  for i in range(N**2):
    priorities[i][1] -= priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.29682546296296325}
#island_id: 2
#version_generated: 2
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
    
  return(priorities)




#score: {'data2D.txt': 0.2793763888888891}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N] + np.sum(J[:, i//N, i%N]) * total_spin
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N] - np.sum(J[:, i//N, i%N]) * total_spin
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.28366064814814834}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.28509120370370394}
#island_id: 2
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Prioritize spin assignment based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(h[:,i%N])) / 3 + J[1, i//N, i%N]
      priorities[i][1] = -((priorities[i][0]))
    else:
      priorities[i][0] = -((total_spin + np.sum(h[:,i%N])) / 3) - J[1, i//N, i%N]
      priorities[i][1] = (priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.3427186728395051}
#island_id: 0
#version_generated: 2
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's nearest neighbors' spins
    for j in range(4):
      if J[j, i//N, i//N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.2172254629629629}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = -1
    else:
      total_spin = 1
      
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
     j, l = i//N + k - 1, i%N
     if J[k,i%N,l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
     j = i//N - 1 + k
     l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
     if J[3, i%N, l] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 9
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
   
  return(priorities)




#score: {'data2D.txt': 0.1812273148148149}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 7
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.22647422839506168}
#island_id: 0
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j = i//N - 1 + k
      l = (i%N + 1) % N if k == 0 else (i%N - 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (7 + np.count_nonzero(h[i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time12:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.12044552469135816}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h_site - sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.06214768518518519}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for j in range(3):
      k = (j + i // N) % N
      if J[j, i % N, i // N] > 0:
        priorities[i][0] += h[k][i % N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= h[k][i % N]
        priorities[i][1] += 1

    if h[i//N][i%N] > 0:
      priorities[i][0] += h_site + sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h_site - sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3)])
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.13712608024691378}
#island_id: 2
#version_generated: 2
#generate time12:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3) for k in range(N)])
      priorities[i][0] = total_spin
      priorities[i][1] -= len([j for j in range(3) if J[j, i % N, i // N]>0])
    else:
      total_spin -= sum([J[j, i % N, i // N]*h[k][i % N] for j in range(3) for k in range(N)])
      priorities[i][0] = -total_spin
      priorities[i][1] += len([j for j in range(3) if J[j, i % N, i // N]>0])
  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = h[site_nbr][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      site_k = (k+N-1)%N
      if J[k,i%N,i//N] > 0:
        h_k = h[site_k][i%N]
      else:
        h_k = -h[site_k][i%N]

      priorities[i][0] += h_site + h_k
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 2
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.22411064814814807}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + ((k-1)%2 - 1), (k+1)%2
      if J[k,i%N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for k in range(2):
      j, l = i//N + (k+1)%2, i%N - (k-1)%2
      if J[2*i%2,k,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.222611574074074}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1:
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-2 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-2 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22303842592592585}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time12:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2228100308641976}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': -0.07532854938271609}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin - 1]
    else:
      priorities[i] = [-total_spin - 1, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': -0.0018313271604938272}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    total_spin += h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11504675925925939}
#island_id: 3
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time12:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.2178668209876543}
#island_id: 0
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j = i//N + k - 1
      l = i%N
      if J[k, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if j > 0 and l < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 6
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16575663580246935}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((0)%2 - 1)) % N
    
    if h[site_nbr_left][i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if h[site_nbr_right][i%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16501250000000023}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate spin interactions from the left and right
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i-1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Calculate spin interactions from the top and bottom
    site_nbr = (i % N + ((i//N-2)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if i != 0 and i < N**2-N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3,i%N,(i-1)%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.008915277777777775}
#island_id: 2
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      site_nbr_k = (site_nbr + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]*h[site_nbr_k][i%N]
    
    priorities[i][0] = h[site_nbr][i%N] + total_spin
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time12:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 2
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0004291666666666669}
#island_id: 2
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(4):
      if k == 0 and i % N != 0:
        h_site += J[k,i%N,i//N]*h[(site_nbr + N)%N][i%N]
      elif k == 1 and (i // N) * N + i % N - 1 < N**2 - N:
        h_site += J[k,i%N,i//N]*h[site_nbr][((i+N-1)%N)]
      elif k == 2 and (i // N) * N + i % N + 1 >= 0:
        h_site += J[k,i%N,i//N]*h[site_nbr][((i-1)%N)]
      else:
        h_site += J[k,i%N,i//N]*h[(site_nbr+N-1)%N][(i+1)%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time12:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add second nearest neighbor interactions (if any)
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Normalize by the number of neighbors
    total_neighbors = 4 if i % N == 0 or i % N == N-1 else 8
    for j in range(2):
      priorities[i][j] /= total_neighbors
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.30986898148148123}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i % N
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,i//N,site_nbr_row] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i%N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i%N+1)%N - 1)) % N
    if J[0,i//N,site_nbr_left] > 0:
      total_spin += 1
    elif J[0,i//N,site_nbr_right] > 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    site_nbr_up = (i // N + ((i % N-1)%2 - 1)) % N
    site_nbr_down = (i // N + ((i % N+1)%N - 1)) % N
    if J[3,i//N,site_nbr_up] > 0:
      total_spin += 1
    elif J[3,i//N,site_nbr_down] > 0:
      total_spin -= 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16043842592592614}
#island_id: 1
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.3427356481481471}
#island_id: 0
#version_generated: 2
#generate time12:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's own spin
    if neighbors_spin.mean() > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.342724537037036}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] -= 2
    
    # Add a penalty for not aligning with the magnetism of nearest neighbors
    for j in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] != J[j, i//N, i//N]:
        priorities[i][j % 2] -= 1
    
    # Add a bonus for aligning with the majority spin of nearest neighbors
    majority_spin = np.sum(neighbors_spin) > 0
    if h[site_nbr][i%N] > 0 and majority_spin:
      priorities[i][1] += 2
    elif h[site_nbr][i%N] < 0 and not majority_spin:
      priorities[i][0] -= 2
    
    # Add a bonus for aligning with the site's magnetism if it is strong
    if abs(h[i//N][i%N]) > 1.5:
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0013779320987654317}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    
    # Calculate the total spin at this site
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    # Calculate the priorities for each spin state
    if total_spin >= 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin - 2 * (h[site_nbr][i%N] > 0) - 1 * (np.sum(neighbors_spin) < 0)
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + 2 * (h[site_nbr][i%N] > 0) + 1 * (np.sum(neighbors_spin) < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19632299382716054}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.28601126543209826}
#island_id: 0
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N > 0:
      j = i//N - 1
      l = i%N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0) + int(i % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
  
  return(priorities)




#score: {'data2D.txt': -0.018455092592592606}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1 if h[i//N][i%N] * h[site_nbr][i%N] < 0 else -1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1 if h[i//N][i%N] * h[site_nbr][i%N] > 0 else 1

  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0012770061728395064}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-site_energy)
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = 1 - np.exp(site_energy)

  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add more energy terms from J
    for j in range(3):
        if i//N != 0 and (i-1)%N == j:
            site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
            site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
            site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.1649069444444446}
#island_id: 1
#version_generated: 2
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add interactions with nearest neighbors
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,1,3]]
    for j in site_nbrs:
      if J[0,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interactions with diagonally neighboring sites
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [4,5]]
    for j in site_nbrs:
      if J[3,i//N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.006232561728395062}
#island_id: 1
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      neighbors_spin = 0
      for k in range(4):
        neighbors_spin += J[k,i%N,i//N]
      priorities[i][0] = neighbors_spin
      priorities[i][1] = -neighbors_spin
      
    else:
      neighbors_spin = 0
      for k in range(4):
        neighbors_spin -= J[k,i%N,i//N]
      priorities[i][0] = -neighbors_spin
      priorities[i][1] = neighbors_spin
  
  return(priorities)




#score: {'data2D.txt': 0.1661791666666669}
#island_id: 1
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%N - 1)) % N
    if J[0,i%N,i//N] > 0:
      total_spin += h[site_nbr_left][i%N]
      total_spin -= h[site_nbr_right][i%N]
    else:
      total_spin -= h[site_nbr_left][i%N]
      total_spin += h[site_nbr_right][i%N]
    
    site_nbr_up = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_down = (i % N + ((i//N+1)%N - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[i%N,site_nbr_up]
      total_spin -= h[i%N,site_nbr_down]
    else:
      total_spin -= h[i%N,site_nbr_up]
      total_spin += h[i%N,site_nbr_down]

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
    
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': 0.06553132716049385}
#island_id: 0
#version_generated: 2
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
    # Add a heuristic term to guide the search
    if total_spin > 0.5:
      priorities[i][0] -= (total_spin - 0.5)**2
    elif total_spin < -0.5:
      priorities[i][1] -= (total_spin + 0.5)**2
    
    # Add a term based on the interaction with all neighboring sites
    neighbor_sum = np.sum(J[:,i//N], axis=0)
    if h[i//N][i%N] > 0:
      priorities[i][0] += -neighbor_sum[1]
      priorities[i][1] -= -neighbor_sum[0]
    else:
      priorities[i][0] -= neighbor_sum[1]
      priorities[i][1] += neighbor_sum[0]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.33343379629629527}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[l,i%N,0] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      if J[1,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      if J[3,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.012360339506172806}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with the site above
    j = i//N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[l,i%N,0] * h[site_nbr][j]
    
    # Add interaction with the site below
    j = i//N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[l,i%N,0] * h[site_nbr][j]
    
    # Add interaction with the site to the left
    j = i % N - ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[1,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site to the right
    j = i % N + ((i//N-1)%2 - 1)
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[3,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site above-left
    j = i//N - ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site above-right
    j = i//N - ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site below-left
    j = i//N + ((i//N-1)%2 - 1)
    k = (3)%2
    if j >= 0 and j < N:
      l = (1)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Add interaction with the site below-right
    j = i//N + ((i//N-1)%2 - 1)
    k = (1)%2
    if j >= 0 and j < N:
      l = (3)%2
      total_spin += J[k,i%N,l] * h[site_nbr][j]
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.3427368827160483}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)
    
    # Add a bonus for aligning with the majority of the neighbors
    if np.sum(neighbors_spin) > 0:
      priorities[i][1] += np.sum(neighbors_spin)
    else:
      priorities[i][0] += np.sum(neighbors_spin)

  return(priorities)




#score: {'data2D.txt': -0.007752314814814814}
#island_id: 0
#version_generated: 2
#generate time12:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0, i//N, i//N] > 0:
      total_spin += J[0, i//N, i//N]
      priorities[i] = [-total_spin + 2 * np.exp(-total_spin), total_spin - 2 * np.exp(total_spin)]
    else:
      total_spin -= J[1, i//N, i//N]
      priorities[i] = [total_spin - 2 * np.exp(total_spin), -total_spin + 2 * np.exp(-total_spin)]

  return(priorities)




#score: {'data2D.txt': 0.34275262345678903}
#island_id: 0
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + J[0, i//N, i//N]
      priorities[i][1] = -total_spin + J[1, i//N, i//N]
    else:
      priorities[i][0] = -total_spin + J[2, i//N, i//N]
      priorities[i][1] = total_spin + J[3, i//N, i//N]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  return(priorities)




#score: {'data2D.txt': 0.1853757716049385}
#island_id: 0
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-total_spin)
    else:
      priorities[i][0] -= 2 * np.exp(total_spin)

  # Add a bonus for aligning with the nearest neighbor in each direction
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += 2 * np.exp(-np.sum(priorities[i//N*N:(i//N+1)*N, 0]))
      priorities[i][0] -= 2 * np.exp(np.sum(priorities[i//N*N:(i//N+1)*N, 1]))
    else:
      priorities[i][0] += 2 * np.exp(-np.sum(priorities[i//N*N:(i//N+1)*N, 1]))
      priorities[i][1] -= 2 * np.exp(np.sum(priorities[i//N*N:(i//N+1)*N, 0]))

  return(priorities)




#score: {'data2D.txt': -0.28239922839506126}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Sort the sites based on their spin energy
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0], priorities[i][1] = sorted((priorities[i][0], priorities[i][1]), reverse=True)
    else:
      priorities[i][0], priorities[i][1] = sorted((priorities[i][0], priorities[i][1]))

  return(priorities)




#score: {'data2D.txt': 0.09345385802469144}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]<0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]<0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.21528811728395067}
#island_id: 3
#version_generated: 2
#generate time12:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin
      priorities[i][0] = np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': -0.11744706790123469}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Calculate priority based on magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.16393040123456815}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    neighbor_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        neighbor_spin -= 1
      else:
        total_spin -= h[site_nbr][i%N]
        neighbor_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + neighbor_spin, -total_spin - neighbor_spin]
    else:
      priorities[i] = [-total_spin - neighbor_spin, total_spin + neighbor_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on site and neighbor spin values
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][1] = -total_spin
    priorities[i][0] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.03003595679012347}
#island_id: 2
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    # Calculate site energy based on interactions with neighbors
    site_energy = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Adjust priority based on magnetism and site energy
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy * (1 + abs(h_site))
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy * (1 + abs(h_site))
      priorities[i][1] = -h_site

  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
      
  # Additional processing to improve the algorithm
  for i in range(N2):
    if priorities[i][1] == 1:
      if priorities[i-1][1] == -1 and priorities[(i+1)%N2][1] == 1:
        priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': -0.0009121913580246917}
#island_id: 2
#version_generated: 2
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    total_energy = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if total_energy > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -h_site
    
  return(priorities)




#score: {'data2D.txt': -0.043136265432098767}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority = [total_spin, -total_spin]
    
    priorities[i] = [priority[0] + sum(h[j][i%N] for j in range(N) if J[3,i%N,j] > 0), 
             -priority[1] - sum(h[j][i%N] for j in range(N) if J[3,i%N,j] < 0)]
  
  return(priorities)




#score: {'data2D.txt': -0.008888117283950617}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = np.array([total_spin, -total_spin])
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priority_total[0] += h[site_nbr][i%N]
      priority_total[1] -= h[site_nbr][i%N]
    else:
      priority_total[0] -= h[site_nbr][i%N]
      priority_total[1] += h[site_nbr][i%N]
    
    if J[2,i//N,i%N] > 0:
      priority_total[0] += 1
      priority_total[1] -= 1
    else:
      priority_total[0] -= 1
    
    priorities[i] = priority_total
  return(priorities)




#score: {'data2D.txt': 0.03229490740740742}
#island_id: 1
#version_generated: 2
#generate time12:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin and adjust priorities
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
        priorities[i][0] -= h[site_nbr][i%N]
    
    # Add priority based on magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= 2*total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= h[site_nbr][j]
    
    # Calculate and set final priorities
    if h[i//N][i%N] > 0:
      priorities[i][1] += -total_spin
    else:
      priorities[i][0] += total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.07260972222222228}
#island_id: 3
#version_generated: 2
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.06469305555555557}
#island_id: 3
#version_generated: 2
#generate time12:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + 3 * (J[0,i//N,i//N]+J[2,i//N,i//N])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - 3 * (J[1,i//N,i//N]+J[3,i//N,i//N])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - 3 * (J[0,i//N,i//N]+J[2,i//N,i//N])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + 3 * (J[1,i//N,i//N]+J[3,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.000839043209876543}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Sort the priorities for each site
  priorities = priorities[np.argsort(priorities[:,0])]
  
  return priorities




#score: {'data2D.txt': 0.1585282407407409}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions
    total_spin += sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
    
    # Normalize by the number of neighbors
    total_spin /= 8
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
      priorities[i][0] = total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
    else:
      priorities[i][0] = -total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
      priorities[i][1] = total_spin + sum(np.where(J[k,i//N,i//N]>0, 1, -1) for k in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.11403688271604952}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add an additional term based on the magnetism
    if h[site_nbr][i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][0] += 2
  
  return(priorities)




#score: {'data2D.txt': 0.0004365740740740744}
#island_id: 3
#version_generated: 2
#generate time12:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    spin_flip_energy = np.sum(np.where(J[:,i//N,i//N]>0, -np.sign(h[i//N][i%N]), np.sign(h[i//N][i%N])))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = spin_flip_energy
      priorities[i][0] = -spin_flip_energy
    else:
      priorities[i][0] = spin_flip_energy
      priorities[i][1] = -spin_flip_energy
  
  return(priorities)




#score: {'data2D.txt': 0.16416959876543233}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr2 = (i % N + ((3-i%2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.10498750000000007}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_bias = 2*h[i//N][i%N]
    priorities[i][0] = total_spin + spin_bias
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.11176466049382727}
#island_id: 1
#version_generated: 2
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-2)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0008217592592592592}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    priorities[i][0] = -np.abs(h_site)
    priorities[i][1] = np.abs(h_site)

  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site=h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      h_site += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      h_site -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002140895061728397}
#island_id: 2
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][k] for k in range(N)])
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': 0.14140354938271624}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with next-nearest-neighbor sites
    site_nbr_nn = (site_nbr + ((i//N+1)%2 - 1)) % N
    if J[0,i%N,(i//N+1)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11502052469135816}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2 * (i % N + i // N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22069398148148162}
#island_id: 3
#version_generated: 2
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = np.sum([total_spin])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -np.sum([total_spin])
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.11736959876543222}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism and neighbor interactions
    total_spin += h[i//N][i%N]
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= (2 + np.count_nonzero(J[:,i//N,i//N]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': -0.07079089506172843}
#island_id: 3
#version_generated: 2
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))

  # Add magnetism to the priority
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.0007677469135802473}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      spin_sum = sum([h[k][i%N] for k in range(N) if k != i//N])
      priorities[i][0] = J[0,i//N,i%N]*spin_sum + h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      spin_sum = sum([h[k][i%N] for k in range(N) if k != i//N])
      priorities[i][0] = -J[0,i//N,i%N]*spin_sum - h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0024331790123456793}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = h[site_nbr][i%N] + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][0] = -h[site_nbr][i%N] - total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 2
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time13:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.001073611111111111}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    for k in range(4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
     else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0801541666666667}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    energy = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + h[i//N][i%N]
    
    if energy > 0:
      priorities[i][0] = -energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = energy
      priorities[i][1] = -h_site
    
    # Add the magnetism contribution to the priority
    priorities[i][0] += h_site
    
  return(priorities)




#score: {'data2D.txt': -0.005752623456790124}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
    
    # Add a trick to break the symmetry: assign higher priority to +1 spin if site energy is positive, and to -1 spin if site energy is negative
    if site_energy > 0:
      priorities[i][0] -= 0.01
    elif site_energy < 0:
      priorities[i][1] -= 0.01
  
  return(priorities)




#score: {'data2D.txt': -0.0212587962962963}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2=N*N
  priorities=np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
      
    site_energy=h[i//N][i%N]+sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = h_site
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -h_site
      
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
      
  return(priorities)




#score: {'data2D.txt': 0.1175260802469137}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = 2*h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0394587962962963}
#island_id: 2
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site1 = h[site_nbr1][i%N]
      h_site2 = h[site_nbr2][i%N]
    else:
      h_site1 = -h[site_nbr1][i%N]
      h_site2 = -h[site_nbr2][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add additional spin flip priority based on the energy difference between two neighboring sites
    if i % N > 0 and J[1,i%N,(i-N-1)//N] > 0:
      site_energy_diff = sum([J[k,i%N,(i-N-1)//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if J[2,i%N,(i-1)//N] > 0 and i % N < N-1:
      site_energy_diff += sum([J[k,i%N,(i+1)//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if J[3,i%N,i//N] > 0 and i // N < N-1:
      site_energy_diff += sum([J[k,(i+N-1)%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)]) - site_energy
    else:
      site_energy_diff = 0

    if site_energy_diff > 0:
      priorities[i][0] += site_energy_diff
      priorities[i][1] = 1
    else:
      priorities[i][0] -= site_energy_diff
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.003649845679012346}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 1
#version_generated: 2
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + h[site_nbr][i%N]
      priorities[i][1] = -total_spin + h[site_nbr][i%N]
    else:
      priorities[i][0] = -total_spin - h[site_nbr][i%N]
      priorities[i][1] = total_spin - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.10769089506172846}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr1][i%N]
    else:
      h_site = -h[site_nbr1][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
    
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.04920169753086421}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-2*h_site) / (np.exp(-2*h_site) + np.exp(2*h_site))
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = 1 - np.exp(-2*h_site) / (np.exp(-2*h_site) + np.exp(2*h_site))

  return(priorities)




#score: {'data2D.txt': 0.189416512345679}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = np.exp(-2*site_energy)
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -np.exp(-2*site_energy)

  return(priorities)




#score: {'data2D.txt': 0.13751003086419764}
#island_id: 2
#version_generated: 2
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.1437229938271607}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_spins = []
    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        neighbor_spins.append(1)
      else:
        neighbor_spins.append(-1)
    total_spin += sum(neighbor_spins)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:, i//N, i%N]), -total_spin + np.sum(J[1:, i//N, i%N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:1, i//N, i%N]), total_spin + np.sum(J[1:, i//N, i%N])]
    
  return(priorities)




#score: {'data2D.txt': 0.34273873456790016}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 2  # increased the bonus from 1 to 2
    else:
      priorities[i][0] -= 2
  
  return(priorities)




#score: {'data2D.txt': 0.08026620370370371}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bonus for aligning with the magnetism at the site
    priorities[i][1] += h[site_nbr][i%N]

    for j in range(4):
      neighbor_nbr = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j, i//N, i%N] > 0:
        if h[neighbor_nbr][i%N] > 0:
          priorities[i][0] += 1
        else:
          priorities[i][1] -= 1
      else:
        if h[neighbor_nbr][i%N] > 0:
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.34273966049382615}
#island_id: 0
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = (np.where(J[0, :, i//N] > 0, 1, -1) 
              + np.where(J[1, :, i//N] > 0, 1, -1)
              + np.where(J[2, :, i//N] > 0, 1, -1)
              + np.where(J[3, :, i//N] > 0, 1, -1)).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a bonus for aligning with the magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.014329166666666669}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    # Calculate the magnetism term
    site_nbr_mag = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_mag][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.09469675925925933}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(N):
      if i//N != 0 and (i-N)%N == j:
        site_energy += J[2,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.08410478395061734}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add a bias term for the magnetism
    if h_site > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.1352387345679013}
#island_id: 2
#version_generated: 2
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    site_energy = h[i//N][i%N] + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    # Add more energy terms from J
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.2109483024691358}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22300972222222218}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j = i//N + k - 1
      if 0 <= j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for k in range(2):
      j = i//N + k - 1
      if 0 <= j < N:
        l = i%N - k
        if J[3-k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2109483024691358}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22015509259259253}
#island_id: 0
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy
    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.33500046296296193}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34289706790123353}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.23918101851851845}
#island_id: 2
#version_generated: 2
#generate time13:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    site_energy = h[i//N][i%N] + total_energy

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  for i in range(N):
    for j in range(N//2+1):
      k = (i + ((j-1)%2 - 1)) % N
      priorities[k*N+j][0] += priorities[k*N+N-j-1][0]
      priorities[k*N+j][1] -= priorities[k*N+N-j-1][1]

  return(priorities)




#score: {'data2D.txt': 0.22250169753086413}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.166851388888889}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for d in [(0,1), (-1,1)]:
      j = i//N + d[0]
      l = i%N + d[1]
      if 0 <= j < N and 0 <= l < N:
        total_spin += J[2 if d == (0,1) else 0, i%N, l] * h[j][l]
    
    # Normalize by the number of neighbors
    total_spin /= np.sum(h==h[i//N][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22303842592592585}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    l = i%N
    if J[3, i%N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2055770061728395}
#island_id: 0
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N:
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N and i%N > 0:
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    for j in range(2):
      l = i//N + j - 1
      if 0 <= l < N and i%N < N-1:
        if J[0, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time13:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = np.sum(np.where(h[site_nbr], 1, -1))
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
  return(priorities)




#score: {'data2D.txt': 0.07888009259259265}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07260972222222228}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Assign priorities based on total spin and magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.001845216049382715}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,N//2,N//2+1,N-1]]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': 0.16625015432098791}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[site_nbr][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[site_nbr][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
  
  return(priorities)




#score: {'data2D.txt': 0.059460339506172855}
#island_id: 3
#version_generated: 2
#generate time13:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.34074182098765327}
#island_id: 2
#version_generated: 2
#generate time13:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.00013410493827160496}
#island_id: 3
#version_generated: 2
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  # Sort the sites based on their priority
  priorities = priorities[np.argsort(np.sum(priorities,axis=1))]
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.022154783950617294}
#island_id: 3
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.3384337962962953}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[0,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif ((i//N+1)%2 == (site_nbr//N)%2) and (j-(i%N))**2 <= 1:
        site_energy += J[2,(i//N),(i%N)]*h[i//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34108842592592487}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(h[site_nbr][i%N])
      priorities[i][1] = 1
    else:
      priorities[i][0] = (h[site_nbr][i%N])
      priorities[i][1] = -1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
  
  return(priorities)




#score: {'data2D.txt': 0.34289706790123353}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = 0
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34076219135802366}
#island_id: 2
#version_generated: 2
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
              for j in range(3) if i//N != 0 and (i-1)%N == j)
    site_energy += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
               for j in range(2) if i%N != N-1 and (i-1)%N == j)
    site_energy += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
               for j in range(2) if i//N == N-1 and (i-N)%N == j)

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Compute total spin energy considering nearest neighbors
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at the site
    total_spin += h[site_nbr][i%N]
    
    # Compute priority based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # consider nearest neighbors first
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # then magnetism at the site itself
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.059460339506172855}
#island_id: 3
#version_generated: 2
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Update priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + total_spin * np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - total_spin * np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[-1e6 if j%2==i else 1e6 for i in range(2)] for j in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.07159830246913586}
#island_id: 3
#version_generated: 2
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.009964660493827162}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.34074182098765327}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.1986155864197533}
#island_id: 2
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add the priority for the next sites to consider flipping
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,i//N,i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[0,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16525632716049407}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.0004603395061728403}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002964506172839509}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 0
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    sum_h = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum_h
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum_h
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time13:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on interactions with nearest neighbors
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.3408961419753076}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
                  for j in range(3) if i//N != 0 and (i-1)%N == j)
      priorities[i][0] += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
                  for j in range(2) if i%N != N-1 and (i-1)%N == j)
      priorities[i][0] -= sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
                  for j in range(2) if i//N == N-1 and (i-N)%N == j)

    else:
      priorities[i][0] = -sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
                    for j in range(3) if i//N != 0 and (i-1)%N == j)
      priorities[i][0] -= sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
                    for j in range(2) if i%N != N-1 and (i-1)%N == j)
      priorities[i][0] += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
                    for j in range(2) if i//N == N-1 and (i-N)%N == j)

    priorities[i][1] = 1 if h[i//N][i%N] > 0 else -1

  return(priorities)




#score: {'data2D.txt': -0.0011557098765432104}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_plus = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
              for j in range(3) if i//N != 0 and (i-1)%N == j)
    energy_plus += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
              for j in range(2) if i%N != N-1 and (i-1)%N == j)
    energy_plus += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
              for j in range(2) if i//N == N-1 and (i-N)%N == j)
    
    energy_minus = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
               for j in range(3) if i//N != 0 and (i+1)%N == j)
    energy_minus += sum(J[1,i//N,i//N]*h[i//N][i%N] 
               for j in range(2) if i%N != N-1 and i//N == j)
    energy_minus += sum(J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N] 
               for j in range(2) if i//N == 0 and (i+1)%N == j)
    
    priorities[i][0] = -energy_plus + energy_minus
    priorities[i][1] = 1
    
  return(priorities)




#score: {'data2D.txt': 0.0012146604938271576}
#island_id: 2
#version_generated: 2
#generate time13:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    if J[0, i//N, i//N] > 0:
      total_spin -= 2 * h[site_nbr1][i%N]
    else:
      total_spin += 2 * h[site_nbr1][i%N]

    if J[1, (i-1)//N, i//N] > 0:
      total_spin -= 2 * h[site_nbr2][i%N]
    else:
      total_spin += 2 * h[site_nbr2][i%N]

    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34076219135802366}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = sum(J[0,(i//N)%N,i//N]*h[(i//N)%N][i%N] 
             for j in range(3) if i//N != 0 and (i-1)%N == j)
    total_spin += sum(J[1,(i-1)//N,i//N]*h[(i-1)//N][i%N] 
              for j in range(2) if i%N != N-1 and (i-1)%N == j)
    total_spin += sum(J[2,(i-N+1)//N,i//N]*h[(i-N+1)//N][i%N] 
              for j in range(2) if i//N == N-1 and (i-N)%N == j)

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.33322021604938173}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priorities[i][0] -= J[1,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priorities[i][0] += J[2,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priorities[i][0] -= J[3,(i-1)//N,i//N]
      priorities[i][1] = -1
    else:
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priorities[i][0] += J[1,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priorities[i][0] -= J[2,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priorities[i][0] += J[3,(i-1)//N,i//N]
      priorities[i][1] = 1
  
  return(priorities)




#score: {'data2D.txt': 0.3557831790123447}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 1
      for j in range(3):
        if (i-1)%N == j and i//N != 0:
          total_spin += J[1,i//N,j]*h[(i-1)//N][j]
        elif (i-N)%N == j and i//N == N-1:
          total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      total_spin = -1
      for j in range(3):
        if (i-1)%N == j and i//N != 0:
          total_spin -= J[1,i//N,j]*h[(i-1)//N][j]
        elif (i-N)%N == j and i//N == N-1:
          total_spin -= J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.00022793209876543225}
#island_id: 2
#version_generated: 2
#generate time13:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.07425262345679018}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07501033950617289}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
  return(priorities)




#score: {'data2D.txt': 0.1650634259259262}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.07888009259259265}
#island_id: 3
#version_generated: 2
#generate time13:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0473686728395062}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0014662037037037042}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.04247083333333336}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sum = sum([J[k,i%N,i//N]*h[(k+((j-1)%2 - 1)) % N][i%N] for j,k in zip(range(4),range(4))])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.002058796296296297}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])*h_site + J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])*h_site - J[1,i//N,i//N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.046535030864197566}
#island_id: 0
#version_generated: 2
#generate time13:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = [h[(site_nbr + j) % N][i%N] for j in range(-1,2) if (site_nbr + j) % N != site_nbr]
    nn_sum = sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + nn_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - nn_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.08586280864197537}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(np.where(J[:,i//N,i//N]<0, 1, 0))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11150848765432106}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    # Calculate bias term based on local magnetism
    bias = h[i//N][i%N]
    
    # Prioritize spins that align with local magnetism
    priorities[i][1] = total_spin + bias
    priorities[i][0] = -total_spin - bias
  
  return(priorities)




#score: {'data2D.txt': 0.06562083333333336}
#island_id: 3
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + h[i//N][i%N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - h[i//N][i%N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term to encourage spins to align with the local magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += h[i//N][i%N]
      priorities[i][0] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0025239197530864204}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_sum = sum([J[0,i%N,i//N]*((site_nbr + ((k-1)%2 - 1)) % N) for k in range(3)])
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + nn_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0008646604938271608}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016791666666666663}
#island_id: 0
#version_generated: 2
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_h = h[nn_site][i%N]
      else:
        nn_h = -h[nn_site][i%N]

      nns.append(J[j,i//N,nn_site]*nn_h)
    if sum(nns) > 0:
      priorities[i][0] = h_site + max([n for n in nns])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nns])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.00023719135802469115}
#island_id: 0
#version_generated: 2
#generate time13:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
      priorities[i][0] = (J_up - J_down)*h_site
      priorities[i][1] = -priorities[i][0]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
      priorities[i][0] = (J_up - J_down)*h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.3174069444444438}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
     nn_site = (site_nbr + ((j-1)%2 - 1)) % N
     if J[j,i//N,nn_site] > 0:
       nns.append(J[j,i//N,nn_site])
     else:
       nns.append(-J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009353858024691358}
#island_id: 0
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.07501033950617289}
#island_id: 3
#version_generated: 2
#generate time13:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': -0.004094290123456794}
#island_id: 3
#version_generated: 2
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.057388734567901264}
#island_id: 3
#version_generated: 2
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
  
  # Since the Ising model is symmetric, we can reduce the number of calculations
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
  
  return(priorities)




#score: {'data2D.txt': 0.34066651234567796}
#island_id: 2
#version_generated: 2
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] = 1
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] = -1
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
  
  return(priorities)




#score: {'data2D.txt': 0.14475293209876564}
#island_id: 2
#version_generated: 2
#generate time13:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(h[site_nbr][i%N])
      priorities[i][1] = 1
    else:
      priorities[i][0] = (h[site_nbr][i%N])
      priorities[i][1] = -1
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_spin += J[2,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += J[1,(i-1)//N,i//N]*h[(i-1)//N][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += -total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.0705106481481482}
#island_id: 3
#version_generated: 2
#generate time13:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
    # Additional improvement: swap the priority if necessary to minimize energy
    if priorities[i][0] > priorities[i][1]:
      priorities[i][0], priorities[i][1] = priorities[i][1], priorities[i][0]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
  
  return(priorities)




#score: {'data2D.txt': 0.057388734567901264}
#island_id: 3
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h[site_nbr])
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h[site_nbr])
    
  # Since the Ising model is symmetric, we can reduce the number of calculations
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[N*N - i - 1, 0], priorities[N*N - i - 1, 1] = priorities[i, 1], priorities[i, 0]
    
  return(priorities)




#score: {'data2D.txt': 0.15929706790123482}
#island_id: 2
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    
    # Add the energy from nearest neighbors
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
    
    # Add the priority for flipping to the next sites
    if i % N > 0 and h[(i-1)//N][(i-1)%N] > 0:
      priorities[i][0] += J[0,(i-1)//N,i//N]
      priorities[i][1] -= 1
    elif i % N > 0 and h[(i-1)//N][(i-1)%N] < 0:
      priorities[i][0] -= J[0,(i-1)//N,i//N]
    
    if i // N < N - 1 and h[(i+1)//N][(i+1)%N] > 0:
      priorities[i][0] += J[3,(i+1)//N,i//N]
      priorities[i][1] -= 1
    elif i // N < N - 1 and h[(i+1)//N][(i+1)%N] < 0:
      priorities[i][0] -= J[3,(i+1)//N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.0123554012345679}
#island_id: 2
#version_generated: 2
#generate time13:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[site_nbr][i%N]
    for j in range(4):
      if i//N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
      elif i//N == N-1 and (i-N)%N == (j+1)%4:
        site_energy += J[3,(i-N)//N,i//N]*h[(i-N)//N][(j+1)%4]
      elif i%N != 0 and (i-1)%N == (j+1)%4:
        site_energy += J[j,(i-1)//N,i//N]*h[(i-1)//N][(j+1)%4]
    
    total_priority = -site_energy
    
    if h[i//N][i%N] > 0:
      total_priority -= 1
    else:
      total_priority += 1
    
    priorities[i][0] = total_priority
    priorities[i][1] = -1 if total_priority < 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.011683487654320987}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00023719135802469115}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -(J_up + J_down)*h_site

  return(priorities)




#score: {'data2D.txt': 0.0007646604938271605}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) + J[3,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)]) - J[3,i//N,i//N]
    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.01349212962962963}
#island_id: 0
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i//N,i%N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    if h[i//N][i%N] > 0:
      spin_energy = J_up
    else:
      spin_energy = J_down

    priorities[i][0] = spin_energy * h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 2*(h[site_nbr][i%N])
      priorities[i][1] = -total_spin - 2*(h[site_nbr][i%N])
    else:
      priorities[i][0] = -total_spin - 2*(h[site_nbr][i%N])
      priorities[i][1] = total_spin + 2*(h[site_nbr][i%N])
    
  return(priorities)




#score: {'data2D.txt': 0.29325694444444383}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if j == 0 and i//N != 0:
        total_spin += J[0,i//N,0]*h[(i-1)//N][0]
      elif j == 1 and i//N != 0:
        total_spin += J[1,i//N,j%2]*h[(i-1)//N][j%2]
      elif j == 2 and i//N != N-1:
        total_spin += J[2,(i-N)//N,i//N]*h[(i-N)//N][j%2]
      else:
        total_spin += J[3,(i-N)//N,i//N]*h[(i-N)//N][0]
    if h[i//N][i%N] > 0:
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.010125154320987654}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interaction with all nearest neighbors
    for j in range(4):
      if j == 0 and i//N != 0:
        total_spin += J[j, i//N, i%N]*h[(i-1)//N][(i-1)%N]
      elif j == 1 and i%N != N-1:
        total_spin += J[j, i//N, i%N]*h[i//N][min(i%N+1, N-1)]
      elif j == 2 and i//N != N-1:
        total_spin += J[j, i//N, i%N]*h[max(0, i//N-1), i%N]
      elif j == 3 and (i-N)%N == 0 or (i+N)%N == N*N-1:
        total_spin += J[j, (i-N)//N if (i-N)%N == 0 else (i+N)//N, i%N]*h[(i-N)//N if (i-N)%N == 0 else (i+N)//N][min(i%N+1, N-1)]
    
    priorities[i][0] = -total_spin
    priorities[i][1] = 1 if total_spin > 0 else -1
  
  return(priorities)




#score: {'data2D.txt': 0.2026199074074076}
#island_id: 2
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 1
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin += J[0,i//N,0]*h[(i-1)//N][0]
        elif j == 1 and i//N != 0:
          total_spin += J[1,i//N,j%2]*h[(i-1)//N][j%2]
        elif j == 2 and i//N < N-1:
          total_spin += J[2,(i-N)%N,i//N]*h[(i-N)//N][(i-1)%N]
        elif j == 3 and i//N == N-1:
          total_spin += J[3,(i-N)//N,N-1]*h[(i-N)//N][0]
      priorities[i][0] = -(total_spin)
      priorities[i][1] = 1
    else:
      total_spin = -1
      for j in range(4):
        if j == 0 and i//N != 0:
          total_spin -= J[0,i//N,0]*h[(i-1)//N][0]
        elif j == 1 and i//N != 0:
          total_spin -= J[1,i//N,j%2]*h[(i-1)//N][j%2]
        elif j == 2 and i//N < N-1:
          total_spin -= J[2,(i-N)%N,i//N]*h[(i-N)//N][(i-1)%N]
        elif j == 3 and i//N == N-1:
          total_spin -= J[3,(i-N)//N,N-1]*h[(i-N)//N][0]
      priorities[i][0] = (total_spin)
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.16641342592592617}
#island_id: 3
#version_generated: 2
#generate time13:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) 
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a term based on the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
    
    # Consider the priority based on the current state of the spins
    if (h[i//N][i%N] > 0 and priorities[i][0] < priorities[i][1]) or (h[i//N][i%N] < 0 and priorities[i][0] > priorities[i][1]):
      # If this site is likely to be aligned with the majority, prioritize it
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
      else:
        priorities[i][0] -= 1
    elif (h[i//N][i%N] > 0 and priorities[i][0] > priorities[i][1]) or (h[i//N][i%N] < 0 and priorities[i][0] < priorities[i][1]):
      # If this site is likely to be anti-aligned with the majority, prioritize it
      if h[i//N][i%N] > 0:
        priorities[i][0] -= 1
      else:
        priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.12849614197530881}
#island_id: 3
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on site magnetism and spin interactions
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - J[0,i//N,i//N]
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + J[0,i//N,i//N]
    
    # Consider the priority of neighboring sites
    for j in range(2):
      site_nbr_2d = (i // N, i % N)
      site_nbr_1d = i // N * N + i % N
      
      if h[i//N][i%N] > 0:
        if priorities[site_nbr_1d][j] > priorities[i][j]:
          priorities[i][j] += (priorities[site_nbr_1d][j] - priorities[i][j])
        elif priorities[site_nbr_1d][j] < priorities[i][j]:
          priorities[i][j] -= (priorities[i][j] - priorities[site_nbr_1d][j])
      
      else:
        if priorities[site_nbr_1d][j] > priorities[i][j]:
          priorities[i][j] -= (priorities[site_nbr_1d][j] - priorities[i][j])
        elif priorities[site_nbr_1d][j] < priorities[i][j]:
          priorities[i][j] += (priorities[i][j] - priorities[site_nbr_1d][j])
  
  return(priorities)




#score: {'data2D.txt': 0.001304783950617284}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0013794753086419744}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_values = [J[j,i//N,nn_sites[j]] for j in range(3)]
    
    if sum(nn_values) > 0:
      priorities[i][0] = h_site + max([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_values])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time13:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16518225308641996}
#island_id: 1
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.09454305555555564}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.15541219135802473}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((j-1)%2 - 1)) % N for j in range(3)]
    nn_energies = [h[nn_site][i%N] if J[j,i//N,nn_site] > 0 else -h[nn_site][i%N] for j, nn_site in enumerate(nn_sites)]

    total_energy = sum(x*y for x,y in zip(nn_energies, [1 if h[i//N][i%N] > 0 else -1]*3)) + h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06266064814814815}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.1404871913580247}
#island_id: 0
#version_generated: 2
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_energy_sum = 0
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy_sum += h[nn_site][i%N]
      else:
        nn_energy_sum -= h[nn_site][i%N]

    total_energy = h[i//N][i%N] + nn_energy_sum
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.05871990740740745}
#island_id: 3
#version_generated: 2
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    
    # Add a term that favors aligning spins with the site's magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
  
  return(priorities)




#score: {'data2D.txt': 0.07425262345679018}
#island_id: 3
#version_generated: 2
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      priorities[i][1] += 1
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07455416666666673}
#island_id: 3
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1))
    
    # Add a correction term based on the magnetism at this site
    if h[i//N][i%N] > 0:
      priorities[i][1] += np.sum(h[site_nbr])
      priorities[i][0] -= np.sum(h[site_nbr])
    else:
      priorities[i][0] += np.sum(h[site_nbr])
      priorities[i][1] -= np.sum(h[site_nbr])
    
    # Add a term based on the current spin
    if i//N < N/2:
      if h[i//N][i%N] > 0:
        priorities[i][1] += 1
        priorities[i][0] -= 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    else:
      if h[i//N][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.041178240740740744}
#island_id: 3
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (2*len(np.where(J[:,i//N,i//N]>0)[0]))
    
    if h[i//N][i%N] > 0:
      priorities[i][1] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h)
      priorities[i][0] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h)
    else:
      priorities[i][0] = -total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) + np.sum(h)
      priorities[i][1] = total_spin + np.sum(np.where(J[:,i//N,i//N]>0, 1, -1)) - np.sum(h)
  
  return(priorities)




#score: {'data2D.txt': 0.34288688271604834}
#island_id: 2
#version_generated: 2
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 0
      for j in range(4):
        if i//N != 0 and (i-1)%N == j:
          total_spin -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
          total_spin += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
          total_spin -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      priorities[i][0] = -total_spin
      priorities[i][1] = 1
    else:
      total_spin = 0
      for j in range(4):
        if i//N != 0 and (i-1)%N == j:
          total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
        elif i//N == N-1 and (i-N)%N == j:
          total_spin -= J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
        elif i%N != 0 and (i-1)%N == j:
          total_spin += J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      priorities[i][0] = total_spin
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.28277916666666625}
#island_id: 2
#version_generated: 2
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] = 1
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] = -1
    
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        priorities[i][0] += J[4-(j+1),(i-N)//N,i//N]*h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        priorities[i][0] -= J[j,(i-1)//N,i//N]*h[(i-1)//N][j]
    
    # Add a term for the site's own interaction
    if i % N > 0: 
      priorities[i][0] += J[0,(i-1)//N,i//N]*h[i//N][i%N]
    elif i % N == 0:
      priorities[i][0] -= J[3,(i+1)//N,i//N]*h[i//N][i%N]
    
    if i // N > 0: 
      priorities[i][0] += J[2,(i-1)//N,i//N]*h[i//N][i%N]
    elif i // N == 0:
      priorities[i][0] -= J[1,(i+1)//N,i//N]*h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1656881172839509}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + (1 + (i//N-1)%2 - 1)) % N
    
    if h[site_nbr_left][i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if h[site_nbr_right][i%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.007555092592592593}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if np.sum(J[:,i//N,i//N]) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions from all four neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.033701388888888885}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the priority based on the interactions with distant sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Add the priority based on the magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1875470679012347}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0,0.0] for _ in range(N*N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = sum([J[0,(i//N)%N,i//N]*h[(i//N)%N][j] if j%N != i%N else 0.5*J[1,(i//N)%N,i//N]*h[(i//N)%N][j] for j in range(N)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.2806344135802465}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.009791820987654323}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      priority_plus_one = 0
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priority_plus_one += J[2,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priority_plus_one += J[3,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priority_plus_one += J[1,(i-1)//N,i//N]

      priorities[i][0] = -priority_plus_one
      priorities[i][1] = 1
    else:
      priority_minus_one = 0
      for j in range(3):
        if i//N != 0 and (i-1)%N == j:
          priority_minus_one += J[2,(i-1)//N,i//N]
        elif i//N == N-1 and (i-N)%N == j:
          priority_minus_one += J[3,(i-N)//N,i//N]
        elif i%N != 0 and (i-1)%N == j:
          priority_minus_one += J[1,(i-1)//N,i//N]

      priorities[i][0] = priority_minus_one
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.06924614197530868}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_sites.append(nn_energy)

    total_energy = sum(nn_sites) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.06733873456790126}
#island_id: 0
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,site_nbr,i//N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
      
    priorities[i][0] = total_spin
    priorities[i][1] = -1 if total_spin < 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.0019745370370370385}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr])
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0002964506172839509}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.057722685185185196}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      neighbors = [(k, (k+i-N)//N) for k in range(4)]
      for neighbor in neighbors:
        priorities[i][0] -= J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]
    if h_site > 0:
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.07387021604938272}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2*total_spin

  # Add a correction term to avoid flipping spins unnecessarily
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if np.sum(J[:,i//N,i%N]) > 0:
      priorities[i][0] -= np.abs(np.sum(J[:,i//N,i%N]))/2
      priorities[i][1] += np.abs(np.sum(J[:,i//N,i%N]))
    else:
      priorities[i][0] += np.abs(np.sum(J[:,i//N,i%N]))/2
      priorities[i][1] -= np.abs(np.sum(J[:,i//N,i%N]))

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * 3
      priorities[i][1] -= 2 * total_spin
    else:
      priorities[i][0] -= total_spin * 3
      priorities[i][1] += 2 * total_spin

  return(priorities)




#score: {'data2D.txt': -0.004933796296296297}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.05242700617283951}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(4):
      if J[j,i//N,(site_nbr+(j-1)%2-N)%N] > 0:
        priorities[i][0] += J[j,i//N,(site_nbr+(j-1)%2-N)%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[j,i//N,(site_nbr+(j-1)%2-N)%N]
        priorities[i][1] += 1
    priorities[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -total_energy if sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) < 0 else total_energy
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin[i//N][i%N][0] + 1
      priorities[i][1] = -(total_spin[i//N][i%N][0] + 1)
    else:
      priorities[i][0] = total_spin[i//N][i%N][0] - 1
      priorities[i][1] = -(total_spin[i//N][i%N][0] - 1)

  return(priorities)




#score: {'data2D.txt': 0.0008646604938271608}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0063804012345679}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.009256635802469135}
#island_id: 0
#version_generated: 2
#generate time13:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum([J[0,i%N,i//N] if j == 0 else J[1,i//N,(site_nbr + ((j-1)%2 - 1)) % N] for j in range(4)])
    priorities[i][0] = h[site_nbr][i%N] + total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11721620370370385}
#island_id: 1
#version_generated: 2
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((3)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum(h[site_nbr2][j] for j in range(N))
      priorities[i][1] = -total_spin - sum(-h[site_nbr2][j] for j in range(N))
    else:
      priorities[i][0] = -total_spin + sum(h[site_nbr2][j] for j in range(N))
      priorities[i][1] = total_spin - sum(h[site_nbr2][j] for j in range(N))
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.003023302469135803}
#island_id: 3
#version_generated: 2
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      if J[0,i%N,i//N] > 0:
        h_site = h[site_nbr][i%N]
      else:
        h_site = -h[site_nbr][i%N]

      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      if J[0,i%N,i//N] > 0:
        h_site = -h[site_nbr][i%N]
      else:
        h_site = h[site_nbr][i%N]

      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions from neighboring sites
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism at the site itself
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': 0.13293009259259275}
#island_id: 1
#version_generated: 2
#generate time13:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][k] > 0:
        total_spin += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][k] < 0:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.00207608024691358}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - i % N) == 1:
        nns.append(J[0, i%N, i//N] * h_site)
      elif i//N == nn_site // N and abs(nn_site % N - i % N) > 1:
        nns.append(0)
      else:
        nns.append(J[(j-1)%2, i%N, i//N]*h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([n for n in nns])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0473686728395062}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])
      
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007646604938271605}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) + J[3,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)]) - J[3,i//N,i//N]

    priorities[i][0] = (J_up - J_down)*h_site
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0028449074074074067}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  nns = [i for i in range(4)]
  priorities = [[0,0] for _ in range(N*N)]

  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      h_site = 1
    else:
      h_site = -1

    J_up = np.sum([J[i,k%N,k//N]*h_site for i in nns]) + J[3,k//N,k//N]
    J_down = -np.sum([J[i,k%N,k//N]*(-h_site) for i in nns]) - J[3,k//N,k//N]

    priorities[k][0] = (J_up - J_down)*h_site
    priorities[k][1] = -priorities[k][0]

  return(priorities)




#score: {'data2D.txt': 0.004153240740740741}
#island_id: 0
#version_generated: 2
#generate time13:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[h_site]+nns)]) 
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(4),[-h_site]+nns)])
    priorities[i][0] = (J_up + J_down)*h_site
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.2806344135802465}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.3082109567901227}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_energy += J[k,i//N,i//N]*h[site][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.0013146604938271604}
#island_id: 2
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = 0
    if i//N > 0:
      total_energy += J[0,i//N,i//N]*h[(i-1)//N][i%N]
    if i//N < N-1:
      total_energy += J[2,(i+1)//N,i//N]*h[(i+1)//N][i%N]
    
    if i%N > 0:
      total_energy += J[1,(i//N)%N,i//N]*h[i//N][i%N-1]
    if i%N < N-1:
      total_energy += J[3,i//N,(i+1)%N]*h[i//N][(i+1)%N]

    energy_difference = 2*h[i//N][i%N] * (total_energy + h[i//N][i%N])
    
    if energy_difference > 0:
      priorities[i][0] = -energy_difference
      priorities[i][1] = 1
    else:
      priorities[i][0] = energy_difference
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': -0.051234413580246864}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[1] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin[1]
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin[0] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin[0]
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0013282407407407407}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[i//N][i%N]
    if h_site > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.002385030864197532}
#island_id: 3
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    else:
      total_spin -= sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.0007476851851851852}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += total_energy + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.006340277777777778}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if J[0,i//N,i%N]*h[(i+1)%N][i%N] > 0:
      priorities[i][0] = total_energy - (J[0,i//N,i%N]*2 + J[1,i//N,i%N])
    elif J[0,i//N,i%N]*h[(i+1)%N][i%N] < 0:
      priorities[i][0] = total_energy + (J[0,i//N,i%N]*2 - J[1,i//N,i%N])
    else:
      priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.05059953703703704}
#island_id: 0
#version_generated: 2
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k%2==0 else h[(i+k+1)%N][i%N]) for k in range(4))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.006355092592592594}
#island_id: 3
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[1] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + (total_spin[1] if h[site_nbr][i%N] > 0 else -total_spin[1])
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin[0] += h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + (total_spin[0] if h[site_nbr][i%N] > 0 else -total_spin[0])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.1420492283950618}
#island_id: 3
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) + h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) - h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0056594135802469124}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      if j == 0: nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      elif j == 1: nn_site = (i // N + ((site_nbr-1)%N) - 1) % N
      elif j == 2: nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      else: nn_site = (i // N + ((site_nbr+1)%N) - 1) % N
      
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0066575617283950615}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  # Add some extra magic to make the function even better
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] += 0.5 * total_energy ** 2
    priorities[i][1] -= priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006665586419753086}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_spin = 1
      else:
        nn_spin = -1

      nns.append(nn_spin * h[nn_site][i%N])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.005132561728395061}
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == (i//N+1)%N or i%N==0: 
        nn_site = (site_nbr + 1) % N  
      elif i//N==(i//N+1)%N and i%N==N-1:
        nn_site = (site_nbr - 1) % N
      nns.append(J[j,i//N,nn_site])

    total_energy = sum(nns) * h[i//N][i%N]
    priorities[i][0] = h_site + total_energy
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0016578703703703703}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    spin_energy = h_site + sum([n*n for n in nns])
    if spin_energy > 0:
      priorities[i][0] = max([spin_energy - J[0,i%N,i//N]*n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = min([spin_energy + J[0,i%N,i//N]*n for k,n in zip(range(4),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_site = -1
      priority_total = -sum(J[j,i//N,site_nbr] for j in range(3))
    else:
      priority_site = 1
      priority_total = sum(J[j,i//N,site_nbr] for j in range(3))

    priorities[i][0] = h[site_nbr][i%N]
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.001061574074074074}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      nns.append(J[j,i//N,nn_site])

    if sum(nns) > 0:
      priorities[i][0] = h_site + max([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([J[0,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0013285493827160497}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[site_nbr][j] for k, j in [(k, (k+i-N)//N) for k in range(4)]])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.05035385802469137}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      priority_total = [1, -1]
    else:
      priority_total = [-1, 1]

    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1

    priorities[i][0] = total_spin + sum([J[k,i%N,j]*h[(k+N-1)%N][i%N] for k in range(4)])
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0010276234567901227}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][0] = h[site_nbr][i%N] + neighbors_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbors_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(4)])
      priorities[i][0] = -h[site_nbr][i%N] - neighbors_sum
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0002492283950617291}
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site's own magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]

  # Calculate interactions with neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] += sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    neighbors = [(k, (k+i-N)//N) for k in range(4)]
    for neighbor in neighbors:
      priorities[i][0] += J[neighbor[0], i%N, i//N]*h[neighbor[1]][i%N]

  # Calculate priority based on total magnetism
  priorities[:,1] = -priorities[:,0]
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.0035387345679012356}
#island_id: 0
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbrs = list(set(site_nbrs))
    h_neighbors = [h[site][i%N] for site in site_nbrs]
    if sum(h_neighbors) > 0:
      priorities[i][0] = np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)])
      priorities[i][1] = -(np.sum([1 if h[j][i%N] > 0 else -1 for j in range(N)]))
    else:
      priorities[i][0] = np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)])
      priorities[i][1] = -(np.sum([-1 if h[j][i%N] > 0 else 1 for j in range(N)]))
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.008169907407407407}
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i // N) % N
    site_nbr_col = i % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr_row_neighbor = (site_nbr_row + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row_neighbor][i%N]
        priorities[i][1] -= h[site_nbr_row_neighbor][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row_neighbor][i%N]
        priorities[i][1] += h[site_nbr_row_neighbor][i%N]
    
    site_nbr_col_neighbor = (site_nbr_col + ((k-1)%2 - 1)) % N
    if J[3,i%N,site_nbr_col_neighbor] > 0:
      priorities[i][0] += h[site_nbr_col_neighbor][i//N]
      priorities[i][1] -= h[site_nbr_col_neighbor][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col_neighbor][i//N]
      priorities[i][1] += h[site_nbr_col_neighbor][i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.007664043209876543}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if site_energy > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.07435570987654325}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    
    if i//N != 0:
      site_energy += J[1, i//N, i//N] * h[(i-1)//N][i%N]
    if i//N < N-1:
      site_energy += J[2, i//N, i//N] * h[(i+1)//N][i%N]
    
    for j in range(N):
      if i%N != 0:
        site_energy += J[3, i//N, i%N] * h[i//N][j]
      if i%N < N-1:
        site_energy += J[3, i//N, (i+1)%N] * h[i//N][(i+1)%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.3439816358024681}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if np.abs(h[i//N][i%N]) > 0.5:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1 if h[i//N][i%N] > 0 else -1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1 if h[i//N][i%N] < 0 else 1

  return(priorities)




#score: {'data2D.txt': 0.007791512345679012}
#island_id: 2
#version_generated: 2
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]

    if i % N > 0:
      total_energy += J[1, site_nbr, i//N] * h[(i-1)//N][(i-1)%N]
    if i % N < N - 1:
      total_energy += J[2, site_nbr, i//N] * h[(i+1)//N][i%N + 1]
    if i // N > 0:
      total_energy += J[3, site_nbr, i//N] * h[(i-1)//N][i%N]
    if i // N < N - 1 and (i % N == 0 or i % N == N - 1):
      total_energy += J[0, site_nbr, i//N] * h[i//N][i%N]

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.008343364197530864}
#island_id: 1
#version_generated: 2
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin + sum(h[j][i%N] for j in range(N) if abs(j-i)%2 == 0)
    priorities[i][1] = -total_spin + sum(h[j][i%N] for j in range(N) if abs(j-i)%2 != 0)
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.003604475308641976}
#island_id: 1
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + (i//N+1)%N) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N]
    
    if i // N < N-1:
      total_spin += J[1,i//N,i%N] * (h[i//N+1][i%N] - h[site_nbr2][i%N])
    if i % N > 0:
      total_spin += J[2,i//N,i%N] * (h[site_nbr1][i%N-1] - h[i//N][i%N])
    
    if i % N < N-1 and i // N < N-1:
      total_spin += J[3,i//N,i%N] * (h[site_nbr3][i%N+1] + h[i//N+1][i%N] - 2*h[site_nbr2][i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17046589506172866}
#island_id: 2
#version_generated: 2
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1

    site_nbr_opp = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr_opp][i%N] > 0:
      priorities[i][0] += J[3, i//N, i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[3, i//N, i//N]

  return(priorities)




#score: {'data2D.txt': 0.3429029320987644}
#island_id: 2
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  return(priorities)




#score: {'data2D.txt': 0.11481929012345692}
#island_id: 2
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        total_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = total_energy
      priorities[i][1] = -1
    
  # add a twist to prioritize sites with no interaction
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0, i//N, i%N] == 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] = -1 if h[i//N][i%N] > 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.3238257716049374}
#island_id: 1
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][i%N] > 0:
        if J[3,i%N,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      else:
        if J[3,i%N,j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.005032253086419754}
#island_id: 1
#version_generated: 2
#generate time13:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for i in range(N**2):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[3,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])

    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  # Add a bias term to the priority based on the current spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.26976095679012313}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N]
    
    # Add interactions with neighboring sites
    if i // N > 0:
      site_energy += J[0, i//N, i//N] * (h[(i//N-1)%N][i%N])
    if i % N > 0:
      site_energy += J[1, i//N, i//N] * (h[i//N][(i+1)%N])
    if i // N < N - 1:
      site_energy += J[2, i//N, i//N] * (h[(i//N+1)%N][i%N])
    if i % N < N - 1 and i // N > 0:
      site_energy += J[3, i//N, i//N] * (h[(i//N-1)%N][(i+1)%N])

    # Adjust energy based on magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.17138996913580273}
#island_id: 2
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])

    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0, site_nbr, i//N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[0, site_nbr, i//N]

  return(priorities)




#score: {'data2D.txt': 0.0034081790123456786}
#island_id: 0
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      J[:,i//N,i%N][J[:,i//N,i%N]>0.5]+=1
      J[:,i//N,i%N][J[:,i//N,i%N]<-0.5]-=1
    else:
      J[:,i//N,i%N][J[:,i//N,i%N]>0.5]-=1
      J[:,i//N,i%N][J[:,i//N,i%N]<-0.5]+=1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

  return(priorities)




#score: {'data2D.txt': -9.799382716049343e-05}
#island_id: 0
#version_generated: 2
#generate time13:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin * (np.sum(J[:,i//N,i%N]) - 2)
      priorities[i][1] -= 2*total_spin
    else:
      priorities[i][0] -= total_spin * (np.sum(J[:,i//N,i%N]) + 2)
      priorities[i][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.021364969135802468}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += (total_energy + nn_energy) / abs(nn_energy)
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= (total_energy - nn_energy) / abs(nn_energy)
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.02459614197530864}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -2.8240740740740123e-05}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] if k==0 else h[(i+(k+1)-1)%N][i%N]) for k in range(-1,2))
    if nn_energy > 0:
      priorities[i][0] += total_energy + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= total_energy - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.0007476851851851852}
#island_id: 0
#version_generated: 2
#generate time13:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if nn_energy > 0:
      priorities[i][0] += 2*total_energy + nn_energy
      priorities[i][1] -= 4
    else:
      priorities[i][0] -= 2*total_energy - nn_energy
      priorities[i][1] += 4
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.08258163580246924}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16431033950617308}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  for i in range(N):
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i,N-1-i] > 0:
      priorities[i*N+i][0] += h[site_nbr][i]
      priorities[i*N+i][1] -= h[site_nbr][i]
    else:
      priorities[i*N+i][0] -= h[site_nbr][i]
      priorities[i*N+i][1] += h[site_nbr][i]
  
  for j in range(N):
    site_nbr = (j % N + ((1-1)%2 - 1)) % N
    if J[1,N-1-j,j] > 0:
      priorities[j*N+j][0] += h[site_nbr][j]
      priorities[j*N+j][1] -= h[site_nbr][j]
    else:
      priorities[j*N+j][0] -= h[site_nbr][j]
      priorities[j*N+j][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.17964212962962964}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      total_spin = h[site_nbr1][i%N]
    else:
      total_spin = -h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      total_spin += h[site_nbr3][i%N]
      total_spin -= h[site_nbr4][i%N]
    else:
      total_spin -= h[site_nbr3][i%N]
      total_spin += h[site_nbr4][i%N]

    if J[1,i//N,i%N] > 0:
      total_spin += h[i//N][i%N]
    else:
      total_spin -= h[i//N][i%N]

    site_nbr5 = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr5][i%N]
    else:
      total_spin -= h[site_nbr5][i%N]

    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Compute interactions with horizontal and vertical neighbors
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.10518256172839513}
#island_id: 3
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) + h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0] - 2*h[site_nbr][i%N]
    else:
      total_spin = sum([h[k][i%N] for k in range(N) if k == i//N or k == (site_nbr+N-1)%N]) - h[site_nbr][i%N]
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0] + 2*h[site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': -0.0011924382716049392}
#island_id: 3
#version_generated: 2
#generate time14:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.06733873456790126}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.006374228395061729}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    total_energy = J[1,i//N,site_nbr] * h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.022201080246913633}
#island_id: 0
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    total_spin = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
        total_spin += (J[j,i//N,nn_site] > 0).astype(int)
      else:
        nn_energy = -h[nn_site][i%N]
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = (total_energy + nn_energy_sum) * total_spin
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.00775817901234568}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if J[0, i//N, i//N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_energy = h[i//N][i%N] * (h[i//N][i%N] if J[0, i//N, i//N] > 0 else -h[i//N][i%N])
    
    for j in range(3):
      if i//N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[2,(i-1)//N,i//N]
      elif i//N == N-1 and (i-N)%N == j:
        site_energy += h[(i-N)//N][j] * J[3,(i-N)//N,i//N]
      elif i%N != 0 and (i-1)%N == j:
        site_energy += h[(i-1)//N][j] * J[1,(i-1)//N,i//N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1

  # Add a bias term to the priority based on the current spin
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.3428674382716039}
#island_id: 2
#version_generated: 2
#generate time14:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        if J[2,(i-1)//N,i//N] > 0:
          total_spin += h[(i-1)//N][j]
        else:
          total_spin -= h[(i-1)//N][j]
      elif i//N == N-1 and (i-N)%N == j:
        if J[3,(i-N)//N,i//N] > 0:
          total_spin += h[(i-N)//N][j]
        else:
          total_spin -= h[(i-N)//N][j]
      elif i%N != 0 and (i-1)%N == j:
        if J[1,(i-1)//N,i//N] > 0:
          total_spin += h[i//N][j]
        else:
          total_spin -= h[i//N][j]
    site_energy = total_spin * (total_spin if J[0, i//N, i%N] > 0 else -total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin including interactions with nearest neighbors
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.2012217592592595}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i // N + ((i % N - 1) % N)) % N
    if h[site_nbr][i%N] * J[3, i%N, i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate interaction with neighboring sites
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # adjust magnetism term based on the sign of h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34217422839506073}
#island_id: 2
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        total_spin += h[(i-1)//N][j] * J[0, i//N, i%N]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin += h[(i-N)//N][j] * J[3, (i-N)//N, i//N]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += h[i//N][j] * J[1, i//N, i%N]
      elif (i+1)%N == j:
        total_spin += h[i//N][j] * J[2, i//N, i%N]
    
    site_energy = total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.3428754629629619}
#island_id: 2
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if i//N != 0 and (i-1)%N == j:
        total_spin += h[(i-1)//N][j] * J[0, (i-1)//N, i%N]
      elif i//N == N-1 and (i-N)%N == j:
        total_spin -= h[(i-N)//N][j] * J[3, (i-N)//N, i%N]
      elif i%N != 0 and (i-1)%N == j:
        total_spin += h[i//N][j] * J[1, i//N, i%N]
    site_energy = total_spin * (total_spin if J[2, i//N, i%N] > 0 else -total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -site_energy
      priorities[i][1] = 1
    else:
      priorities[i][0] = site_energy
      priorities[i][1] = -1
  
  return(priorities)




#score: {'data2D.txt': 0.003758179012345679}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff = total_energy
    for k in [(i-1)%N if i!=0 else N-1,(i+1)%N if i!=(N*N)-1 else 0]:
      site_nbr_k = (k % N + ((k//N-1)%2 - 1)) % N
      energy_diff += sum(J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] if J[j,k//N,(site_nbr_k+(j-1)%2-N)%N]>0 else -J[j,k//N,(site_nbr_k+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr_k][k%N]
    priorities[i][0] = energy_diff
    if sum(J[:,i//N,i%N]) > 0:
      priorities[i][1] -= 2*total_energy
    else:
      priorities[i][1] += 2*total_energy
  return(priorities)




#score: {'data2D.txt': -0.009550771604938271}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] if J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[(j+1)%4,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -6171599491158.986}
#island_id: 0
#version_generated: 2
#generate time14:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    energy_diff = sum(J[j,i//N,(site_nbr+(j-1)%2-N)%N] if J[j,i//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,i//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][i%N]
    energy_diff += sum(J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N] if J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N]>0 else -J[j,((i+N)%N)//N,(site_nbr+(j-1)%2-N)%N] for j in range(4)) * h[site_nbr][((i+N)%N)%N]
    priorities[i][0] = energy_diff
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0016807098765432107}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N]) - 2*sum(h[site_nbr])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N]) + 2*sum(h[site_nbr])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.0012047839506172833}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin if h[i//N][i%N] > 0 else total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin if h[i//N][i%N] < 0 else total_spin
      priorities[i][1] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.14424768518518538}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      spin = 1
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      spin = -1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin * spin
  return(priorities)




#score: {'data2D.txt': -0.0014649691358024689}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + sum(h[:,i%N])
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    # Add the interactions with the next nearest neighbors
    if i % (N*N) < N:
      priorities[i][0] += J[2,i//N,i%N]*h[(i+N-1)%N][i%N]
      priorities[i][1] -= J[2,i//N,i%N]*h[(i+N-1)%N][i%N]
    if i % (N*N) >= N and i % (N*N) < 2*N:
      priorities[i][0] += J[3,(i+N-1)%N,i//N]*h[i%N,(i+N-1)%N]
      priorities[i][1] -= J[3,(i+N-1)%N,i//N]*h[i%N,(i+N-1)%N]
  return(priorities)




#score: {'data2D.txt': 0.002223611111111111}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.09343904320987653}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([J[k,i,j]*h[(k+N-1)%N][j] for k in range(3)]) + total_spin
        priorities[i*N+j][1] = -priorities[i*N+j][0]
      else:
        priorities[i*N+j][0] -= sum([J[k,i,j]*h[(k+N-1)%N][j] for k in range(3)]) - total_spin
        priorities[i*N+j][1] = -priorities[i*N+j][0]
  return(priorities)




#score: {'data2D.txt': -0.052260339506172857}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum(h[k][i%N] for k in range(N))
      priorities[i][0] = sum(J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum(h[k][i%N] for k in range(N))
      priorities[i][0] = sum(J[k,i//N,k]*h[(k+N-1)%N][i%N] for k in range(3)) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.10717700617283961}
#island_id: 3
#version_generated: 2
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = sum(h[site_nbr][j] for j in range(N)) + 1
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      total_spin = sum(h[site_nbr][j] for j in range(N)) - 1
      priorities[i][0] = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + total_spin
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0036063271604938273}
#island_id: 1
#version_generated: 2
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = i//N
    
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in [0, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_sum = 0
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        spin_sum += h[site_nbr][j]
      else:
        spin_sum -= h[site_nbr][j]
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N] + spin_sum
        priorities[i][1] -= h[site_nbr][i%N] - spin_sum
      else:
        priorities[i][0] -= h[site_nbr][i%N] + spin_sum
        priorities[i][1] += h[site_nbr][i%N] - spin_sum
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0012405864197530861}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for l in range(N):
      site_nbr = (i % N + ((l-1)%2 - 1)) % N
      if J[3,i%N,l] > 0:
        priorities[i][0] += h[site_nbr][l]
        priorities[i][1] -= h[site_nbr][l]
      else:
        priorities[i][0] -= h[site_nbr][l]
        priorities[i][1] += h[site_nbr][l]
    
    return(priorities)




#score: {'data2D.txt': -0.08245910493827165}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = total_spin + magnetism
    priorities[i][1] = -total_spin - magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism term
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.16547484567901255}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the spin priority based on local magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority for assigning spins to -1 and 1
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * N + sum(h[j][i%N] for j in range(N))
      priorities[i][1] = -(total_spin * N + sum(h[j][i%N] for j in range(N)))
    else:
      priorities[i][0] = -((total_spin * N) + sum(h[j][i%N] for j in range(N)))
      priorities[i][1] = (total_spin * N + sum(h[j][i%N] for j in range(N)))

  return(priorities)




#score: {'data2D.txt': 0.06338040123456797}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k+2,i%N,i//N] > 0:
       total_spin += h[site_nbr][i%N]
       priorities[i][1] -= h[site_nbr][i%N]
     else:
       total_spin -= h[site_nbr][i%N]
       priorities[i][0] += h[site_nbr][i%N]
    
    for j in range(N):
     site_nbr = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
       total_spin += h[site_nbr][j]
       priorities[i][1] -= h[site_nbr][j]
     else:
       total_spin -= h[site_nbr][j]
       priorities[i][0] += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0006992283950617284}
#island_id: 1
#version_generated: 2
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
 
  # Sort the sites based on the priority
  indices = np.argsort(priorities[:,0])
  priorities = priorities[indices]
 
  return(priorities)




#score: {'data2D.txt': 0.019974537037037034}
#island_id: 0
#version_generated: 2
#generate time14:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)])
      priorities[i][1] = -priorities[i][0]

  # Check if the spin assignment is valid
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      if sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) > 0:
        priorities[i] = -priorities[i]
    else:
      if sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) < 0:
        priorities[i] = -priorities[i]

  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add site-specific contributions to priorities
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.005700462962962963}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
    priorities[i] = [total_spin, -total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 1
#version_generated: 2
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = []
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs.append((site_nbr, h[site_nbr][i%N]))
    if sum(1 for _, val in site_nbrs) > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1645208333333336}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N-2)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i//N]
      priorities[i][1] -= h[site_nbr_row][i//N]
    else:
      priorities[i][0] -= h[site_nbr_row][i//N]
      priorities[i][1] += h[site_nbr_row][i//N]
    
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i%N]
      priorities[i][1] -= h[site_nbr_col][i%N]
    else:
      priorities[i][0] -= h[site_nbr_col][i%N]
      priorities[i][1] += h[site_nbr_col][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1653785493827163}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism at site
    total_spin += h[i//N][i%N]
    
    # Add nearest neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add next-nearest neighbor interactions (if applicable)
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr][i%N]
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      total_spin -= h[site_nbr][i%N]
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16521435185185204}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with nearest neighbors
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,(i+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i+N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Assign priorities based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.08344675925925932}
#island_id: 1
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin + sum(h[site_nbr])
    priorities[i][1] = -total_spin + sum(-h[site_nbr])
  return(priorities)




#score: {'data2D.txt': 0.0004427469135802473}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if i//N == (k+N-1)%N and (i%N+k+2)%4==1:
        h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      elif i//N == (k+N-1)%N and (i%N+k+2)%4==3:
        h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0010192901234567897}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0012569444444444444}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.001565895061728395}
#island_id: 3
#version_generated: 2
#generate time14:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    row, col = divmod(i, N)
    for k in range(3):
      if k == 1 and (col+1)%N == N: # wraparound
        k = 0
      elif k == 2 and (col-1)%N == -1: 
        k = 1
      if J[k,i%N,i//N]*h[(k+N-1)%N][i%N] > 0:
        h_site += J[k,i%N,i//N]
      else:
        h_site -= J[k,i%N,i//N]

    if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    total_spin = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + total_spin
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - total_spin
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.002374845679012345}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.01128533950617284}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-N_half)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1
    
    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N < N_half:
        if j%2 == 0:
          nns.append(h[nn_site][i%N])
        else:
          nns.append(-h[nn_site][i%N])
      else:
        if j%2 == 0:
          nns.append(-h[nn_site][i%N])
        else:
          nns.append(h[nn_site][i%N])
    
    J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]
    
    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.012395524691358023}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      if j == 0:
        nn_site = (site_nbr + ((i//N-1)%2 - 1)) % N
      elif j == 1:
        nn_site = (site_nbr + ((i//N)%2 - 1)) % N
      elif j == 2:
        nn_site = (site_nbr + ((i//N+1)%N)) % N
      else:
        nn_site = (site_nbr + (((i//N)-1)%2 - 1)) % N

      nn_sites.append(h[nn_site][i%N])

    if h[i//N][i%N] > 0:
      J_up = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) + J[1,i//N,i//N]
      J_down = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) - J[1,i//N,i//N]
    else:
      J_up = -np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) + J[1,i//N,i//N]
      J_down = np.sum([J[k,i%N,i//N]*n for k,n in zip(range(4),nn_sites)]) - J[1,i//N,i//N]

    if h_site > 0:
      priorities[i][0] = (J_up - J_down)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(J_up - J_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0015705246913580244}
#island_id: 0
#version_generated: 2
#generate time14:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      nns.append(h[nn_site][i%N])

    J_up = np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) + J[1,i//N,i//N]
    J_down = -np.sum([J[k,i//N,i//N]*n for k,n in zip(range(3),nns)]) - J[1,i//N,i//N]

    priorities[i][0] = h_site * (J_up - J_down)
    priorities[i][1] = -(priorities[i][0])

  return(priorities)




#score: {'data2D.txt': -0.0090125}
#island_id: 0
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      h_site = 1
    else:
      h_site = -1

    nn_sites = []
    for j in range(4):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(i%N - nn_site %N) < 2:
        nn_sites.append(J[abs(i%N - nn_site %N),i//N,nn_site//N] * h_site)
    priorities[i][0] = np.sum(nn_sites) + h_site
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.0009686728395061732}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    flip = 0 if sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) < h_site else 1
    priorities[i][flip] += J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
  return(priorities)




#score: {'data2D.txt': -0.005630401234567902}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.0002334876543209875}
#island_id: 3
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      if left_nbr != i and J[0,left_nbr%N,top_nbr%N] > 0:
        priorities[i][0] += J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
      if right_nbr != i and J[0,right_nbr%N,top_nbr%N] > 0:
        priorities[i][0] -= J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
    else:
      priorities[i][0] = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      if left_nbr != i and J[0,left_nbr%N,top_nbr%N] > 0:
        priorities[i][0] -= J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]
      if right_nbr != i and J[0,right_nbr%N,top_nbr%N] > 0:
        priorities[i][0] += J[1,top_nbr//N,i//N]*h[top_nbr//N][i%N]

    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002374845679012345}
#island_id: 2
#version_generated: 2
#generate time14:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0038486111111111117}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    h_site = h[site_nbr][i%N]
    
    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    # Introduce a small noise term to avoid getting stuck in local minima
    noise = 0.01 * np.random.rand()

    priorities[i][0] = np.exp(-diff + noise)
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.11235972222222222}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin)
      priority_down = 1 - priority_up
    else:
      priority_up = 1 - np.exp(-total_spin)
      priority_down = priority_up

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': -0.001977623456790124}
#island_id: 2
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    # Calculate the priority for each spin state based on interactions and magnetism
    p_up = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    p_down = -h_site - sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])

    # Calculate the priority difference to favor the spin state with lower energy
    diff = p_up - p_down

    priorities[i][0] = np.exp(-diff) / (np.exp(-p_up) + np.exp(-p_down))
    priorities[i][1] = 1 - priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0023819444444444417}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    if i < N*N/2:
      priorities[i][1] = -priority_sum
    else:
      priorities[i][0] = -priority_sum
  
  return(priorities)




#score: {'data2D.txt': -0.20788441358024695}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
        
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    total_energy = h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.03339521604938272}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]
      
      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]
    
    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        else:
          priorities[i][0] -= 1
    else:
      for j in range(3):
        nn_site = (site_nbr + ((j-1)%2 - 1)) % N
        
        if J[j,i//N,nn_site] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        else:
          priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.06614212962962965}
#island_id: 0
#version_generated: 2
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    nn_energy_sum = 0
    nn_count = 0
    
    for j in range(4):  # include the diagonal neighbor as well
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nn_energy_sum += nn_energy
      nn_count += (J[j,i//N,nn_site] > 0).astype(int)
    
    if J[1,i//N,site_nbr] > 0:
      total_energy = h[i//N][i%N]
    else:
      total_energy = -h[i//N][i%N]

    priority_sum = nn_energy_sum * nn_count + total_energy
    
    priorities[i][0] = priority_sum
    priorities[i][1] = -priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time14:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11501373456790137}
#island_id: 1
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Compute the contribution from nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add the contributions from all sites
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    # Apply the magnetism term
    total_spin *= np.sign(h[i//N][i%N])
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0014819444444444444}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h[site_nbr][i%N] + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h[site_nbr][i%N] - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.02224891975308642}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_site_1 = (site_nbr + ((2-1)%2 - 1)) % N
    if J[1,i//N,nn_site_1] > 0:
      nn_energy_1 = h[nn_site_1][i%N]
    else:
      nn_energy_1 = -h[nn_site_1][i%N]

    nn_site_2 = (site_nbr + ((3-1)%2 - 1)) % N
    if J[2,i//N,nn_site_2] > 0:
      nn_energy_2 = h[nn_site_2][i%N]
    else:
      nn_energy_2 = -h[nn_site_2][i%N]

    total_energy = (h[i//N][i%N] + nn_energy_1 + nn_energy_2) * h_site
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.005777006172839506}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy_sum = sum([J[j,i//N,site_nbr] * h[(site_nbr + j)%N][i%N] for j in range(4)])
    
    if J[0,i//N,site_nbr] > 0:
      priorities[i][0] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = h[site_nbr][i%N]

    priorities[i][1] = -priorities[i][0] + nn_energy_sum

  return(priorities)




#score: {'data2D.txt': 0.030788425925925927}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    if total_energy > 0:
      priorities[i][0] = h_site + total_energy
      priorities[i][1] = -priorities[i][0]
    elif total_energy < 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      if np.random.rand() > 0.5:
        priorities[i][0] = h_site + total_energy
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = h_site
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nns = []
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if J[j,i//N,nn_site] > 0:
        nn_energy = h[nn_site][i%N]
      else:
        nn_energy = -h[nn_site][i%N]

      nns.append(nn_energy)

    total_energy = sum(nns) * h[i//N][i%N]
    if J[1,i//N,site_nbr] > 0:
      total_energy += h[i//N][i%N]
    else:
      total_energy -= h[i//N][i%N]

    priorities[i][0] = -np.exp(h_site + total_energy)
    priorities[i][1] = np.exp(-h_site - total_energy)

  return(priorities)




#score: {'data2D.txt': 0.11235972222222222}
#island_id: 2
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.exp(total_spin_up)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - np.exp(-total_spin_down)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin)
      priority_down = 1 / (np.exp(-total_spin) + 1)
    else:
      priority_up = 1 / (np.exp(total_spin) + 1)
      priority_down = np.exp(-total_spin)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.0291195987654321}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]

    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      for k in range(4):
        if k==3:
          continue
        neighbor = (site_nbr + ((k-1)%2 - 1)) % N
        if i//N == neighbor // N and abs(neighbor % N - site_nbr % N) > 0:
          neighbor = (neighbor + ((k-1)%2 - 1)) % N
        priority_total[0] += J[k,i//N,nn_site]
        priority_total[1] -= J[k,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]

  return(priorities)




#score: {'data2D.txt': 0.07557268518518517}
#island_id: 0
#version_generated: 2
#generate time14:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [h[site_nbr][i%N], 1]
    else:
      priority_total = [-h[site_nbr][i%N], -1]
      
    for j in range(3):
      nn_site = (site_nbr + ((j-1)%2 - 1)) % N
      if i//N == nn_site // N and abs(nn_site % N - site_nbr % N) > 0:
        nn_site = (nn_site + ((j-1)%2 - 1)) % N
      priority_total[0] += J[j,i//N,nn_site]
      priority_total[1] -= J[j,i//N,nn_site]

    priorities[i][0] = priority_total[0]
    priorities[i][1] = -priority_total[0]
    
  return(priorities)




#score: {'data2D.txt': 0.018646759259259262}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] < 0:
        priorities[i][0] -= J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] < 0:
        priorities[i][0] -= J[1, i//N, i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      if i % N > 0 and J[2, i//N, i%N] * h[(i+1)%N][i%N] > 0:
        priorities[i][0] += J[2, i//N, i%N]
      if i % N < N-1 and J[1, i//N, i%N] * h[(i-1)%N][i%N] > 0:
        priorities[i][0] += J[1, i//N, i%N]
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[site_nbr][i%N] for k in range(3))
    priorities[i][0] += h[site_nbr][i%N] + nn_energy
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= 2
    else:
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': -0.0055526234567901235}
#island_id: 0
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += (h[site_nbr][i%N] + nn_energy) / 2
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= (h[site_nbr][i%N] - nn_energy) / 2
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -6.219135802469178e-05}
#island_id: 2
#version_generated: 2
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': 0.11411743827160509}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate the influence from four nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # adjust the spin based on local magnetism and nearest neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.006468364197530864}
#island_id: 1
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_contributions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        neighbor_contributions -= 2
      else:
        total_spin -= 1
        neighbor_contributions += 2
    priorities[i][0] = -total_spin + neighbor_contributions/2
    priorities[i][1] = total_spin + neighbor_contributions/2
  return(priorities)




#score: {'data2D.txt': 0.06266064814814815}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.014498611111111113}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N]
    for j in range(4):
      if J[j,i//N,i%N] > 0:
        total_energy += 2*J[j,i//N,i%N]*h[(i+j-3)%N][i%N]
      else:
        total_energy -= 2*J[j,i//N,i%N]*h[(i+j-3)%N][i%N]
    priorities[i][0] = total_energy
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0788337962962963}
#island_id: 0
#version_generated: 2
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': -0.002082561728395062}
#island_id: 0
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin

    # Add interaction with next nearest neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += np.sum(J[:,i//N,site])
        priorities[i][1] -= 2*np.sum(J[:,i//N,site])
      else:
        priorities[i][0] -= np.sum(J[:,i//N,site])
        priorities[i][1] += 2*np.sum(J[:,i//N,site])

  return(priorities)




#score: {'data2D.txt': 0.1613686728395064}
#island_id: 1
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,N-1] > 0:
      priorities[i][0] += h[site_nbr][N-1]
      priorities[i][1] -= h[site_nbr][N-1]
    else:
      priorities[i][0] -= h[site_nbr][N-1]
      priorities[i][1] += h[site_nbr][N-1]
    
  return(priorities)




#score: {'data2D.txt': 0.11584243827160508}
#island_id: 1
#version_generated: 2
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr2][j]
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        total_spin -= h[site_nbr2][j]
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0036038580246913585}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum of interactions from left and right neighbors
    total_spin += sum(J[0,i//N,(i%N)+j] for j in range(-1,2) if 0 <= i%N+j < N)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.06103503086419755}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = 1
      for k in range(4):
        if J[k,i//N,i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    else:
      total_spin = -1
      for k in range(4):
        if J[k,i//N,i%N] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0021887345679012346}
#island_id: 1
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       priorities[i][0] += h[site_nbr1][i%N]
       priorities[i][1] -= h[site_nbr1][i%N]
     else:
       priorities[i][0] -= h[site_nbr1][i%N]
       priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.16616836419753087}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

    # Add the bias term
    if J[1,i//N,site_nbr] > 0:
      priorities[i][0] += h_site + max([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] -= h_site - min([J[k, i//N, site_nbr] for k in range(4)])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0015828703703703701}
#island_id: 0
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    nn_sites = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    nn_spins = [J[j,i//N,nn_site] for j,nn_site in zip(range(4),nn_sites)]

    if sum(nn_spins) > 0:
      priorities[i][0] = h_site + max([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - min([n for n in nn_spins])
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.004227314814814815}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[site_nbr][k] for k in range(3)])
    priorities[i][0] = h[site_nbr][i%N] + neighbor_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0009560185185185193}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    priorities[i][0] = h_site + 2*neighbor_sum
    priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0023470679012345683}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = 2*h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.0002837962962962961}
#island_id: 3
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
      if i//N == (k+N-1)%N and (i%N+k+2)%4==1:
        h_site += J[k,i%N,i//N]*h[(k+N-1)%N][i%N]
      elif i//N == (k+N-1)%N and (i%N+k+2)%4==3:
        h_site -= J[k,i%N,i//N]*h[(k+N-1)%N][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site + sum(J[k, i%N, (i//N+k+2)%4] for k in range(3))
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum(J[k, i%N, (i//N+k+2)%4] for k in range(3))
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0007035493827160492}
#island_id: 3
#version_generated: 2
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    for k in range(3):
     site = (i + ((k-1)%2 - 1)) % N
     if i//N == (site+N-1)%N and (i%N+k+2)%4==1:
      h_site += J[k,i%N,i//N]*h[site][i%N]
     elif i//N == (site+N-1)%N and (i%N+k+2)%4==3:
      h_site -= J[k,i%N,i//N]*h[site][i%N]

    if h[i//N][i%N] > 0:
      priorities[i][0] = h_site
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.07523533950617285}
#island_id: 2
#version_generated: 2
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up

    if h[site_nbr][i%N] > 0:
      priorities[i][0] = np.exp(total_spin_up)
      priorities[i][1] = 1 / (1 + np.exp(-total_spin_down))
    else:
      priorities[i][0] = 1 / (1 + np.exp(total_spin_up))
      priorities[i][1] = np.exp(total_spin_down)

  return(priorities)




#score: {'data2D.txt': -0.3281248456790114}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0012566358024691366}
#island_id: 1
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
      
  return(priorities)




#score: {'data2D.txt': 0.0012813271604938282}
#island_id: 3
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    priorities[i][0] = h_site + sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
    priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': 0.0005708333333333331}
#island_id: 3
#version_generated: 2
#generate time14:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -h[site_nbr][i%N]
    else:
      priorities[i][0] = -h[site_nbr][i%N]
      priorities[i][1] = h[site_nbr][i%N]
    
    if i > 0:
      prev_site = (i-1) % N
      if J[2,i//N,prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]
    
    if i < N*N-1:
      next_site = (i+1) % N
      if J[3,i//N,next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]
  
  if h.sum() > 0:
    return -priorities
  else:
    return priorities




#score: {'data2D.txt': -0.006602623456790123}
#island_id: 3
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    if J[0,i//N,i%N] > 0:
      priorities[i][0] = h_site + sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -h_site - sum([J[k,i//N,i%N]*h[(k+N-1)%N][i%N] for k in range(3)]) + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

    if i > 0:
      prev_site = (i-1) % N
      if h[i//N][prev_site] > 0:
        priorities[i][0] -= J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] += J[2,i//N,prev_site]*h[i//N][prev_site]
      else:
        priorities[i][0] += J[2,i//N,prev_site]*h[i//N][prev_site]
        priorities[i][1] -= J[2,i//N,prev_site]*h[i//N][prev_site]

    if i < N*N-1:
      next_site = (i+1) % N
      if h[i//N][next_site] > 0:
        priorities[i][0] -= J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] += J[3,i//N,next_site]*h[i//N][next_site]
      else:
        priorities[i][0] += J[3,i//N,next_site]*h[i//N][next_site]
        priorities[i][1] -= J[3,i//N,next_site]*h[i//N][next_site]

  return(priorities)




#score: {'data2D.txt': -0.0045875}
#island_id: 3
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    left_nbr = (i-1) % (N*N)
    right_nbr = (i+1) % (N*N)
    top_nbr = i-N
    bot_nbr = i+N

    total_spin = 0
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if J[0,i//N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]

    if J[0,i%N,i//N] > 0:
      priorities[i][0] = total_spin + h_site - J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin - h_site + J[1,i//N,top_nbr%N]*h[top_nbr//N][top_nbr%N]
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.02333070987654321}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin_up)
      priority_down = 1 / (1 + np.exp(total_spin_down))
    else:
      priority_up = 1 / (1 + np.exp(-total_spin_up))
      priority_down = np.exp(total_spin_down)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    
    # Calculate the interaction energy with neighbors
    for k in range(-1, 2):
      if k == 0:
        continue
      x = (i + k) % N
      y = i // N
      total_spin += J[k, y, i%N] * h[x][y]
    
    # Update the magnetism at each site based on the interaction energy
    if total_spin > 0:
      priorities[i][0] = np.exp(total_spin)
      priorities[i][1] = 1 - priorities[i][0]
    else:
      priorities[i][0] = 1 - np.exp(-total_spin)
      priorities[i][1] = priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.018206944444444442}
#island_id: 2
#version_generated: 2
#generate time14:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin_up = np.sum(J[:,i//N,i%N])*h[site_nbr][i%N]
    total_spin_down = -total_spin_up
    if h[site_nbr][i%N] > 0:
      priority_up = np.exp(total_spin_up)
      priority_down = np.exp(total_spin_down) / (1 + np.exp(total_spin_up))
    else:
      priority_up = 1 / (1 + np.exp(-total_spin_up))
      priority_down = np.exp(total_spin_down)

    priorities[i][0] = priority_up
    priorities[i][1] = priority_down

  return(priorities)




#score: {'data2D.txt': 0.09301496913580247}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
      elif h[site_nbr][i%N] < 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        elif sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) < 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
  return(priorities)




#score: {'data2D.txt': 0.07749367283950617}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = 1
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = -1
    else:
      site_energy = h[site_nbr][i%N]
      if sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3)) > 0:
        if site_energy > 0:
          priorities[i][0] = -1
          priorities[i][1] = 1
        else:
          priorities[i][0] = 1
          priorities[i][1] = -1
      else:
        if site_energy > 0:
          priorities[i][0] = 1
          priorities[i][1] = -1
        else:
          priorities[i][0] = -1
          priorities[i][1] = 1
  return(priorities)




#score: {'data2D.txt': 0.08017731481481483}
#island_id: 0
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_energy = h[site_nbr][i%N] + sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if total_energy > 0:
      priorities[i][0] = -1
      priorities[i][1] = np.exp(-total_energy)
    elif total_energy < 0:
      priorities[i][0] = 1
      priorities[i][1] = np.exp(total_energy)
    else:
      priorities[i][0] = np.random.choice([-1, 1])
      priorities[i][1] = -priorities[i][0]
  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0010378086419753096}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      if i % (N*N) < N*(N-1):
        priorities[i][0] = h_site + 2*neighbor_sum
        priorities[i][1] = -priorities[i][0]
      else:
        priorities[i][0] = neighbor_sum
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.00853533950617284}
#island_id: 2
#version_generated: 2
#generate time14:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    
    if i < N*(N-1):
      priorities[i][0] = h[site_nbr][i%N]
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      
      if neighbor_sum > 0:
        priorities[i][0] = 2
        priorities[i][1] = 0
      elif neighbor_sum < 0:
        priorities[i][0] = 0
        priorities[i][1] = 2
      else:
        priorities[i][0] = h[site_nbr][i%N]
        priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.0055526234567901235}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.024727314814814817}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy - J[1, i//N, i%N]
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy + J[1, i//N, i%N]
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.00870848765432099}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 2*h[site_nbr][i%N] + nn_energy
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 2*h[site_nbr][i%N] - nn_energy
      priorities[i][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.017414969135802472}
#island_id: 0
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    nn_energy = sum(J[k,i//N,i%N] * h[(i+k-1)%N][i%N] for k in range(3))
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N] + nn_energy
      priorities[i][0] -= sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
    else:
      priorities[i][0] -= h[site_nbr][i%N] - nn_energy
      priorities[i][0] += sum(J[k,i//N,i%N] * (h[(i+k-1)%N][i%N] - h[site_nbr][i%N]) for k in range(3))
    priorities[i][1] -= 1 if h[site_nbr][i%N] > 0 else 1
  return(priorities)




#score: {'data2D.txt': 0.0005276234567901242}
#island_id: 2
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      neighbor_sum += sum([J[1,k,i%N]*h[k][i%N] for k in range(N)])
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': 0.0011365740740740748}
#island_id: 2
#version_generated: 2
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      if J[1,i//N,i%N] > 0:
        neighbor_sum += J[1,i//N,i%N]*h[site_nbr][i%N]
      else:
        neighbor_sum -= J[1,i//N,i%N]*h[site_nbr][i%N]

      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
      
  return(priorities)




#score: {'data2D.txt': 0.0006683641975308652}
#island_id: 2
#version_generated: 2
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      h_site = h[site_nbr][i%N]
    else:
      h_site = -h[site_nbr][i%N]

    neighbor_sum = sum([J[k,i%N,i//N]*h[(k+N-1)%N][i%N] for k in range(3)])
    if i % (N*N) < N*(N-1):
      priorities[i][0] = h_site + 2*neighbor_sum
      priorities[i][1] = -priorities[i][0]
    else:
      total_sum = h_site + neighbor_sum
      if J[1,i//N,i%N] > 0:
        total_sum += 2*h[site_nbr][i%N]
      else:
        total_sum -= 2*h[site_nbr][i%N]

      priorities[i][0] = total_sum
      priorities[i][1] = -priorities[i][0]

  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




