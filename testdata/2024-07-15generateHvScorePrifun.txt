#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N,N,2))
  priority_total=np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j]>0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.002499228395061728}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  total_spin = np.zeros((N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
  return total_spin.reshape(N**2, 2)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
      
  for i in range(N**2):
    site = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      priority_total = np.zeros((N**2, 2))
      for k in range(N**2):
        site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
        if h[site_nbr][k%N] > 0:
          priority_total[k][0] += 1
          priority_total[k][1] -= 1
        else:
          priority_total[k][0] -= 1
      return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.28881250000000014}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in range(4):
        site = (site_nbr + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N,2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.0013600308641975305}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N**2):
    site = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      for k in range(N**2):
        site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
        if h[site_nbr][k%N] > 0:
          total_spin[i][0] += 1
          total_spin[i][1] -= 1
        else:
          total_spin[i][0] -= 1
      return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N,i%N][0] += 1
      total_spin[i//N,i%N][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  return(priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  priority_total = np.zeros((N*N, 2))

  # Calculate site magnetism and update priorities
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  # Calculate interaction priorities
  for k in range(N**2):
    i = k // N
    j = k % N
    site_nbr = (i + ((j-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N,2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  site_neighbor = (np.arange(N) + ((np.arange(N)-1)%2 - 1)) % N
  for i in range(N):
    for j in range(N):
      total_spin[i][j][0] += h[site_neighbor[i]][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N, 2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.13068348765432103}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape(4, N**2)
  h = h.flatten()
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      if J[k][i] > 0:
        total_spin[i][0] += h[site_nbr]
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= h[site_nbr]
        total_spin[i][1] += 1
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': 0.028777623456790125}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += J[k][i]
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= J[k][i]
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][(i % N)]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  for i in range(N**2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][(i % N)] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin.tolist()




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 1
      else:
        priority_total[i*N+j][0] += 1
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i] > 0:
        total_spin[i][j][0] += 1
      else:
        total_spin[i][j][0] -= 1
      k += 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.002499228395061728}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.003224537037037036}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.0011248456790123459}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][0] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.29886373456790055}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for k in range(N**2):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site][k%N] > 0:
      total_spin[k][0] += 1
      total_spin[k][1] -= 1
    else:
      total_spin[k][0] -= 1
  return total_spin.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += total_spin[site_nbr][j][0]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return [list(t) for t in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total = np.zeros((N**2,2))
        for i in range(N**2):
          site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
          if h[site_nbr][i%N] > 0:
            priority_total[i][0] += 1
            priority_total[i][1] -= 1
          else:
            priority_total[i][0] -= 1
        return priority_total




#score: {'data2D.txt': -0.11005077160493826}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0][site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.2242328703703704}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if J[0][site_nbr][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
    
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
      else:
        priority_total[i * N + j][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.052889351851851854}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(3):
        if J[k][site_nbr][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] += total_spin
      priority_total[i*N+j][1] -= total_spin
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.00016404320987654299}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
        
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for k in range(N**2):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    total_spin = h[site][k%N]
    if h[site][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total.tolist()




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
      else:
        total_spin[i*N+j][0] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] -= 1
        else:
          priority_total[i*N+j][0] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
      else:
        total_spin[i][j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N, 2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      total_spin[k][0] += 1
      total_spin[k][1] -= 1
    else:
      total_spin[k][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      total_spin[k][0] += 1
      total_spin[k][1] -= 1
    else:
      total_spin[k][0] -= 1
      total_spin[k][1] += 1
  return total_spin




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.018216203703703707}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4,N*N))
  total_spin = [[0,0] for _ in range(N*N)]
  
  # calculate magnetism contribution
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  # calculate interaction contribution
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[0][i]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= J[0][i]
      total_spin[i][1] += 1
    
    site_nbr = (site_nbr + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[1][i]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= J[1][i]
      total_spin[i][1] += 1
    
    site_nbr = (site_nbr + ((i%N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[2][i]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= J[2][i]
      total_spin[i][1] += 1
    
    site_nbr = (site_nbr + ((i%N+1)%N - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[3][i]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= J[3][i]
      total_spin[i][1] += 1
  
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.00027731481481481574}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  priority_list = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    sum_h = sum(h[site_nbr][j] for j in range(N))
    sum_J = sum(J[k][i] for k in range(4) if k%2 == (i//N+1)%2)
    priority_list[i][0] += sum_h + sum_J
    if sum_h > 0:
      priority_list[i][1] -= 1
    else:
      priority_list[i][1] += 1
  return([list(t) for t in priority_list])




#score: {'data2D.txt': -0.009445216049382716}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if k == 0:
        site = (i + ((k-1)%2 - 1)) % N
      else:
        site = (i + ((k%2 - 1) * N + (k//2 - 1))) % N
      total_spin[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = -total_spin[0]
  return priority_total




#score: {'data2D.txt': -4.475308641975595e-06}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.002499228395061728}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.14237824074074076}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k][site_nbr][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] = total_spin
      priority_total[i*N+j][1] = -total_spin
  
  return priority_total




#score: {'data2D.txt': 0.06255447530864197}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_list = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0][site_nbr][j] > 0:
        priority_list[i*N+j][0] += 1
        priority_list[i*N+j][1] -= 1
      elif J[0][site_nbr][j] < 0:
        priority_list[i*N+j][0] -= 1
        priority_list[i*N+j][1] += 1
      
      if J[1][i][j] > 0:
        priority_list[i*N+j][0] += 1
        priority_list[i*N+j][1] -= 1
      elif J[1][i][j] < 0:
        priority_list[i*N+j][0] -= 1
        priority_list[i*N+j][1] += 1
      
      if J[2][site_nbr][j] > 0:
        priority_list[i*N+j][0] += 1
        priority_list[i*N+j][1] -= 1
      elif J[2][site_nbr][j] < 0:
        priority_list[i*N+j][0] -= 1
        priority_list[i*N+j][1] += 1
      
      if J[3][i][j] > 0:
        priority_list[i*N+j][0] += 1
        priority_list[i*N+j][1] -= 1
      elif J[3][i][j] < 0:
        priority_list[i*N+j][0] -= 1
        priority_list[i*N+j][1] += 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_list[i][0] += 1
      priority_list[i][1] -= 1
    else:
      priority_list[i][0] -= 1
  
  return priority_list




#score: {'data2D.txt': -0.0323523148148149}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  
  return total_spin.tolist()




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for k in range(N**2):
    i = k // N
    j = k % N
    site_nbr = (i + ((j-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin[k][0] += 1
      total_spin[k][1] -= 1
    else:
      total_spin[k][0] -= 1
  
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return priority_total.tolist()




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if total_spin > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.18973935185185203}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.17669799382716048}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_magnetism = sum(h[site_nbr][j] for j in range(N))
    for k in range(3):
      if J[k][i] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    priorities[i][0] += total_magnetism
  return([list(t) for t in priorities])




#score: {'data2D.txt': 0.028777623456790125}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += J[k][i]
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= J[k][i]
        total_spin[i][1] += 1
  return([list(t) for t in total_spin])




#score: {'data2D.txt': 0.0718192901234568}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4,N*N))
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += J[k][i]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[k][i]
        priorities[i][1] += 1
  return([list(t) for t in priorities])




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
  priority_total = np.zeros((N*N,2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] -= 1
        else:
          priority_total[i*N+j][0] += 1
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N, 2))
  for k in range(N**2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.010439351851851849}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbrs = []
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbrs.append((site_nbr, i))
  priorities = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    for k in range(4):
      if k == 0:
        site = site_nbrs[i][0]
      else:
        site = (i + ((k%2 - 1) * N + (k//2 - 1))) % N
      priorities[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        priorities[i][1] -= 1
      else:
        priorities[i][1] += 1
  return([list(t) for t in priorities])




#score: {'data2D.txt': -0.009445216049382716}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,-N**2//2] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0,0]
    for k in range(4):
      if k == 0:
        site = (i + ((k-1)%2 - 1)) % N
      else:
        site = (i + ((k%2 - 1) * N + (k//2 - 1))) % N
      total_spin[0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
    for j in range(2):
      priority_total[i][j] = total_spin[j]
  return([list(t) for t in priority_total])




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
  return total_spin




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [list(t) for t in total_spin]




#score: {'data2D.txt': -0.004077932098765432}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]
  priorities = [[0,0] for _ in range(N2)]
  J = J.reshape((4,N2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += J[k][i]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[k][i]
        priorities[i][1] += 1
  
  return([list(t) for t in priorities])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      priority_total[i*N+j][0] += total_spin[0]
      priority_total[i*N+j][1] += total_spin[1]
  return priority_total




#score: {'data2D.txt': -0.08853009259259258}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      priority_total[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        priority_total[i][1] -= 1
      else:
        priority_total[i][1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priority_total[i][0] -= J[k][i]
        priority_total[i][1] += 1
      else:
        priority_total[i][0] += J[k][i]
        priority_total[i][1] -= 1
  return([list(t) for t in priority_total])




#score: {'data2D.txt': -0.010692746913580247}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4,N*N))
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
      
      site_nbr = (i + ((k-1)%2 - 1)) % N
      priority_total[i][0] += J[k][site_nbr*N+i%N]
      if h[site][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
  
  return([list(t) for t in priority_total])




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  J = J.reshape((4, N*N))
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    for k in range(4):
      if J[k][i] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return [[t[0], -t[1]] for t in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i][j][0] -= 1
    else:
      total_spin[i][j][0] += 1

  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        if k == 0:
          total_spin[i*N+j][0] += h[site_nbr][j]
        elif k == 1:
          if h[i][j] > 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
        else:
          site = (i + ((k-1)%2 - 1)) % N
          if h[site][j] > 0:
            total_spin[i*N+j][0] += 1
          else:
            total_spin[i*N+j][0] -= 1

  return total_spin




#score: {'data2D.txt': -0.08480416666666668}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        if J[k][site_nbr][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j][0] += sum([a for a in h[site_nbr]]) + total_spin[0]
      if sum(h[site_nbr]) > 0:
        priority_total[i*N+j][1] -= 1 - total_spin[1]
      else:
        priority_total[i*N+j][1] += 1 - total_spin[1]

  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def energy(spin_config):
    total_energy = 0
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        interaction_energy = J[site_nbr][i*N+j]
        if spin_config[i*N+j] == 1:
          total_energy += h[site_nbr][j] + interaction_energy
        else:
          total_energy -= h[site_nbr][j] - interaction_energy
    return total_energy

  def priority_func(spin_config):
    spin_config = np.array(spin_config).reshape(N, N)
    energy_val = energy(spin_config.flatten())
    if spin_config.sum() > 0:
      return [-x for x in energy_val]
    else:
      return [x for x in energy_val]

  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
     site_nbr = (i + ((j-1)%2 - 1)) % N
     total_spin[i*N+j][0] += h[site_nbr][j]
     if h[i][j] > 0:
      total_spin[i*N+j][1] -= 1
     else:
      total_spin[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]

  spin_config = np.random.randint(2, size=(N,N))
  res = minimize(priority_func, spin_config.flatten(), method='SLSQP')
  return [[-1 if x < 0 else 1 for x in row] for row in res.x.reshape(N, N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = -total_spin[1]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.180304475308642}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i*N+j][0] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
        if J[k,i,j] > 0:
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  site_nbr_indices = {(i+N*j): (i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)}
  for i in range(N**2):
    total_spin = h[site_nbr_indices[i%N]][i//N]
    if total_spin > 0:
      priorities[i][0] += -1
      priorities[i][1] -= 1
    else:
      priorities[i][0] += 1
      priorities[i][1] += 1
  for i in range(N**2):
    site = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.04599490740740741}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  site_nbr = np.zeros((N*N,2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr[i*N+j][0] = (i + ((j-1)%2 - 1)) % N
      site_nbr[i*N+j][1] = i
  for i in range(N**2):
    site_nbr[i][0], site_nbr[i][1] = site_nbr[i][1], site_nbr[site_nbr[i][0]*N+int(i/N)][0]
  for i in range(N**2):
    total_spin[site_nbr[i][1]][site_nbr[i][0]][0] += h[site_nbr[i][1]][site_nbr[i][0]]
    if h[site_nbr[i][1]][site_nbr[i][0]] > 0:
      total_spin[site_nbr[i][1]][site_nbr[i][0]][1] -= 1
    else:
      total_spin[site_nbr[i][1]][site_nbr[i][0]][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N][i%N][0] += 1
      total_spin[i//N][i%N][1] -= 1
    else:
      total_spin[i//N][i%N][0] -= 1
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      priorities[i*N+j][0] += -0.5*J[0,i,j]*total_spin[i][j][0]
      priorities[i*N+j][1] -= total_spin[i][j][1]
      if J[1,i,j] > 0:
        priorities[i*N+j][0] -= 1
      else:
        priorities[i*N+j][0] += 1
      priorities[i*N+j][1] += -0.5*J[2,i,j]*total_spin[i][j][0]
      priorities[i*N+j][1] -= total_spin[i][j][1]
      if J[3,i,j] > 0:
        priorities[i*N+j][0] -= 1
      else:
        priorities[i*N+j][0] += 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
    else:
      total_spin[i*N+j][0] -= 1
  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2), dtype=int)
  
  for i in range(N2):
    total_spin = 0
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.010500771604938272}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[site_nbr]][(i%N)]
    if h[i%N][(i//N)] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin += h[site][i%N]
      if h[i//N][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,-0] for _ in range(N**2)]
  total_spin = [0,0]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [x for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.007117129629629629}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  total_spin = [0]*N**2
  for i in range(N**2):
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      total_spin[i] += h[site][i%N]
    if h[site_nbrs[i]][0] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return(priority_total)




#score: {'data2D.txt': -0.3430239197530853}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin.copy()
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total = total_spin.copy()
      priority_total[i][0] -= 1
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priority_total += 1
      else:
        priority_total -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  total_spin = [0]*N**2
  for i in range(N**2):
    site_nbr = (i // N + ((i % N)-1)//2 - 1) % N
    total_spin[i] += h[site_nbr][i%N]
    if h[site_nbrs[i]][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbr = [(i % N + ((i//N-1)%2 - 1)) % N for i in range(N**2)]
  
  for i in range(N**2):
    total_spin[i][0] += h[site_nbr[i]][i%N]
    if h[site_nbr[i]][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return(total_spin)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i // N + ((i % N)-1)//2 - 1) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbrs[i]][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    site_nbr = (i // N + ((i % N)-1)//2 - 1) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbrs[i]][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priorities = [(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = total_spin[1]
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[-total_spin[k][0], -total_spin[k][1]] for k in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.010756018518518517}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbr = [(i % N + ((i//N-1)%2 - 1)) % N for i in range(N**2)]
  
  for k in range(3):
    for i in range(N**2):
      site = (i % N + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site][i%N]
      if h[site][i%N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return(total_spin)




#score: {'data2D.txt': -0.023747685185185212}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_list = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0][site_nbr][j] > 0:
        total_spin += 1
      elif J[0][site_nbr][j] < 0:
        total_spin -= 1
      
      if J[1][i][j] > 0:
        total_spin += 1
      elif J[1][i][j] < 0:
        total_spin -= 1
      
      if J[2][site_nbr][j] > 0:
        total_spin += 1
      elif J[2][site_nbr][j] < 0:
        total_spin -= 1
      
      if J[3][i][j] > 0:
        total_spin += 1
      elif J[3][i][j] < 0:
        total_spin -= 1
      
      priority_list[i*N+j][0] = total_spin
      priority_list[i*N+j][1] = -total_spin
  
  return priority_list




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], h[i][j]]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
        return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.concatenate((total_spin[:, 0][:, None], -total_spin[:, 1][:, None]), axis=1)
  return priority_total.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  return(total_spin.reshape(N*N,2).tolist())




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]

  return(priority_total)




#score: {'data2D.txt': -0.023752932098765434}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += total_spin[i*N+j][0]
        priority_total[i*N+j][1] -= total_spin[i*N+j][1]
      else:
        priority_total[i*N+j][0] -= total_spin[i*N+j][0]
        priority_total[i*N+j][1] += total_spin[i*N+j][1]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total

  site_nbr = (i + ((k-1)%2 - 1)) % N
  if h[site_nbr][j] > 0:
    total_spin += 1
  else:
    total_spin -= 1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1

  return [[total_spin[i], -total_spin[i]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
    else:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return(total_spin)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  total_spin = [0]*N**2
  for i in range(N**2):
    site_nbr = (i // N + ((i % N)-1)//2 - 1) % N
    total_spin[i] += h[site_nbr][i%N]
    if h[site_nbrs[i]][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for k in range(2):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    site = (i + ((3-1)%2 - 1)) % N
    if h[site][i] > 0:
      priority_total += 1
    else:
      priority_total -= 1
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0,0]
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [x for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  
  for k in range(3):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3346547839506163}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
        priority_total[site_nbr1][0] += 1
        priority_total[site_nbr2][0] += 1
        priority_total[site_nbr1][1] -= 1
        priority_total[site_nbr2][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
        priority_total[site_nbr1][0] -= 1
        priority_total[site_nbr2][0] -= 1
        priority_total[site_nbr1][1] += 1
        priority_total[site_nbr2][1] += 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((0)%2 - 1)) % N
      site_nbr2 = (j + ((0)%2 - 1)) % N
      total_spin = h[site_nbr1][site_nbr2]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((1)%2 - 1)) % N
      site_nbr2 = (j + ((1)%2 - 1)) % N
      total_spin += h[site_nbr1][site_nbr2]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((2)%2 - 1)) % N
      site_nbr2 = (j + ((2)%2 - 1)) % N
      total_spin += h[site_nbr1][site_nbr2]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((3)%2 - 1)) % N
      site_nbr2 = (j + ((3)%2 - 1)) % N
      total_spin += h[site_nbr1][site_nbr2]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,-0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in priority_total]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.concatenate((total_spin[:, 0][:, None], -total_spin[:, 1][:, None]), axis=1)
  return priority_total.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  priority_total = np.concatenate((total_spin[:, 0][:, None], -total_spin[:, 1][:, None]), axis=1)
  return priority_total.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.0012955246913580244}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,i*N:i*N+N], axis=0)
    
    if h[i].sum() > 0:
      priority_total[:,0] += 1
      priority_total[:,1] -= 2 * (np.sum(h[i]) + np.sum(total_spin[1:]))
    else:
      priority_total[:,0] -= 1
      priority_total[:,1] += 2 * (np.sum(h[i]) + np.sum(total_spin[1:]))
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return [[x, -y] for x, y in priority_total]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
      else:
        priority_total[i * N + j][0] -= 1
        priority_total[i * N + j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  total_spin = [0,0]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0],-x[1]] for x in priority_total]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
      
  for i in range(N**2):
    if sum(total_spin[i]) > N*N//2:
      priority_total = [[-1,1]]*N*N
    else:
      priority_total = [[1,-1]]*N*N
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0],-x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], 0]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin[1] += h[site][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.006327314814814814}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0, 0]
    
    for k in range(3):
      if J[k][site_nbr][i%N] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priority_total[i][0] += sum([a for a in h[site_nbr]]) + total_spin[0]
    if sum(h[site_nbr]) > 0:
      priority_total[i][1] -= 1 - total_spin[1]
    else:
      priority_total[i][1] += 1 - total_spin[1]
  
  return priority_total




#score: {'data2D.txt': -0.05699861111111112}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2), dtype=int)
  
  # Calculate magnetism based priorities
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  # Calculate interaction based priorities
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(4):
        if J[k][site_nbr][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j][0] += sum([a for a in h[site_nbr]]) + total_spin[0]
      if sum(h[site_nbr]) > 0:
        priority_total[i*N+j][1] -= 1 - total_spin[1]
      else:
        priority_total[i*N+j][1] += 1 - total_spin[1]

  return priority_total




#score: {'data2D.txt': -0.04970478395061729}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      if J[0][site_nbr][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif J[0][site_nbr][j] < 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      if J[1][site_nbr][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif J[1][site_nbr][j] < 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      if J[2][site_nbr][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif J[2][site_nbr][j] < 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      if J[3][site_nbr][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif J[3][site_nbr][j] < 0:
        total_spin[0] -= 1
        total_spin[1] += 1

      priority_total[i*N+j][0] += sum([a for a in h[site_nbr]]) + total_spin[0]
      if sum(h[site_nbr]) > 0:
        priority_total[i*N+j][1] -= 1 - total_spin[1]
      else:
        priority_total[i*N+j][1] += 1 - total_spin[1]

  return priority_total




#score: {'data2D.txt': -0.010500771604938272}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[site_nbr]][(i%N)]
    if h[i%N][(i//N)] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.010500771604938272}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[site_nbr]][(i%N)]
    if h[i%N][(i//N)] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.18973935185185203}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total

  neighbor_list = [(i, j) for i in range(N) for j in range(N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[-x for x in y] for y in total_spin]
  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  # first row
  for i in range(1, N):
    site_nbr = (i + ((N - 1) % 2 - 1)) % N
    if h[i][0] > 0:
      total_spin[i * N][0] += 1
      total_spin[i * N][1] -= 1
    else:
      total_spin[i * N][0] -= 1
      total_spin[i * N][1] += 1

  # first column
  for j in range(1, N):
    site_nbr = (N - 1) % N
    if h[0][j] > 0:
      for i in range(N):
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
    else:
      for i in range(N):
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1

  # other sites
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1

  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.04188780864197534}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return([list(total_spin[i]) for i in range(N*N)])




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N ** 2)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i % N]
    if h[site_nbrs[i]][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]

  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i//N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  n = N**2
  spin_priorities = np.zeros((n, 2))

  for i in range(n):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin_priorities[i][0] += 1
      spin_priorities[i][1] -= 1
    else:
      spin_priorities[i][0] -= 1
      spin_priorities[i][1] += 1

  for i in range(n):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      spin_priorities[i][0] += 1
      spin_priorities[i][1] -= 1
    else:
      spin_priorities[i][0] -= 1
      spin_priorities[i][1] += 1

  return spin_priorities.tolist()




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': 0.14715138888888907}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] += total_spin
      if h[i][j] > 0:
        priority_total[i*N+j][1] -= len([True for k in range(3) if h[(i + ((k-1)%2 - 1)) % N][j] > 0])
      else:
        priority_total[i*N+j][1] += len([True for k in range(3) if h[(i + ((k-1)%2 - 1)) % N][j] < 0])
  return [[x[0], -x[1]] for x in priority_total]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[i]][i % N]
    if h[site_nbrs[i]][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i%N + ((i//N-1)%2-1))%N for i in range(N**2)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[site_nbrs[i]][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0],-total_spin[i][1]] for i in range(N*N)]
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.0010433641975308645}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      priorities[i*N+j][0] += J[0, i, j] * (h[site_nbr][j] - h[i][j])
      priorities[i*N+j][1] -= J[1, i, j] * (h[site_nbr][j] - h[i][j])
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          total_spin += 1
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          total_spin -= 1
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
  return priority_total




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return ([list(map(lambda x: (-1)**(x+1), row)) for row in total_spin])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]

  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]

  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities + total_spin/N**2




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N))
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  interacting_spins = np.zeros((4,N,N))  
  for i in range(4):
    interacting_spins[i] = ((i % 2) * 2 - 1) * h + ((i // 2) % 2) * J[i]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][1] += 1
  
  return(priority_total)




#score: {'data2D.txt': 0.05967978395061734}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[-h[i][j] for j in range(N)] for i in range(N)]
  for i in range(N):
    for j in range(N):
      if i > 0:
        priorities[i][j] += -J[0][i-1][j]
      if j > 0:
        priorities[i][j] += -J[1][i][j-1]
      if i < N-1:
        priorities[i][j] += J[2][i+1][j]
      if j < N-1:
        priorities[i][j] += J[3][i][j+1]
  return [[priorities[i][j], 0] for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0,0.0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total=np.zeros((N**2,2))
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      return priority_total




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.001936882716049405}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] - h[i][j]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1 * total_spin
        priorities[i*N+j][1] -= 1 * total_spin
      else:
        priorities[i*N+j][0] -= 1 * total_spin
        priorities[i*N+j][1] += 1 * total_spin
  return priorities




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(N**2):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site][k%N] > 0:
      total_spin[k][0] += 1
      total_spin[k][1] -= 1
    else:
      total_spin[k][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  J_ = J.reshape((4, -1))
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  total_spin = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i // N) % 2 - 1)) % N
    if h[i // N][i % N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1

  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i // N) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    
    if h[i // N][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N][i%N][0] += 1
      total_spin[i//N][i%N][1] -= 1
    else:
      total_spin[i//N][i%N][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[0] += 1
      priorities[i*N+j] = [total_spin[0], total_spin[1]]
  return priorities




#score: {'data2D.txt': -0.016323919753086422}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  total_spin = np.zeros((N, N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
      
  for i in range(N):
    if h[0][i] > 0:
      priority_total[i][0] = total_spin[0][i][0]
    else:
      priority_total[i][1] = -total_spin[0][i][0]
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(4):
      if J_[j][i] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0.0, 0.0] for _ in range(N**2)]
  priority_total = [[0.0, 0.0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]

  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]

  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': 0.18973935185185203}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  total_spin = np.zeros((N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.028056018518518563}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j] - h[i][j]
        if J[k, i, j] > 0:
          priority_total[i*N+j][0] += 1 * total_spin
          priority_total[i*N+j][1] -= 1 * total_spin
        else:
          priority_total[i*N+j][0] -= 1 * total_spin
          priority_total[i*N+j][1] += 1 * total_spin
  return priority_total




#score: {'data2D.txt': -0.001936882716049405}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] - h[i][j]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1 * total_spin
        priorities[i*N+j][1] -= 1 * total_spin
      else:
        priorities[i*N+j][0] -= 1 * total_spin
        priorities[i*N+j][1] += 1 * total_spin
  return priorities




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return ([list(map(lambda x: (-1)**(x+1), row)) for row in total_spin])




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_square = N*N
  total_spin = [[0, 0] for _ in range(N_square)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N_square)]
  
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.15130416666666688}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i * N + j][0] -= 1
        priority_total[i * N + j][1] += 1
      else:
        total_spin -= 1
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]

  return([[-x[0],-x[1]] if x[0]>0 else [x[0],-x[1]] for x in priority_total])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.0034868827160493823}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[0][site_nbr][j] > 0:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
      else:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      if total_spin > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
      
  return priority_total




#score: {'data2D.txt': -0.002278549382716049}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[0][site_nbr][j] > 0:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
      else:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
  return total_spin




#score: {'data2D.txt': -0.31976836419752996}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  spin_priority = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        spin_priority[i*N+j][0] += 1
        spin_priority[i*N+j][1] -= 1
      else:
        spin_priority[i*N+j][0] -= 1
  
  for k in range(3):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin = 0
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      spin_priority[i*N+k][0] += total_spin
      spin_priority[i*N+k][1] -= total_spin
  
  return spin_priority




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N * N):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return (priority_total)




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin.tolist()




#score: {'data2D.txt': -0.27106867283950575}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return (priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return(priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  priority_total = [[0, 0] for _ in range(N * N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
      else:
        priority_total[i * N + j][0] -= 1

  return [list(x) for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
      
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += total_spin[site_nbr][j][0]
        priority_total[i*N+j][1] -= total_spin[site_nbr][j][1]
      else:
        priority_total[i*N+j][0] -= total_spin[site_nbr][j][0]
        priority_total[i*N+j][1] += total_spin[site_nbr][j][1]
      
  for k in range(N**2):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site][k%N] > 0:
      priority_total[k][0] += 1
      priority_total[k][1] -= 1
    else:
      priority_total[k][0] -= 1
      priority_total[k][1] += 1
      
  return priority_total




#score: {'data2D.txt': -0.22700200617283905}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
      
  priority_total = np.zeros((N**2, 2))
  
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        total_spin[i][k][0] += 1
        total_spin[i][k][1] -= 1
      else:
        total_spin[i][k][0] -= 1
        total_spin[i][k][1] += 1
      
  for i in range(N**2):
    priority_total[i][0] = total_spin[i//N][i%N][0]
    if h[i//N][i%N] > 0:
      priority_total[i][1] = -total_spin[i//N][i%N][1]
    else:
      priority_total[i][1] = total_spin[i//N][i%N][1]
      
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  priority_total = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  priority_total = np.zeros((N2, 2))
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  
  return priority_total




#score: {'data2D.txt': -0.2207300925925926}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J_flat[i] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i] > 0:
        total_spin = np.sum(J[k][:, i])
        priority_total[i*N+i][0] += 1
        priority_total[i*N+i][1] -= 1 * (total_spin > 0)
      else:
        total_spin = -np.sum(J[k][:, i])
        priority_total[i*N+i][0] -= 1
        priority_total[i*N+i][1] += 1 * (total_spin < 0)
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
        
  for k in range(4):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return (priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))
  
  for k in range(4):
    for i,j in itertools.product(range(N),range(N)):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.32417083333333246}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for j in range(N):
    if h[0][j] > 0:
      priority_total[j][0] = 1
    else:
      priority_total[j][1] = -1
  
  for i in range(1, N):
    if h[i][0] > 0:
      priority_total[i*N + 0][0] = 1
    else:
      priority_total[i*N + 0][1] = -1
  
  return priority_total.tolist()




#score: {'data2D.txt': -0.33384984567901144}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N):
    if h[0][i] > 0:
      priority_total[i][0] = -np.sum(priority_total[:, 1])
    else:
      priority_total[i][0] = np.sum(priority_total[:, 0])
  return priority_total




#score: {'data2D.txt': -0.34030200617283846}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for j in range(N):
    if h[0][j] > 0:
      priority_total[j][0] = 1
    else:
      priority_total[j][1] = -1
  
  return priority_total.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0.0, 0.0] for _ in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N**2):
    if h[int(i//N)][i%N] > 0:
      total_spin[i][0] = -1
    else:
      total_spin[i][1] = 1
  
  return [[x, y] for x, y in total_spin]




#score: {'data2D.txt': -0.1806384259259262}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(N):
      if J[0][site_nbr][j] > 0:
        total_spin += h[i//N][j]
      else:
        total_spin -= h[i//N][j]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += total_spin
      priority_total[i][1] -= 2*total_spin + 1
    else:
      priority_total[i][0] -= total_spin
      priority_total[i][1] = -total_spin + 1
  return priority_total




#score: {'data2D.txt': 0.006961882716049383}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  # Calculate total spin and priority for each site
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
      
  # Calculate priority for assigning spins to -1 and 1 based on site interactions and magnetism
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  for i in range(N2):
    if h[i//N][i%N] > 0:
      total_spin[i][0] += J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      total_spin[i][1] -= J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
    else:
      total_spin[i][0] -= J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      total_spin[i][1] += J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return priorities.tolist()




#score: {'data2D.txt': -0.009445216049382716}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total[i][0] += total_spin
    priority_total[i][1] = -priority_total[i][0]
  
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[i]][i % N]
    if h[site_nbrs[i]][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N]
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  total_spin = [0, 0]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[0] += 1
      priorities[i*N+j] = [total_spin[0], total_spin[1]]
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], 0]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities.append([1, -1])
    else:
      priorities.append([-1, 1])
  return priorities




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return (priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[0] += 1
      priorities[i*N+j] = [total_spin[0], total_spin[1]]
  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[0] += 1
      priorities[i*N+j] = [total_spin[0], total_spin[1]]
  return priorities




#score: {'data2D.txt': 0.1898905864197533}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return [[priorities[i][0], -priorities[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][i%N] > 0:
          total_spin[i][0] += 1
          total_spin[i][1] -= 1
        else:
          total_spin[i][0] -= 1
          total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.0005449074074074074}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i % N]
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return ([list(map(lambda x: (-1) ** (x + 1), row)) for row in priority_total])




#score: {'data2D.txt': -0.001936882716049405}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] - h[i][j]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1 * total_spin
        priorities[i*N+j][1] -= 1 * total_spin
      else:
        priorities[i*N+j][0] -= 1 * total_spin
        priorities[i*N+j][1] += 1 * total_spin
  return priorities




#score: {'data2D.txt': 0.09752453703703716}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.1898905864197533}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.0014229938271604935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
      return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.0013773148148148147}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N,N,2))
  for k in range(4):
    if k%2==0:
      for i in range(N):
        for j in range(N):
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin[i][j][0] += h[site_nbr][j]
          if h[i][j] > 0:
            total_spin[i][j][0] += 1
            total_spin[i][j][1] -= 1
          else:
            total_spin[i][j][0] -= 1
            total_spin[i][j][1] += 1
    else:
      for i in range(N):
        site_nbr = (i + ((k-2)%2 - 1)) % N
        for j in range(N):
          if h[site_nbr][j] > 0:
            total_spin[i][j][0] += 1
            total_spin[i][j][1] -= 1
          else:
            total_spin[i][j][0] -= 1
            total_spin[i][j][1] += 1  
  return [(i*N+j, (-sum(J[i][j]*total_spin[k-1][i][j]) if k%2==0 else -J[(k-1)%4][i][j]),) for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.016323919753086422}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  for i in range(N):
    if h[0][i] > 0:
      priority_total[i][0] = total_spin[0][i][0]
    else:
      priority_total[i][1] = -total_spin[0][i][0]
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0, 0] for _ in range(N**2)]
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      priority_total[i*N+j][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          total_spin += 1
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          total_spin -= 1
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.0093125}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.2742109567901232}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = []
  for i in range(N**2):
    if i % N == 0:
      site_nbr = (i + ((N-1)%2 - 1)) % N
    else:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
    else:
      total_spin[i*N+j][0] -= 1
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return total_spin.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
    return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
      else:
        total_spin[i*N+j][0] -= 1
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N):
    for j in range(N):
      site_nbr = site_nbrs[i*N+j]
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.17293256172839455}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
    else:
      total_spin[i*N+j][0] -= 1
  return ([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.2207300925925926}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_flat = np.concatenate((J[0].flatten(), J[1].flatten(), J[2].flatten(), J[3].flatten()))
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J_flat[i] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.00043070987654320985}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] + flat_J[i]
    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1

  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N):
    for j in range(N):
      site_nbr = site_nbrs[i*N+j]
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = site_nbrs[i*N+j]
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.15769274691358048}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      for k in range(4):
        neighbor_i = (i + ((k%2) - 1)) % N
        neighbor_j = (j + ((k//2) - 1)) % N
        
        if h[neighbor_i][neighbor_j] > 0:
          total_spin += J[k, i, j]
        else:
          total_spin -= J[k, i, j]
      
      priorities[i*N+j, 0] = total_spin
      priorities[i*N+j, 1] = -total_spin
  
  return priorities.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  site_nbrs = []
  
  for k in range(3):
    for i in range(N ** 2):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      total_spin[i][0] += h[site_nbr][i % N]
      if h[i // N][i % N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
  
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i][j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][j][0] += 1
      else:
        total_spin[i][j][0] -= 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N * N)]




#score: {'data2D.txt': 0.2742109567901232}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]




#score: {'data2D.txt': 0.2742109567901232}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
  return priority_total




#score: {'data2D.txt': -0.003911574074074074}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J_flat[i*4] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1

  return priority_total




#score: {'data2D.txt': -0.16921435185185135}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  for i in range(N):
    if h[0][i] > 0:
      priority_total[i][0] = total_spin[0][0]
    else:
      priority_total[i][1] = -total_spin[0][0]
  
  return ([priority_total[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': 0.1648658950617279}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    if h[0][i] > 0:
      total_spin[i][0] = total_spin[0][1]
    else:
      total_spin[i][1] = -total_spin[0][1]

  priority_total = [[-a for a in b] for b in total_spin]

  return [list(a) for a in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.zeros((N*N,2))
  for k in range(3):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      priority_total[i*N+j][0] -= 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.04700787037037041}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priority_total[i][0] += total_spin + 1
      priority_total[i][1] -= 2*total_spin+1
    else:
      priority_total[i][0] -= total_spin - 1
      priority_total[i][1] += 2*total_spin-1
  
  return priority_total




#score: {'data2D.txt': 0.2742109567901232}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  for i in range(N):
    site_nbr = (i + ((2-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N * N)]




#score: {'data2D.txt': 0.1648658950617279}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    if h[0][i] > 0:
      total_spin[i][0] = total_spin[0][1]
    else:
      total_spin[i][1] = -total_spin[0][1]

  priority_total = [[-a for a in b] for b in total_spin]

  return [list(a) for a in priority_total]




#score: {'data2D.txt': -0.10918935185185198}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    site_nbr = (i + ((0)%2 - 1)) % N
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i*N+j, 0] += 1
        total_spin[i*N+j, 1] -= 1
      else:
        total_spin[i*N+j, 0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i, 0] += 1
      total_spin[i, 1] -= 1
    else:
      total_spin[i, 0] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j, 0] += J[0, i, j]
      else:
        total_spin[i*N+j, 0] -= J[0, i, j]
      
      site_nbr = (i + ((1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j, 0] += J[1, i, j]
      else:
        total_spin[i*N+j, 0] -= J[1, i, j]
      
      site_nbr = (i + ((2)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j, 0] += J[2, i, j]
      else:
        total_spin[i*N+j, 0] -= J[2, i, j]
      
      site_nbr = (i + ((3)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j, 0] += J[3, i, j]
      else:
        total_spin[i*N+j, 0] -= J[3, i, j]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i, 0] += 1
      total_spin[i, 1] -= 1
    else:
      total_spin[i, 0] -= 1
  
  return total_spin.tolist()




#score: {'data2D.txt': -0.15769274691358048}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      for k in range(4):
        neighbor_i = (i + ((k%2) - 1)) % N
        neighbor_j = (j + ((k//2) - 1)) % N
        
        if h[neighbor_i][neighbor_j] > 0:
          total_spin += J[k, i, j]
        else:
          total_spin -= J[k, i, j]
        
      priorities[i*N+j, 0] = total_spin
      priorities[i*N+j, 1] = -total_spin
      
  return priorities.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(2):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return total_spin.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return total_spin

  # Add your logic here to create a priority function based on the site interactions and magnetism.
  # For example, you can calculate the priority for each spin as follows:

  def get_priority(total_spin):
    priority_list = []
    for i in range(N**2):
      spin = np.sign(total_spin[i][0])
      if spin == 1:
        priority = J[0][i]
      else:
        priority = -J[0][i]
      priority_list.append([spin, priority])
    return priority_list

  return get_priority




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][j][0] += 1
      else:
        total_spin[i][j][0] -= 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.14147299382716066}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for j in range(2):
        total_spin[i][j] += 1
    else:
      for j in range(2):
        total_spin[i][j] -= 1
  
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.240644907407407}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
      else:
        total_spin[i*N+j][0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(3)]
    neighbors_spin = [h[s][i%N] for s in site_nbrs]
    total_spin = sum([a*b for a,b in zip(neighbors_spin, [1,-1])])
    magnetism = sum([a*b for a,b in zip(neighbors_spin, [1,1])])
    
    # Calculate priorities
    priority_0 = -magnetism
    priority_1 = total_spin
    
    priorities.append([priority_0, priority_1])
  
  return np.array(priorities)




#score: {'data2D.txt': -0.14147299382716066}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for j in range(2):
        total_spin[i][j] += 1
    else:
      for j in range(2):
        total_spin[i][j] -= 1
  
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return [total_spin[i] for i in range(N*N)]




#score: {'data2D.txt': -0.0008662037037037036}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  
  for k in range(3):
    for i in range(N**2):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbrs[i]][i%N]
      if h[i//N][i%N] > 0:
        priority_total = [total_spin[i][0] + 1, -total_spin[i][1] - 1]
      else:
        priority_total = [-total_spin[i][0] - 1, total_spin[i][1] + 1]
  
  return [[priority_total[0], -priority_total[1]] for i in range(N*N)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    if h[0][i] > 0:
      priority_total[i][0] = total_spin[0][0]
    else:
      priority_total[i][1] = -total_spin[0][0]
  return ([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.009996450617283952}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  for i in range(N**2):
    for k in range(3):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][0] += 1
      else:
        total_spin[i][0] -= 1
  
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
        
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  for k in range(2):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          total_spin += 1
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          total_spin -= 1
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.010322376543209878}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
  for i in range(N**2):
    site = (i % N + ((3-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i % N + ((i // N - 1) % 2 - 1)) % N for i in range(N*N)]

  for i in range(N**2):
    site_nbr = site_nbrs[i]
    total_spin[i][0] += h[site_nbr][i % N]
    if h[i // N][i % N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.0014245370370370369}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      priority_total[i*N+j][0] -= 1
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.09752453703703716}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[-a for a in b] for b in total_spin]
  return [list(a) for a in priority_total]




#score: {'data2D.txt': -0.009445216049382716}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priorities = [(np.sign(t[0]), np.sign(t[1])) for t in total_spin]
  return [list(x) for x in priorities]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i + ((i//N+1)%2 - 1)) % N
    if h[site_nbrs[i]][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(N)]
    site_nbr_sum = sum(h[site_nbrs[j]][j] for j in range(N))
    
    if h[i//N][i%N] > 0:
      total_spin[i][0] += site_nbr_sum
      total_spin[i][1] -= (N - site_nbr_sum)
    else:
      total_spin[i][0] -= site_nbr_sum
      total_spin[i][1] += (N - site_nbr_sum)
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  for i in range(N**2):
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(a) for a in priority_total]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[-a for a in b] for b in total_spin]
  return [list(a) for a in priority_total]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  priority_total = [[-a for a in b] for b in total_spin]
  return [list(a) for a in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for k in range(3):
    for i in range(N):
      for j in range(N):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1

  priority_total = [[-a for a in b] for b in total_spin]
  return [list(a) for a in priority_total]




#score: {'data2D.txt': 0.011550462962962964}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(4)]
    neighbors_spin = [h[s][i%N] for s in site_nbrs]
    total_spin = sum([a*b for a,b in zip(neighbors_spin, [1,-1,1,1])])
    magnetism = sum([a*b for a,b in zip(neighbors_spin, [1,1,1,1])])
    
    # Calculate priorities
    priority_0 = -magnetism
    priority_1 = total_spin
    
    priorities.append([priority_0, priority_1])
  
  return np.array(priorities)




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(3)]
    neighbors_spin = [h[s][i%N] for s in site_nbrs]
    total_spin = sum([a*b for a,b in zip(neighbors_spin, [1,-1])])
    magnetism = sum([a*b for a,b in zip(neighbors_spin, [1,1])])
    
    # Calculate priorities
    priority_0 = -magnetism
    priority_1 = total_spin
    
    priorities.append([priority_0, priority_1])
  
  return np.array(priorities)




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(3)]
    neighbors_spin = [h[s][i%N] for s in site_nbrs]
    total_spin = sum([a*b for a,b in zip(neighbors_spin, [1,-1])])
    magnetism = sum([a*b for a,b in zip(neighbors_spin, [1,1])])
    
    # Calculate priorities
    priority_0 = -magnetism
    priority_1 = total_spin
    
    priorities.append([priority_0, priority_1])
  
  return np.array(priorities)




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(3)]
    neighbors_spin = [h[s][i%N] for s in site_nbrs]
    total_spin = sum([a*b for a,b in zip(neighbors_spin, [1,-1])])
    magnetism = sum([a*b for a,b in zip(neighbors_spin, [1,1])])
    
    # Calculate priorities
    priority_0 = -magnetism
    priority_1 = total_spin
    
    priorities.append([priority_0, priority_1])
  
  return np.array(priorities)




#score: {'data2D.txt': 0.34260046296296187}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]
  
  for k in range(3):
    for i in range(N**2):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbrs[i]][i%N]
      if h[i//N][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for k in range(3):
    for i in range(N**2):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbrs[i]][i%N]
      if h[i//N][i%N] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return total_spin.reshape(N2, 2)




#score: {'data2D.txt': -0.2207300925925926}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_flat = np.concatenate((J[0].flatten(), J[1].flatten(), J[2].flatten(), J[3].flatten()))
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J_flat[i] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1

  return priority_total




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for i in range(N**2):
    site_nbr = (i + ((3-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_list = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return priority_list




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for i in range(N**2):
    site_nbr = (i + ((i//N+((i%N-1)%2)-1)) % N)
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i + ((i//N+((i%N-1)%2)-1)) % N)
    if h[site_nbrs[i]][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  site_nbrs = [(i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for i in range(N**2):
    site_nbr = (i + ((3-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbrs[i]][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.18973935185185203}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return priority_total




#score: {'data2D.txt': 0.0484013888888889}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  total_spin = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    
    if J_flat[(i % N*4) + (i//N)] > 0:
      if h[i//N][i%N] > 0:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
      else:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
    
    if J_flat[(i % N*4) + ((i//N)%N)] > 0:
      if h[(i+1)%N][i%N] > 0:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
      else:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
    
    if J_flat[(i % N*4) + (N+i//N)] > 0:
      if h[i//N][(i+1)%N] > 0:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
      else:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
    
    if J_flat[(i % N*4) + (N+i//N)%N] > 0:
      if h[(i+1)%N][(i+1)%N] > 0:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
      else:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
  
  return total_spin




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  priority_total = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N2, 2))
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin -= 1
    else:
      total_spin += 1
  
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i, j: (i + ((j-1)%2 - 1)) % N
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr_i_j = site_nbr(i, j)
      total_spin[i*N+j][0] += h[site_nbr_i_j][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[-1, -1] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr_i_j = site_nbr(i, j)
      if h[site_nbr_i_j][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N*N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return priority_total




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      
      priority_total[i*N+j] = [sum([a*b for a,b in zip(total_spin,[1,-1])]), sum([a*b for a,b in zip(total_spin,[1,1])])]
  
  return priority_total




#score: {'data2D.txt': -0.0005297839506172838}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(N)]
    
    for j in range(N):
      site_nbr = site_nbrs[j]
      total_spin[i][0] += h[site_nbr][j]
      
      if h[i//N][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.1606294753086417}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(N)]
    
    for j in range(N):
      for k in range(3):
        site = (site_nbrs[j] + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site][j]
        
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.0007319444444444447}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(N)]
    
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbrs[j]][j]
      
      if h[i//N][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
    
    for k in range(3):
     site = (i + ((k-1)%2 - 1)) % N
     if h[site][j] > 0:
       total_spin[i][0] += 1
       total_spin[i][1] -= 1
     else:
       total_spin[i][0] -= 1
       total_spin[i][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.0015424382716049383}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      
      total_energy = [0, 0]
      for k, neighbor_i in enumerate(site_nbrs):
        if J[k][i*N+j][0] > 0:
          total_energy[0] += h[neighbor_i][j]
          if h[i][j] > 0:
            total_energy[1] -= 1
          else:
            total_energy[1] += 1
        else:
          total_energy[0] -= h[neighbor_i][j]
          if h[i][j] > 0:
            total_energy[1] += 1
          else:
            total_energy[1] -= 1
      
      return [[total_energy[0], -total_energy[1]] for _ in range(N*N)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += int(total_spin[site_nbr][j][0] > 0)
      priority_total[i*N+j][1] -= int(total_spin[site_nbr][j][0] > 0)
  
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)
  
  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N] + flat_J[i]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  priority = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_val = h[site_nbr][i%N]
    if site_val > 0:
      priority[i][0] += np.abs(site_val)
      priority[i][1] -= np.abs(site_val)
    else:
      priority[i][0] -= np.abs(site_val)
      priority[i][1] += np.abs(site_val)
  
  return priority




#score: {'data2D.txt': -0.038475462962962996}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)
  
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + flat_J[i*N+j]
      if total_spin > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.0052535493827160495}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i%N][i%N] > 0:
      total_spin = h[site_nbr][i%N] + flat_J[i]
      priority_total[i][0] += int(total_spin>0)
      priority_total[i][1] -= int(total_spin>0)
    else:
      total_spin = -h[site_nbr][i%N] + flat_J[i]
      priority_total[i][0] -= int(total_spin>0)
      priority_total[i][1] += int(total_spin>0)

  return priority_total




#score: {'data2D.txt': -0.00043070987654320985}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N] + flat_J[i]
    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = priority_total[i][0] - priority_total[i][1]
    else:
      total_spin = priority_total[i][0] + priority_total[i][1]

    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1
  
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return priority_total.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += total_spin[site_nbr][j][0]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  priority_total = np.zeros((N * N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i][j][0] += 1
        else:
          total_spin[i][j][0] -= 1

  for i in range(N * N):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.038475462962962996}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)
  
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + flat_J[i*N+j]
      if total_spin > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if total_spin > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority_total[i*N+j][0] += total_spin
      if total_spin > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(2):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for k in range(3):  
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.06165601851851854}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  total_spin = np.zeros((N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total[i][0] += total_spin[site_nbr][0]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return priority_total.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      if J_flat[i*4+0] > 0 or J_flat[i*4+3] > 0:
        priority_total[i][1] += 1
      else:
        priority_total[i][0] -= 1
        
    else:
      if J_flat[i*4+1] < 0 or J_flat[i*4+2] < 0:
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] += 1
        
  return priority_total




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return total_spin.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': -0.05569675925925928}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))

  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return total_spin + priority_total




#score: {'data2D.txt': -0.010322376543209878}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
  for i in range(N**2):
    site = (i % N + ((3-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
  for i in range(N**2):
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return [list(row) for row in total_spin]




#score: {'data2D.txt': -0.010322376543209878}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
    site = (i % N + ((3-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return [np.array([total_spin[i][0], total_spin[i][1]]) for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(2):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.34284490740740636}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
    else:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.0009233024691358027}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0.0, 0.0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[0][site_nbr][i%N]
      total_spin[i][1] -= 1.0
    else:
      total_spin[i][0] -= J[0][site_nbr][i%N]
      total_spin[i][1] += 1.0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(3):
      k = i // N * N + (j % N)
      if J[j+1][site_nbr][k%N] > 0:
        total_spin[i][0] -= 1.0
        total_spin[i][1] += 1.0
      else:
        total_spin[i][0] += 1.0
        total_spin[i][1] -= 1.0
    
  return [list(map(lambda x: 2*x - N if x > (N/2) else 2*x, spin)) for spin in total_spin]




#score: {'data2D.txt': -0.0016233024691358025}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = [[0, 0] for _ in range(N2)]
  for i in range(N2):
    site_nbr1 = (i % N + ((i // N - 1) % 2 - 1)) % N
    site_nbr2 = (i % N + ((i // N + 1) % 2 - 1)) % N
    if h[site_nbr1][i % N] > 0:
      priorities[i][0] += J[0][site_nbr1][i % N]
      priorities[i][1] -= J[1][site_nbr1][i % N]
    else:
      priorities[i][0] -= J[0][site_nbr1][i % N]
      priorities[i][1] += J[1][site_nbr1][i % N]
    if h[site_nbr2][i % N] > 0:
      priorities[i][0] += J[0][site_nbr2][i % N]
      priorities[i][1] -= J[1][site_nbr2][i % N]
    else:
      priorities[i][0] -= J[0][site_nbr2][i % N]
      priorities[i][1] += J[1][site_nbr2][i % N]
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1

  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3420791666666656}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  site_nbr = (i + ((j-1)%2 - 1)) % N
  for j in range(N):
    site_nbrs = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(3)]
    
    for k in range(3):
      if h[site_nbrs[k]][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.2457587962962964}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.1606294753086417}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbrs = [(i + ((j-1)%2 - 1)) % N for j in range(N)]
    
    for j in range(N):
      for k in range(3):
        site = (site_nbrs[j] + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site][j]
        
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.0008128086419753088}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      priority_total = [total_spin[i*N+j][0], -total_spin[i*N+j][1]]
      return [priority_total for i in range(N*N)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return priority_total




#score: {'data2D.txt': 0.2457587962962964}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for k in range(3):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        total_spin[i*N+j][0] += h[site_nbr][j]
        
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
        
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1, -1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for k in range(3):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
          
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
      
  priority_total = [[val[0], -val[1]] for val in total_spin]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
    for k in range(2):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
        
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[sum([a*b for a,b in zip(total_spin[i], [1,-1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': -0.03206435185185186}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][0] > 0:
        total_spin[i*N:][:,1] -= 1
      else:
        total_spin[i*N:][:,1] += 1

  return total_spin




#score: {'data2D.txt': 0.14599336419753106}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[sum([a*b for a,b in zip(total_spin[i], [1, -1])]), sum([a*b for a,b in zip(total_spin[i],[1,1])])] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.2457587962962964}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  priority_total = np.vstack((total_spin[:, 0], -total_spin[:, 1])).T
  
  return priority_total.tolist()




#score: {'data2D.txt': 0.2572819444444444}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total = [1,-1]
      else:
        priority_total = [-1,1]
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [row for row in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      
      if h[site][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
    
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N*N)]
  
  return priority_total




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      priority_total[i*N+j][0] += total_spin
      priority_total[i*N+j][1] -= 2*(total_spin>0)-1
  return [[val[0],-val[1]] for val in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  site_nbr = (lambda i, j: ((i + ((j-1)%2 - 1)) % N))
  
  for i in range(N):
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr(i,j)][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.0009233024691358027}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0.0, 0.0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[0][site_nbr][i%N]
      total_spin[i][1] -= 1.0
    else:
      total_spin[i][0] -= J[0][site_nbr][i%N]
      total_spin[i][1] += 1.0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(3):
     k = i // N * N + (j % N)
     if J[j+1][site_nbr][k%N] > 0:
      total_spin[i][0] -= 1.0
      total_spin[i][1] += 1.0
     else:
      total_spin[i][0] += 1.0
      total_spin[i][1] -= 1.0
    
  return [list(map(lambda x: 2*x - N if x > (N/2) else 2*x, spin)) for spin in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      for k in range(2):
        site = (i + (k%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return [[val[0],-val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return [row for row in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(2):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
      
      for k in range(2):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
        else:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
      
  return [row for row in total_spin]




#score: {'data2D.txt': -0.0011316358024691358}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      if h[i][j] > 0:
        priority_total = [1,-1]
      else:
        priority_total = [-1,1]
      
      return [row for row in total_spin]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N*N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1 - J_flat[N*i % (4*N) + i%N]
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1 - J_flat[N*i % (4*N) + i%N]
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2,2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= total_spin
        priority_total[i*N+j][1] += total_spin
      else:
        priority_total[i*N+j][0] += total_spin
        priority_total[i*N+j][1] -= total_spin
        
  return priority_total




#score: {'data2D.txt': -0.07609583333333302}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        total_spin[i*N+j][0] += h[site][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.010956635802469136}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_magnetism = h[site_nbr][j]
      
      if total_magnetism > 0:
        priorities[i*N+j] = [1, -1]
      else:
        priorities[i*N+j] = [-1, 1]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_magnetism += h[site_nbr][j]
      
      if total_magnetism > 0:
        priorities[i*N+j] = [1, -1]
      else:
        priorities[i*N+j] = [-1, 1]
  
  return [row for row in priorities]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin += 1
        total_spin -= 1
      else:
        total_spin -= 1
        total_spin += 1
        
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin -= 1
          total_spin += 1
        else:
          total_spin += 1
          total_spin -= 1
      
      priority_total[i*N+j][0] = total_spin
  return [row for row in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N**2,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1

  return(priority_total)




#score: {'data2D.txt': -0.16858472222222246}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  priority_total = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for k in range(4): # consider all 4 neighbors
    for i in range(N):
      for j in range(N):
        site_nbrs = [(i + ((j-1)%2 - 1)) % N, (i + ((j+1)%2 - 1)) % N, (i + ((k-1)%2 - 1)) % N, (i + ((k+1)%2 - 1)) % N]
        for site_nbr in site_nbrs:
          total_spin[i*N+j][0] += h[site_nbr][j]
          if h[i][j] > 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  return [[h[i][j]*2 for _ in range(2)] for i in range(N) for j in range(N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(2):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.1565942901234569}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.225443981481481}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.024075462962962958}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))

  total_spin = np.zeros((N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = total_spin[i][0]
      priority_total[i*N+j][1] = -total_spin[i][1]

  return priority_total




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      if h[i][j] > 0:
        priority_total[i*N+j][0] += total_spin + 1
        priority_total[i*N+j][1] -= total_spin - 1
      else:
        priority_total[i*N+j][0] -= total_spin - 1
        priority_total[i*N+j][1] += total_spin + 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.001334722222222222}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i*N+j])
      if np.any(h==np.sum(J[:,i*N+j])):
        if h[i][j] > 0:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
      return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
  return priority_total




#score: {'data2D.txt': -0.011780092592592592}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0][site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.0064270061728395065}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
      
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  
  for i in range(N2):
    if h[i//N][i%N] > 0:
      total_spin[i][0] += J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      total_spin[i][1] -= J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
    else:
      total_spin[i][0] -= J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      total_spin[i][1] += J_flat[4*i + ((i//N-1)%2 - 1)*N + (i%N)]
      
  return [row[:2] for row in total_spin]




#score: {'data2D.txt': -0.2803294753086415}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbr = lambda i,j : (i + ((j-1)%2 - 1)) % N
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site = site_nbr(i,k%N)
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  priority_list = [(total_spin[i*N+j][0], -total_spin[i*N+j][1]) for i in range(N) for j in range(N)]
  
  return priority_list




#score: {'data2D.txt': -0.0014807098765432095}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin -= 1
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          total_spin += 1
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
      
      return priority_total.tolist()




#score: {'data2D.txt': -0.29649027777777714}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4,-1)
  J_flat = np.concatenate((J_[0],J_[1],J_[2],J_[3]))
  total_spin = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      if J_flat[i*4+0] > 0 or J_flat[i*4+3] > 0:
        total_spin[i][1] += 1
      else:
        total_spin[i][0] -= 1
    else:
      if J_flat[i*4+1] < 0 or J_flat[i*4+2] < 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] += 1
        
  return total_spin




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N)]

  for i in range(N**2):
    site_nbr = (site_nbrs[i] + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return total_spin




#score: {'data2D.txt': -0.00043070987654320926}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i,j:(i % N + ((i//N-1)%2 - 1)) % N
  return [[J[0][site_nbr(i,j)][j] if h[i][j] > 0 else -J[0][site_nbr(i,j)][j], 
          J[1][site_nbr(i,j)][j] if h[i][j] > 0 else -J[1][site_nbr(i,j)][j]] for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  result = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
          total_spin -= 1
        else:
          total_spin -= 1
          total_spin += 1
      
      result[i*N+j] = [total_spin, -total_spin]
  
  return result




#score: {'data2D.txt': 0.34257731481481374}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
    else:
      total_spin[i*N+j][0] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return total_spin.tolist()




#score: {'data2D.txt': -0.007888117283950617}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[k][site_nbr][i%N] > 0:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
      else:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
    
  return priority_total




#score: {'data2D.txt': -0.0029976851851851853}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    for k in range(4):  
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k][site_nbr][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
        
  return priority_total




#score: {'data2D.txt': -0.012156327160493828}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += J[0][site_nbr][i%N]
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= J[0][site_nbr][i%N]
      total_spin[i][1] += 1
  
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.3359779320987644}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_flat = J.flatten()
  J_indices = np.unravel_index(np.arange(J_flat.size), (N,N,N,4))
  
  priorities = np.zeros((N2, 2), dtype=int)
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    J_site_neighbors = J_indices[3][(J_indices[0]==site_nbr) & (np.abs(J_indices[1]-i%N)<=1)]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.sum(J_flat[J_site_neighbors])
      priorities[i][1] -= 2*np.sum(1)
    else:
      priorities[i][0] -= np.sum(J_flat[J_site_neighbors])
      priorities[i][1] += 2*np.sum(1)
      
  return priorities




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return [list(t) for t in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  spin_values = [-1, 1]
  
  # Calculate total magnetism and interactions for each site
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      site_nbrs.remove(i)
      total_spin[i*N+j][0] += sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= len([k for k in site_nbrs if h[k][j] > 0])
      else:
        total_spin[i*N+j][1] += len([k for k in site_nbrs if h[k][j] < 0])
  
  # Calculate priorities for each site
  priority_values = [[val[0], -val[1]] for val in total_spin]
  
  return priority_values




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1

  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total.reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.34291774691357924}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(2):
    site = (i + ((k)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
    else:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.0034859567901234572}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i,j:(i % N + ((i//N-1)%2 - 1)) % N
  return [[sum(J[0][site_nbr(i,j)][k] for k in range(3) if h[(i+(k-1)%2-N//2)%N][j]>0) - sum(-J[0][site_nbr(i,j)][k] for k in range(3) if h[(i+(k-1)%2-N//2)%N][j]<=0),
      sum(J[1][site_nbr(i,j)][k] for k in range(3) if h[(i+(k-1)%2-N//2)%N][j]>0) - sum(-J[1][site_nbr(i,j)][k] for k in range(3) if h[(i+(k-1)%2-N//2)%N][j]<=0)] for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.043009722222222255}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i, j: (i % N + ((i // N - 1) % 2 - 1)) % N
  return [[sum(J[0][site_nbr(i, j)][k] for k in range(3) if abs(h[i][(j+k)%N]-h[site_nbr(i,j)][(k+1)%3]) > h[i][j]) 
      if h[i][j] > 0 else -sum(J[0][site_nbr(i, j)][k] for k in range(3) if abs(h[i][(j+k)%N]-h[site_nbr(i,j)][(k+1)%3]) > h[i][j]), 
      sum(J[1][site_nbr(i, j)][k] for k in range(3) if abs(h[i][(j+k)%N]-h[site_nbr(i,j)][(k+1)%3]) > h[i][j]) 
      if h[i][j] > 0 else -sum(J[1][site_nbr(i, j)][k] for k in range(3) if abs(h[i][(j+k)%N]-h[site_nbr(i,j)][(k+1)%3]) > h[i][j])] 
      for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.00043070987654320926}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i,j:(i % N + ((i//N-1)%2 - 1)) % N
  return [[J[0][site_nbr(i,j)][j] if h[i][j] > 0 else -J[0][site_nbr(i,j)][j], 
      J[1][site_nbr(i,j)][j] if h[i][j] > 0 else -J[1][site_nbr(i,j)][j]] for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.16194768518518532}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total.reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.18973935185185203}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          total_spin += 1
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          total_spin -= 1
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
    for k in range(N2):
      site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
      if h[site_nbr][k%N] > 0:
        priority_total[k][0] += 1
        priority_total[k][1] -= 1
      else:
        priority_total[k][0] -= 1
    return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return priority_total




#score: {'data2D.txt': -0.002721759259259259}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  J_reshape = J.reshape((4,N2))
  
  priority_total = np.zeros((N2,2))
  for k in range(4):
    site_nbr = (k % 2)
    
    total_spin = h[site_nbr].sum()
    if total_spin > 0:
      priority_total[:,0] += -1
      priority_total[:,1] -= 1
    else:
      priority_total[:,0] -= 1
      priority_total[:,1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total.reshape(-1, 2)




#score: {'data2D.txt': -0.0011316358024691358}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      return [[val[0],-val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[0,0] for _ in range(N*N)]
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
        
  return [[val[0],-val[1]] for val in total_spin]




#score: {'data2D.txt': -0.001378858024691358}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = [[0, 0] for _ in range(N2)]
  
  site_nbr = lambda i, j: (i + ((j - 1) % 2 - 1)) % N
  
  for i in range(N):
    for j in range(N):
      site_nbr_site = site_nbr(i, j)
      total_spin[i * N + j][0] += h[site_nbr_site][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(2):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
      
      if h[i][j] > 0:
        priority_total = [1, -1]
      else:
        priority_total = [-1, 1]
      
      return [[row[0], row[1]] for row in total_spin]




#score: {'data2D.txt': -0.0011316358024691358}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      return [row for row in total_spin]




#score: {'data2D.txt': -0.03296867283950618}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(2):
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] += J[k][site_nbr][j]
          priorities[i*N+j][1] -= J[k][site_nbr][j]
        else:
          priorities[i*N+j][0] -= J[k][site_nbr][j]
          priorities[i*N+j][1] += J[k][site_nbr][j]
  
  return [row for row in priorities]




#score: {'data2D.txt': -0.00043070987654320926}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr = lambda i,j:(i % N + ((i//N-1)%2 - 1)) % N
  return [[J[0][site_nbr(i,j)][j] if h[i][j] > 0 else -J[0][site_nbr(i,j)][j], 
      J[1][site_nbr(i,j)][j] if h[i][j] > 0 else -J[1][site_nbr(i,j)][j]] for i in range(N) for j in range(N)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  priority_total = [[0, 0] for _ in range(N*N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(2):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][1] += 2
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.28305910493827163}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J_ = J.reshape(4, -1)
  J_flat = np.concatenate((J_[0], J_[1], J_[2], J_[3]))
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J_flat[i] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    site_nbr = (i % N + ((i//N)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    
    if J_flat[(i+1) % (4*N2)] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    if J_flat[(i+N2) % (4*N2)] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
    if J_flat[(i+N2)% (4*N2)] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    
  return priority_total




#score: {'data2D.txt': -0.0013973765432098767}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[i*N2:(i+1)*N2].sum() > 0:
      total_spin += 1
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      total_spin -= 1
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1,4).sum(axis=1)
  
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + flat_J[i*N+j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      priority_total[i*N+j][0] -= 1
      priority_total[i*N+j][1] += 1
  
  site_nbr = (i + ((k-1)%2 - 1)) % N
  total_spin = h[site_nbr][j]
  if h[i][j] > 0:
    priority_total[i*N+j][0] += 1
    priority_total[i*N+j][1] -= 1
  else:
    priority_total[i*N+j][0] -= 1
    priority_total[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  flat_J = J.reshape(-1, 4).sum(axis=1)
  
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + flat_J[i*N+j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total = np.zeros((N**2, 2))
        for k in range(3):
          site = (i + ((k-1)%2 - 1)) % N
          if h[site][j] > 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
        return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] = total_spin
      if h[i][j] > 0:
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][1] += 1
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': 0.33378503086419653}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  for k in range(N):
    site = (k - (k%2)) % N
    if h[site][j] > 0:
      total_spin[k*N+j][0] += 1
    else:
      total_spin[k*N+j][0] -= 1
      
  return [[val[0], -val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for k in range(2):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
          
  return [list(row) for row in total_spin]




#score: {'data2D.txt': 0.0007106481481481484}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  for k in range(N):
    for i in range(N):
      for j in range(N):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
        else:
          total_spin[i*N+j][0] -= 1
        
  return [[val[0],-val[1]] for val in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = [[0,0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = [h[site_nbr][j],0]
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[1] += 1
      
      priorities[i*N+j] = [total_spin[0],abs(total_spin[0]-N*N)]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = np.array([0,0])
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [row for row in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  priority_total = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], 0]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j] = [total_spin[0], -total_spin[1]]
  return priority_total




#score: {'data2D.txt': -0.15427453703703725}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] += J[k,i,j]
          priorities[i*N+j][1] -= J[k,i,j]
        else:
          priorities[i*N+j][0] -= J[k,i,j]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': -0.005916203703703703}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priorities[i*N+j][0] += J[k, i, j]
          priorities[i*N+j][1] -= J[k, i, j]
        else:
          priorities[i*N+j][0] -= J[k, i, j]

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.009474537037037038}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.16543626543209902}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += J[k, i, j]
          total_spin[i*N+j][1] -= J[k, i, j]
        else:
          total_spin[i*N+j][0] -= J[k, i, j]
  return(total_spin)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N - 1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        total_spin[i*N+site_nbr][0] += 1
        total_spin[i*N+site_nbr][1] -= 1
      else:
        total_spin[i*N+site_nbr][0] -= 1
        total_spin[i*N+site_nbr][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.0018554012345679016}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  for k in range(4):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i][j][0] += 1
      total_spin[i][j][1] -= 1
    else:
      total_spin[i][j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = [1, -1]
    else:
      priority_total = [-1, 1]
  return([priority_total for _ in range(N**2)])




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.2727646604938272}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_list = []
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], 0]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_list.append(total_spin)
  return np.array(priority_list).reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      total_spin[i*N+k%N][0] += h[site_nbr][k%N]
      if h[i][k%N] > 0:
        total_spin[i*N+k%N][1] -= 1
      else:
        total_spin[i*N+k%N][1] += 1
  return [[x[0], -x[1]] for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.2727646604938272}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
        
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
      
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for k in range(N):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0,0] for _ in range(N**2)]
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      priority_total[i*N+j][0] -= 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.15427453703703725}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] += J[k,i,j]
          priorities[i*N+j][1] -= J[k,i,j]
        else:
          priorities[i*N+j][0] -= J[k,i,j]
  return(priorities)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
      
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
      
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.14446898148148155}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j] + J[k,i,j]
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.005916203703703703}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priority_total[i*N+j][0] += J[k, i, j]
          priority_total[i*N+j][1] -= J[k, i, j]
        else:
          priority_total[i*N+j][0] -= J[k, i, j]
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.17236095679012373}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][0] > 0:
        total_spin[i*N+0][0] += 1
        total_spin[i*N+0][1] -= 1
      else:
        total_spin[i*N+0][0] -= 1
        total_spin[i*N+0][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for k in range(N):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      total_spin[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
      total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total = np.zeros((N**2, 2))
        for k in range(3):
          site = (i + ((k-1)%2 - 1)) % N
          if h[site][j] > 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
        return priority_total.reshape(-1,2)
  return total_spin




#score: {'data2D.txt': 0.2727646604938272}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.26515231481481477}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, site_nbr][j]
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin = h[site_nbr][j] 
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin += J[0,site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      site_nbr = (i + ((j+1)%2 - 1)) % N
      total_spin += J[1,site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      site_nbr = ((N-1) + (i+j)%2 - 1) % N
      total_spin += J[2,site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      site_nbr = (i + ((N-1)-j)%2 - 1) % N
      total_spin += J[3,site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.046749537037036944}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k,site_nbr][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N**2, 2))
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1

  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.007194907407407406}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i%N][i//N][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      if i % N == 0:
        total_spin[i//N][i%N][1] -= 1
      elif i % N == N-1:
        total_spin[i//N][(i+1)%N][1] += 1
      else:
        total_spin[i//N][((i+1)%N)][1] += 1
    else:
      if i % N == 0:
        total_spin[i//N][i%N][1] += 1
      elif i % N == N-1:
        total_spin[i//N][(i-1)%N][1] -= 1
      else:
        total_spin[i//N][(i+1)%N][1] -= 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  prior = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      prior[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        prior[i*N+j][0] += 1
        prior[i*N+j][1] -= 1
      else:
        prior[i*N+j][0] -= 1
        prior[i*N+j][1] += 1
  return prior.reshape(-1,2)




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1
  return priority_total




#score: {'data2D.txt': -0.3051964506172833}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      if i % N == 0:
        total_spin[i][1] -= 1
      elif i % N == N-1:
        total_spin[i][1] += 1
      else:
        if (i+1)%N != N-1 and (i//N)*N+i%N < (i+1)//N*N+(i+1)%N:
          total_spin[i][1] -= 1
        else:
          total_spin[i][1] += 1
    else:
      if i % N == 0:
        total_spin[i][1] += 1
      elif i % N == N-1:
        total_spin[i][1] -= 1
      else:
        if (i+1)%N != N-1 and (i//N)*N+i%N < (i+1)//N*N+(i+1)%N:
          total_spin[i][1] += 1
        else:
          total_spin[i][1] -= 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1

  return priority_total




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      if total_spin[i*N+j][0] > 0:
        priorities[i*N+j] = [-total_spin[i*N+j][1], -total_spin[i*N+j][0]]
      else:
        priorities[i*N+j] = [total_spin[i*N+j][1], -total_spin[i*N+j][0]]
  
  return priorities.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(J[k, site_nbr][j] for k in range(4))
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return [list(row) for row in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.1938828703703704}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if all(J[k,site_nbr][j] > 0 for k, site_nbr in zip(range(4), site_nbrs)):
        total_spin -= 1
      elif any(J[k,site_nbr][j] < 0 for k, site_nbr in zip(range(4), site_nbrs)):
        total_spin += 1
      
      priorities[i*N+j][0] = total_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i, j in itertools.product(range(N), range(N)):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      priority_total[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return priority_total.reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priority_total = np.zeros((N**2, 2))
        
        for k in range(3):
          site = (i + ((k-1)%2 - 1)) % N
          
          if h[site][j] > 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
        
        return priority_total.reshape(-1,2)
  
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.array([0, 0])
      if h[i][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      priority_total[i*N+j] = total_spin
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.0015754629629629625}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return total_spin.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return priority_total.reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0,0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1

    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return [[priority_total[i][0], -priority_total[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.12185632716049376}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return total_spin + priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1,2)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N for i in range(N**2)]
  spin_priorities = []
  for i in range(N**2):
    total_energy = h[site_nbrs[i]][i%N]
    if J[0][site_nbrs[i]][i%N] > 0:
      total_energy += 1
      total_spin[i][1] -= 1
    else:
      total_energy -= 1
      total_spin[i][1] += 1
    spin_priorities.append([-total_energy, -total_energy])
  return spin_priorities




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2), dtype=int)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i//N][i%N][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i//N][i%N][1] -= 1
    else:
      total_spin[i//N][i%N][1] += 1
  return [(total_spin[i][j][0], -total_spin[i][j][1]) for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.0015754629629629625}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  priorities = np.zeros((N2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N**2
  priorities = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
        priorities[i*N+j][0] += total_spin[0]
        priorities[i*N+j][1] -= total_spin[1]
  return(priorities)




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1

  return priority_total




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1

  return priority_total




#score: {'data2D.txt': -0.0015921296296296302}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin.reshape(-1, 2).T.flatten().reshape(N**2, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1

  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  return total_spin.reshape(-1, 2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  return total_spin




#score: {'data2D.txt': -0.005720524691358024}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i%N*N+i//N][0] += 1
      priority_total[i%N*N+i//N][1] -= 1
    else:
      priority_total[i%N*N+i//N][0] -= 1
      priority_total[i%N*N+i//N][1] += 1

  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return [row for row in priorities]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 0.0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      total_spin = [0.0, 0.0]
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[1] += 1
        
      priorities[i*N+j] = [-total_spin[1], -total_spin[0]]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1

  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
  for k in range(3):
    site = (i + ((k - 1) % 2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i * N + j][0] += 1
      total_spin[i * N + j][1] -= 1
    else:
      total_spin[i * N + j][0] -= 1
      total_spin[i * N + j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(2):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(4):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j][0] += 1
      priorities[i*N+j][1] -= 1
    else:
      priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total=np.zeros((N*N,2))
  for k in range(4):
    site_nbr = (k % 2) 
    total_spin = np.zeros((N*N,2)) 
    for i in range(N):
      for j in range(N):  
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
    for i in range(N**2):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for k in range(2):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return [total_spin[i*N+j].tolist() for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  
  site_nbr = (i + ((k-1)%2 - 1)) % N
  total_spin += h[site_nbr][j]
  
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = np.zeros((N*N, 2))
      for k in range(4):
        site_nbr = (k % 2) 
        total_spin = np.zeros((N*N,2)) 
        for i in range(N):
          for j in range(N):  
            site_nbr = (i + ((j-1)%2 - 1)) % N
            total_spin[i*N+j][0] += h[site_nbr][j]
            if h[i][j] > 0:
              total_spin[i*N+j][1] -= 1
            else:
              total_spin[i*N+j][1] += 1
        for i in range(N**2):
          site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
          if h[site_nbr][i%N] > 0:
            priority_total[i][0] += 1
            priority_total[i][1] -= 1
          else:
            priority_total[i][0] -= 1
        return(priority_total)
  return(total_spin)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = [0, 0]
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
  
  return [[total_spin[0], -total_spin[1]] for total_spin in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (site_nbr + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.0008128086419753088}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priority_total = [total_spin[i][0]+h[site_nbr][i%N], total_spin[i][1]-1]
    else:
      priority_total = [total_spin[i][0]-h[site_nbr][i%N], total_spin[i][1]+1]

    return [[priority_total[0], -priority_total[1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.19698256172839457}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return total_spin




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  site_nbr = np.zeros(N**2, dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr[i*N+j] = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr[i*N+j]][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      
  return total_spin.tolist()




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[1] += 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = -total_spin[1]
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[1] -= 1
        else:
          total_spin[1] += 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = -total_spin[1]
  return(priority_total)




#score: {'data2D.txt': -0.0005171296296296299}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0 if not h[site_nbr][j] else 1
      priority_total[i*N+j][0] += total_spin
      priority_total[i*N+j][1] -= 2*total_spin - 1
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priority_total = np.array([0,0])
    for k in range(3):
      if h[site_nbr][(k-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
    return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1

  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  total_spin = np.zeros((N**2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    else:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1

  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(2):
    for i in range(N**2):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0, 0]
    total_spin[0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.19699490740740688}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] = total_spin
      priority_total[i*N+j][1] = -total_spin
  return priority_total




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.10113657407407417}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for k in range(2):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i][j][0] += 1
    else:
      total_spin[i][j][0] -= 1

  return priority_total.flatten().reshape((N*N,2))




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  return total_spin.astype(int).tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  prior = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        prior[i*N+j][0] += 1
        prior[i*N+j][1] -= 1
      else:
        prior[i*N+j][0] -= 1
  return prior

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        prior[i*N+j][0] += 1
        prior[i*N+j][1] -= 1
      else:
        prior[i*N+j][0] -= 1
  return prior

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      prior[i][0] += 1
      prior[i][1] -= 1
    else:
      prior[i][0] -= 1
  return prio




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = [[0,0] for _ in range(N*N)]
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
      priority_total[i*N+j][1] -= 1
    else:
      total_spin[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
  priority_total = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
  priority_total = np.zeros((N**2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.1709594135802464}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_list = [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]
  
  return priority_list




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.18063472222222168}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i*N+j][0] += 1
      else:
        total_spin[i*N+j][0] -= 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))
  
  # Calculate the total spin at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  # Calculate the priority for each site
  priority_total = np.zeros((N2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total.astype(int).tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = [[0,0] for _ in range(N2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return [list(i) for i in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for k in range(N):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
      else:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
        
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
  
  for i in range(N ** 2):
    site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  for i in range(N):
    k = 0
    while k < N:
      site = (i + ((k - 1) % 2 - 1)) % N
      if h[site][k] > 0:
        total_spin[i * N + k][0] += 1
        total_spin[i * N + k][1] -= 1
      else:
        total_spin[i * N + k][0] -= 1
        total_spin[i * N + k][1] += 1
      k += 1
  
  return [[total_spin[i][0], -total_spin[i][1]] for i in range(N ** 2)]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
      
  return [[total_spin[i][0],-total_spin[i][1]] for i in range(N**2)]




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j],0]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
      priority_total[i*N+j][0] += 1 - total_spin[i][j][1]
      priority_total[i*N+j][1] = -priority_total[i*N+j][0]
  
  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for k in range(2):
    for i in range(N):
      for j in range(N):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
        else:
          total_spin[i*N+j][0] -= 1

  return total_spin.flatten().reshape(-1, 2)




#score: {'data2D.txt': -0.00019984567901234573}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][1] += 1
      else:
        total_spin[i][1] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(2):
    for i in range(N**2):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  return total_spin.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    site_nbr = (i + ((0)%2 - 1)) % N
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
        
  for k in range(2):
    site = (i + ((k)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][0] += 1
    else:
      total_spin[i*N+j][0] -= 1
  
  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for k in range(4):
    site_nbr = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k,i,j]
        if J[k,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return priority_total




#score: {'data2D.txt': -0.29886373456790055}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  return priority_total




#score: {'data2D.txt': 0.15188657407407408}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for k in range(4):
    site_nbr = (k % 2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k, i, j]
        if J[k, i, j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  
  priority_total = [[0, 0] for _ in range(N*N)]
  
  for k in range(3):
    site_nbr = (k % 2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k, i, j]
        if J[k, i, j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  
  return priority_total




#score: {'data2D.txt': -0.07390354938271596}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  for k in range(4):
    site_nbr = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin = J[k,i,j]
        if J[k,i,j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
  return(priority_total)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += J[0,i,j]
      if J[0,i,j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site_nbr = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k+1,i,j]
        if J[k+1,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.22957762345679017}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for k in range(4):
    site_nbr = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k,i,j]
        if J[k,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  
  return(total_spin)




#score: {'data2D.txt': -0.3262100308641966}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  for k in range(4):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if J[k][site_nbr][i]%N > 0:
        priority_total[i*N+int(k/2)][0] += 1
        priority_total[i*N+int(k/2)][1] -= 1
      else:
        priority_total[i*N+int(k/2)][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        total_spin -= 1
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
  return([list(x) for x in priority_total])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k,i,j]
        if J[k,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((3-1)%2 - 1)) % N
      total_spin[i*N+j][0] += J[3,i,j]
      if J[3,i,j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  return(priority_total)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total = np.zeros((N*N, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        total[i*N+j][0] -= 1
        total[i*N+j][1] += 1
      else:
        total_spin -= 1
        total[i*N+j][0] += 1
        total[i*N+j][1] -= 1
  return([list(x) for x in total])




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.225443981481481}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
  return(total_spin)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        total[i*N+j][0] += 1
        total[i*N+j][1] -= 1
      else:
        total[i*N+j][0] -= 1
        total[i*N+j][1] += 1
  return([list(x) for x in total])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
      
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.00019984567901234573}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][1] += 1
      else:
        total_spin[i][1] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.24355478395061686}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N*N,2))
  
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
  
  return total_spin.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N - 1) // N * 2)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return([list(x) for x in priority_total])




#score: {'data2D.txt': 0.14486033950617302}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k][site_nbr][i%N]
        if J[k][site_nbr][i%N] > 0:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[site_nbr][j] > 0:
          priority_total[i*N+j][0] -= 1
          priority_total[i*N+j][1] += 1
        else:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
  return([list(x) for x in priority_total])




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0, 0] for _ in range(N*N)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return([list(x) for x in priority_total])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  return([list(x) for x in priority_total])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total = np.zeros((N*N, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin += 1
        total[i*N+j][0] -= 1
        total[i*N+j][1] += 1
      else:
        total_spin -= 1
        total[i*N+j][0] += 1
        total[i*N+j][1] -= 1
  return([list(x) for x in total])




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(J[k][site_nbr]*J[k][(i + ((k-1)%2 - 1)) % N] for k in range(3))
      if h[site_nbr][j] > 0:
        total[i*N+j][0] += 1
        total[i*N+j][1] -= 1
      else:
        total[i*N+j][0] -= 1
        total[i*N+j][1] += 1
  return([list(x) for x in total])




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      if h[site_nbr][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
      priority_total[i*N+j][0] = total_spin[0]
      priority_total[i*N+j][1] = -total_spin[1]
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = [0, 0]
    total_spin[0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return priority_total




#score: {'data2D.txt': 0.06642206790123462}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  total_spin = np.zeros((N,N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if abs(k-1) == 1: # left neighbor
          j_nbr = max(0, min(N-1, j-1))
        elif k == 2: # top neighbor
          i_nbr = max(0, min(N-1, i-1))
          j_nbr = j
        else: # right or bottom neighbor
          i_nbr = i
          j_nbr = min(max(0, j+1), N-1)
        total_spin[i][j_nbr][0] += h[site_nbr][j_nbr]
        if h[i][j] > 0:
          total_spin[i][j_nbr][1] -= 1
        else:
          total_spin[i][j_nbr][1] += 1
      
      priority_total[i*N+j][0] = total_spin[i][j][0]
      priority_total[i*N+j][1] = -total_spin[i][j][1]
  
  return(priority_total)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.00915231481481481}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priorities.append([-total_spin, 1 - np.abs(total_spin)])
      else:
        priorities.append([total_spin, np.abs(total_spin) + 1])
  return np.array(priorities).reshape(-1,2)




#score: {'data2D.txt': -0.0015723765432098763}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
  
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
  
  return [[a, -b] for a, b in total_spin]




#score: {'data2D.txt': -0.06553256172839507}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority_total = np.zeros((N*N, 2))
  
  for k in range(4):
    site_nbr = (k % 2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        priority_total[i*N+j][0] += J[k, i, j]
        if J[k, i, j] > 0:
          priority_total[i*N+j][0] += 1
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][0] -= 1
  
  return priority_total.tolist()




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k, i, j]
        if J[k, i, j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  
  return [[x[0], N - x[1]] for x in total_spin]




#score: {'data2D.txt': 0.24355478395061686}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(4):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        else:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  # Calculate total spin
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  # Calculate interaction spin
  for k in range(4):
    site = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j+site)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k,i,j]
        if J[k,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  
  # Calculate priority
  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total[i*N+j][0] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [np.array(p) for p in priority_total]




#score: {'data2D.txt': 0.19649398148148145}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_energy = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      for k in range(3):
        site_nbr = (i + ((j + k % 2 - 1) % 2) - 1) % N
        if h[site_nbr][j] > 0:
          site_energy[i * N + j][0] += J[k, i, j]
          site_energy[i * N + j][1] -= 1
        else:
          site_energy[i * N + j][0] -= J[k, i, j]
          site_energy[i * N + j][1] += 1
  return [[site_energy[i * N + j][0], -site_energy[i * N + j][1]] for i in range(N) for j in range(N)]




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += J[0,i,j]
      if J[0,i,j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for k in range(3):
    site_nbr = (k%2 - 1)
    for i in range(N):
      for j in range(N):
        site = (i + ((j+site_nbr)%2 - 1)) % N
        total_spin[i*N+j][0] += J[k+1,i,j]
        if J[k+1,i,j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    if h[i//N][i%N] > 0:
      total_spin[i][1] += 1
    else:
      total_spin[i][1] -= 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Compute magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  # Compute priority for each site
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i // N + ((i%N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] += 1
    else:
      total_spin[i][1] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.09580910493827176}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((0)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      if np.abs(total_spin[i][j][1]) < N/2:
        priority_total[i*N+j][1] = 1
      else:
        priority_total[i*N+j][1] = -1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.10065848765432107}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((0)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  site_nbr = (i + ((2)%2 - 1)) % N
  if h[i][site_nbr] > 0:
    total_spin[i][j][0] += 1
    total_spin[i][j][1] -= 1
  else:
    total_spin[i][j][0] -= 1
    total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total = [[0, 0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([J[k][i*N+j] for k in range(4)])
      if h[i][j] > 0:
        priority_total = [total_spin+1, -total_spin-1]
      else:
        priority_total = [-total_spin-1, total_spin+1]
      return ([list(x) for x in total])




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  return(priority_total)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  priority_total = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return(priority_total)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  priority_total = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
  
  return(priority_total)




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= total_spin
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.00019984567901234573}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(4):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if h[i][j] > 0:
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][1] += 1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.29432391975308586}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i // N + ((i%N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] += 1
    else:
      total_spin[i][1] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    total_spin = [0, 0]
    site_nbr = (i // N + ((i % N - 1) % 2 - 1)) % N
    total_spin[0] += h[site_nbr][i % N]
    if h[i // N][i % N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  site_nbrs = []
  
  for i in range(N):
    temp = []
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
    site_nbrs.append(temp)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return(total_spin)




#score: {'data2D.txt': 0.2700470679012342}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priority_total[i*N+j][0] = -total_spin
      if np.abs(total_spin) < N/2:
        priority_total[i*N+j][1] = 1
      else:
        priority_total[i*N+j][1] = -1
  return priority_total.flatten().reshape(-1, 2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  site_nbrs = []
  
  for i in range(N):
    temp = []
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
    site_nbrs.append(temp)
  
  for k in range(3):
    for i in range(N):
      for j in range(N):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
  
  return(total_spin)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    site_priors.append([-total_spin[i][0], -total_spin[i][1]])
  
  return site_priors




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[-np.inf,-np.inf] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if total_spin > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
      
  return [list(x) for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] += 1
    else:
      total_spin[i][1] -= 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    spin_sum = total_spin[i][0]
    if h[i//N][i%N] > 0:
      spin_sum += 1
    else:
      spin_sum -= 1
    
    site_priors.append([-spin_sum, -total_spin[i][1]])
  
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][0] = -total_spin[i*N+j][0]
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][0] = 1 - np.abs(total_spin[i*N+j][1])
        if h[i][j] > 0:
          priority_total[i*N+j][1] -= 1
        else:
          priority_total[i*N+j][1] += 1

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if total_spin[i*N+j][1] > N//2:
        priority_total[i*N+j] = [1, -abs(total_spin[i*N+j][0])]
      elif total_spin[i*N+j][1] < -N//2:
        priority_total[i*N+j] = [-1, abs(total_spin[i*N+j][0])]
      else:
        if total_spin[i*N+j][0] > 0:
          priority_total[i*N+j] = [1, -abs(total_spin[i*N+j][0])]
        else:
          priority_total[i*N+j] = [-1, abs(total_spin[i*N+j][0])]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.24355478395061686}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.24355478395061686}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1

  priority_total = [[0, 0] for _ in range(N ** 2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1

  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i * N + j][0] = -total_spin[i * N + j][0]
        priority_total[i * N + j][1] = -total_spin[i * N + j][1]
      else:
        priority_total[i * N + j][0] = total_spin[i * N + j][0]
        priority_total[i * N + j][1] = -total_spin[i * N + j][1]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [h[site_nbr][j], 0]
      if h[i][j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[0] += 1
        else:
          total_spin[0] -= 1
      priority_total[i*N+j][0] = -total_spin[0]
      if abs(total_spin[1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[1])
  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for i in range(N**2):
    if total_spin[i][0] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    elif total_spin[i][0] < 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  return priority_total.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])

  return site_priors




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return total_spin




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] += 1
        else:
          total_spin[i*N+j][0] -= 1
        
  return([total_spin[i*N+j] for i in range(N) for j in range(N)])




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.24355478395061686}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][0] += total_spin[i*N+j][0]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.2423634259259259}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  J4xN2 = np.reshape(J,(4,N2))
  total_spin = [[0,0] for _ in range(N2)]
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J4xN2[k][i] > 0:
        total_spin[i][0] += 1
        total_spin[i][1] -= 1
      else:
        total_spin[i][0] -= 1
        total_spin[i][1] += 1
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    priority_total[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
      
  for k in range(2):
    site = (i // N + ((k-1)%2 - 1)) % N
    if h[site][i%N] > 0:
      priority_total[i][1] -= 1
    else:
      priority_total[i][1] += 1
      
  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.33539675925925827}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  for k in range(2):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      for i in range(N):
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
    else:
      for i in range(N):
        total_spin[i][j][0] -= 1
  return total_spin.reshape(-1,2).tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
  
  return [list(x) for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos,p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg,-p_pos])
    else:
      site_priors.append([p_pos,p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.010183179012345679}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N ** 2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  priority_total = [[0, 0] for _ in range(N ** 2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  for i in range(N**2):
    if h[int(i//N)][i%N] > 0:
      priority_total[i][0] = -total_spin[i][0]
      priority_total[i][1] = -total_spin[i][1]
    else:
      priority_total[i][0] = total_spin[i][0]
      priority_total[i][1] = -total_spin[i][1]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N*N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(x) for x in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
  
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.018035648148148144}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      for k in range(4):
        if k == 0:
          total_spin[i*N+j][0] += h[site_nbr][j]
          if h[i][j] > 0:
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][1] += 1
        elif k == 1 and i > 0 and j < N-1:
          site = (i - 1 + ((j+1)%2 - 1)) % N
          if h[site][j+1] > 0:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
          else:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
        elif k == 2 and j > 0:
          site = (i + ((j-1)%2 - 1)) % N
          if h[site][j-1] > 0:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
          else:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
        elif k == 3 and i < N-1:
          site = (i + 1 + ((j-1)%2 - 1)) % N
          if h[site][j-1] > 0:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
          else:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
        
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    
    if p_pos > p_neg + 1e-6:
      site_priors.append([p_pos, -p_neg])
    elif p_neg > p_pos + 1e-6:
      site_priors.append([-p_pos, p_neg])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([-p_neg,p_pos])
    elif p_pos < p_neg:
      site_priors.append([p_pos,-p_neg])
    else:
      site_priors.append([p_pos,p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for i in range(N**2):
    if total_spin[i][0] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    elif total_spin[i][0] < 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1

  return priority_total.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  # Calculate priority for each site based on the total spin and interaction with neighbors
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3344902777777768}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  for k in range(N):
    site = (k + ((j-1)%2 - 1)) % N
    if h[site][i] > 0:
      total_spin[k*N+i][0] += 1
      total_spin[k*N+i][1] -= 1
    else:
      total_spin[k*N+i][0] -= 1
      total_spin[k*N+i][1] += 1
      
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': -0.012033796296296294}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][0] > 0:
        for j in range(N):
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      else:
        for j in range(N):
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if total_spin[i*N+j][0] > N//2:
        priority_total[i*N+j] = [1, -1]
      elif total_spin[i*N+j][0] < -N//2:
        priority_total[i*N+j] = [-1, 1]
      else:
        if abs(total_spin[i*N+j][1]) > N//2:
          priority_total[i*N+j] = [-np.sign(total_spin[i*N+j][1]), np.abs(total_spin[i*N+j][1])]
        else:
          priority_total[i*N+j] = [0, 0]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.024862499999999996}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    if abs(total_spin[i][1]) > N//2:
      priority_total[i][1] = -np.sign(total_spin[i][1])
    else:
      priority_total[i][1] = 1 - np.abs(total_spin[i][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.000977006172839506}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][0]) > N//2:
        priority_total[i*N+j][0] = -np.sign(total_spin[i*N+j][0])
      else:
        priority_total[i*N+j][0] = 1 - np.abs(total_spin[i*N+j][0])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1

  for i in range(N**2):
    if total_spin[i][0] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    elif total_spin[i][0] < 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  return [list(t) for t in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for k in range(2):
    for i in range(N**2):
      if total_spin[i][0] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      elif total_spin[i][0] < 0:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1

  return priority_total.tolist()




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([-p_neg, p_pos])
    elif p_pos < p_neg:
      site_priors.append([p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg and h[i//N][i%N]>0:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg and h[i//N][i%N]<0:
      site_priors.append([-p_neg, -p_pos])
    else:
      if np.random.rand() > 0.5:
        site_priors.append([p_pos, p_neg])
      else:
        site_priors.append([-p_neg, -p_pos])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  priority = []
  for i in range(N2):
    spin_sum = total_spin[i][0]
    mag_sum = total_spin[i][1]
    
    if spin_sum > mag_sum:
      priority.append([-1, 1])
    elif spin_sum < mag_sum:
      priority.append([1, -1])
    else:
      if h[i//N][i%N] > 0:
        priority.append([-1, 1])
      else:
        priority.append([1, -1])
  
  return priority




#score: {'data2D.txt': -0.24656435185185172}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))
  
  for i in range(N):
    site_nbr = (i + ((i+1)%2 - 1)) % N
    total_spin[i*N:(i+1)*N, 0] += h[site_nbr]
    total_spin[i*N:(i+1)*N, 1][h[i]>0] -= 1
  
  return [list(x) for x in total_spin.reshape(N2, 2)]




#score: {'data2D.txt': 0.2554723765432095}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      for j in range(N):
        total_spin[i*N+j][1] -= 1
    else:
      for j in range(N):
        total_spin[i*N+j][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site = (i//N, i%N)
    neighbor = ((site[0]+((site[1]-1)%2 - 1)) % N, i%N)
    if np.abs(total_spin[i][0]) > np.abs(total_spin[i][1]):
      total_spin[i][0] += J[neighbor][i]
      if h[neighbor[0]][neighbor[1]] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
    
    for k in range(3):
      site = (i // N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
        
  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if abs(p_pos) > abs(p_neg):
      site_priors.append([p_pos, p_neg])
    elif abs(p_pos) < abs(p_neg):
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, 1])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -1])
    else:
      site_priors.append([p_pos/2, 0.5])
      
  return site_priors




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([-p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([p_pos, -p_neg])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  # Calculate magnetism at each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  # Calculate interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    
    if h[i//N][i%N]>0 and p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif h[i//N][i%N]<0 and p_neg > p_pos:
      site_priors.append([-p_neg, -p_pos])
    else:
      if np.random.rand() > 0.5:
        site_priors.append([p_pos, p_neg])
      else:
        site_priors.append([-p_neg, -p_pos])
        
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if h[i//N][i%N] > 0:
      if p_pos >= p_neg:
        site_priors.append([p_pos, p_neg])
      else:
        site_priors.append([-p_neg, -p_pos])
    elif h[i//N][i%N] < 0:
      if p_pos <= p_neg:
        site_priors.append([-p_neg, -p_pos])
      else:
        site_priors.append([p_pos, p_neg])
    else:
      if np.random.rand() > 0.5:
        if p_pos >= p_neg:
          site_priors.append([p_pos, p_neg])
        else:
          site_priors.append([-p_neg, -p_pos])
      else:
        if p_pos <= p_neg:
          site_priors.append([-p_neg, -p_pos])
        else:
          site_priors.append([p_pos, p_neg])
  
  return site_priors




#score: {'data2D.txt': 0.21111373456790125}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
      
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][i % N] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
      
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, -p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, p_pos])
    else:
      site_priors.append([p_pos, p_neg])

  return site_priors




#score: {'data2D.txt': -0.26079182098765397}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      for j in range(N):
        total_spin[i*N+j][1] -= 1
    else:
      for j in range(N):
        total_spin[i*N+j][1] += 1

  priorities = np.zeros((N2, 2))
  for i in range(N2):
    if total_spin[i][0] > total_spin[i][1]:
      priorities[i][0] = 1
      priorities[i][1] = -1
    elif total_spin[i][0] < total_spin[i][1]:
      priorities[i][0] = -1
      priorities[i][1] = 1
    else:
      if total_spin[i][0] > 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      elif total_spin[i][0] < 0:
        priorities[i][0] = -1
        priorities[i][1] = 1

  return priorities.tolist()




#score: {'data2D.txt': 0.2554723765432095}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      for j in range(N):
        total_spin[i*N+j][1] -= 1
    else:
      for j in range(N):
        total_spin[i*N+j][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.32926188271604845}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
        
  for i in range(N2):
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if h[site_nbr][i % N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
      
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      for j in range(N):
        total_spin[i*N+j][1] -= 1
    else:
      for j in range(N):
        total_spin[i*N+j][1] += 1
        
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.31004768518518444}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N//2+1):
      k = (i + j) % N
      site_nbr = (k + ((j-1)%2 - 1)) % N
      total_spin[k*N+(N-j-1)][0] += h[site_nbr][N-j-1]
      if h[i][N-j-1] > 0:
        total_spin[k*N+(N-j-1)][1] -= 1
      else:
        total_spin[k*N+(N-j-1)][1] += 1

  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])

  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    
    if p_pos > p_neg:
      site_priors.append([p_pos,p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg,-p_pos])
    else:
      if np.random.rand() < 0.5:
        site_priors.append([p_pos,p_neg])
      else:
        site_priors.append([-p_neg,-p_pos])
  
  return site_priors




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([-p_neg, p_pos])
    elif p_pos < p_neg:
      site_priors.append([p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])

  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  site_priors = []
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N**2):
    site_priors.append([-total_spin[i][0], -total_spin[i][1]])
    
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    spin_sum = total_spin[i][0]
    if h[i//N][i%N] > 0:
      spin_sum += 1
    else:
      spin_sum -= 1
    
    site_priors.append([-spin_sum - total_spin[i][1], -total_spin[i][1]])
    
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N*N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N//2):
      site = (i + ((2*j+1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i*N+(N-1-j)][0] += 1
        total_spin[i*N+(N-1-j)][1] -= 1
      else:
        total_spin[i*N+(N-1-j)][0] -= 1
        total_spin[i*N+(N-1-j)][1] += 1
        
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': 0.09660972222222236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][1] -= 1
    else:
      total_spin[i][1] += 1
      
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1

  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([-p_neg, p_pos])
    elif p_pos < p_neg:
      site_priors.append([p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])

  return site_priors




#score: {'data2D.txt': -0.0017569444444444442}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    site_nbr = (i + ((1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    site_nbr = (i + ((2)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    site_nbr = (i + ((3)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    priority_total[i*N+i][0] = -total_spin[i*N+i][0]
    if h[i][i] > 0:
      priority_total[i*N+i][1] = 1 - np.abs(total_spin[i*N+i][1])
    else:
      priority_total[i*N+i][1] = 1 + np.abs(total_spin[i*N+i][1])

  for i in range(N):
    for j in range(i+1,N):
      site_nbr = (j + ((2)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(i+1,N):
      site_nbr = (j + ((3)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    priority_total[i*N+i][0] = -total_spin[i*N+i][0]
    if h[i][i] > 0:
      priority_total[i*N+i][1] = 1 - np.abs(total_spin[i*N+i][1])
    else:
      priority_total[i*N+i][1] = 1 + np.abs(total_spin[i*N+i][1])

  for i in range(N):
    for j in range(i+1,N):
      site_nbr = (j + ((2)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(i+1,N):
      site_nbr = (j + ((3)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    priority_total[i*N+i][0] = -total_spin[i*N+i][0]
    if h[i][i] > 0:
      priority_total[i*N+i][1] = 1 - np.abs(total_spin[i*N+i][1])
    else:
      priority_total[i*N+i][1] = 1 + np.abs(total_spin[i*N+i][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.24667669753086374}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N,2))
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][0]) > abs(total_spin[i*N+j][1]):
        priority_total[i*N+j][0] = -total_spin[i*N+j][0]
        priority_total[i*N+j][1] = 1
      else:
        priority_total[i*N+j][0] = 1 - np.abs(total_spin[i*N+j][0])
        priority_total[i*N+j][1] = -total_spin[i*N+j][0]

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      neighbor_sum = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          neighbor_sum -= 1
        else:
          neighbor_sum += 1
      total_spin[i*N+j][0] += h[i][j] + neighbor_sum
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] += 1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for k in range(4):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][1] += 2

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 2
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 2
        priority_total[i*N+j][1] -= 1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.21111373456790125}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
      
  priority_total = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
      
  return [[x[0], x[1]] for x in total_spin]




#score: {'data2D.txt': 0.10283101851851861}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%N) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        if h[site][j] > 0:
          if k == 0:  
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
          else:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
        
        site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          if k == 0:  
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] -= 1
        
  return([list(x) for x in total_spin])




#score: {'data2D.txt': 0.21340848765432097}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
  
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.001024537037037037}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
  for i in range(N):
    site = (i % 2) - 1
    for j in range(N):
      if h[site][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      
  return([list(x) for x in total_spin])




#score: {'data2D.txt': -0.05184367283950619}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, (j-1)%N, (j+1)%N]
      site_nbr_values = [h[site_nbr][j] for site_nbr in site_nbrs if i != site_nbr and j != (site_nbr % N)]
      total_spin[i][j][0] += np.sum(site_nbr_values)
      if h[i][j] > 0:
        total_spin[i][j][1] -= len([value for value in site_nbr_values if value > 0])
      else:
        total_spin[i][j][1] += len([value for value in site_nbr_values if value < 0])

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][1])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.13437854938271662}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      total_spin[i][j][0] = np.tanh(total_spin[i][j][0])
      if h[i][j] > 0:
        total_spin[i][j][0] -= 0.5
      else:
        total_spin[i][j][0] += 0.5

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] = -total_spin[i][j][0]
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i][j][0])
      else:
        priority_total[i*N+j][0] = total_spin[i][j][0]
        priority_total[i*N+j][1] = np.abs(total_spin[i][j][0])

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i][j][0]
      if total_spin[i][j][1] > N**2/2:
        priority_total[i*N+j][1] = 1
      else:
        priority_total[i*N+j][1] = -1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= total_spin[i][j][0]
        priority_total[i*N+j][1] -= total_spin[i][j][1]
      else:
        priority_total[i*N+j][0] += total_spin[i][j][0]
        priority_total[i*N+j][1] += total_spin[i][j][1]

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': 0.3185220679012338}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for i in range(N**2):
    if total_spin[i][0] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    elif total_spin[i][0] < 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1

  for i in range(N**2):
    site_nbr = (i // N + ((i % N)-1)%2 - 1) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] -= 1
      priority_total[i][1] += 1
    else:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1

  return [list(x) for x in priority_total]




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for k in range(N):
    for j in range(N):
      site_nbr = (k + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[k*N+j][0] += 1
        total_spin[k*N+j][1] -= 1
      else:
        total_spin[k*N+j][0] -= 1
        total_spin[k*N+j][1] += 1

  return total_spin.tolist()




#score: {'data2D.txt': 0.07261929012345687}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  for k in range(2):
    for i in range(N**2):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priority_total[i][0] += 1
        priority_total[i][1] -= 1
      else:
        priority_total[i][0] -= 1
        priority_total[i][1] += 1

  return priority_total.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
  
  return ([list(x) for x in total_spin])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
      
      for k in range(N):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
        
  return([list(x) for x in total_spin])




#score: {'data2D.txt': 0.026790895061728406}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4) for i in range(N)]
  for i in range(N):
    for j in range(N):
      for site_nbr in [(i, j), (j, i)]:
        total_spin[i*N+j][0] += h[site_nbr[0]][site_nbr[1]]
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  site_priors = []
  for i in range(N**2):
    p_pos = -total_spin[i][0]
    p_neg = -total_spin[i][1]
    if p_pos > p_neg:
      site_priors.append([p_pos, p_neg])
    elif p_pos < p_neg:
      site_priors.append([-p_neg, -p_pos])
    else:
      site_priors.append([p_pos, p_neg])
      
  return site_priors




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k - 1) % 2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i * N + j][0] -= 1
          total_spin[i * N + j][1] += 1
        else:
          total_spin[i * N + j][0] += 1
          total_spin[i * N + j][1] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      
  # Compute priorities for each site based on the current spin configuration
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
      else:
        priority_total[i * N + j][0] -= 1
        priority_total[i * N + j][1] += 1
      
  return ([list(x) for x in total_spin])




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priority_total = np.zeros((N2, 2), dtype=int)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1
      else:
        priority_total[i * N + j][0] -= 1
        priority_total[i * N + j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priority_total[i * N + j][0] -= 1
        priority_total[i * N + j][1] += 1
      else:
        priority_total[i * N + j][0] += 1
        priority_total[i * N + j][1] -= 1

  return priority_total.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][1] += 2

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 2
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 2
        priority_total[i*N+j][1] -= 1

  return total_spin.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.17142885802469163}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    site_nbr = (i // N + ((i % N -1) % 2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i][1] += 1
    else:
      total_spin[i][1] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  
  return [list(x) for x in total_spin]




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  total_spin = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1

  return [list(x) for x in total_spin]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1
      else:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1

  # Compute priorities for each site based on the current spin configuration
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i * N + j][0] += 1
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][0] -= 1
        total_spin[i * N + j][1] += 1

  return ([list(x) for x in total_spin])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      total_spin[i * N + j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i * N + j][1] -= 1
      else:
        total_spin[i * N + j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      
  # Compute priorities for each site based on the current spin configuration
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  return ([list(x) for x in total_spin])




#score: {'data2D.txt': 0.006010339506172841}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priority_total = [[0, 0] for _ in range(N2)]
  
  for i in range(N2):
    total_spin = [0, 0]
    
    for j in range(4):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][i//N] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      else:
        total_spin[0] += 1
        total_spin[1] -= 1
    
    for j in range(2):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[i//N][site_nbr] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priority_total[i][0] = total_spin[0]
    priority_total[i][1] = total_spin[1]
  
  return ([list(x) for x in priority_total])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N * N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i // N - 1) % 2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (j % N + ((i - 1) % 2 - 1)) % N
      if h[i][site_nbr] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  # Compute priorities for each site based on the current spin configuration
  priority_total = [[0, 0] for _ in range(N * N)]
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      
  return ([list(x) for x in total_spin])




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1

  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.00014027777777777826}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][1] += 2

  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] -= 2
        priority_total[i*N+j][1] += 1
      else:
        priority_total[i*N+j][0] += 2
        priority_total[i*N+j][1] -= 1

  return np.fliplr(np.flipud(priority_total)).flatten().reshape(-1,2)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0,0] for _ in range(N**2)]
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      total = total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = [[0, 0] for _ in range(N**2)]
  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1

  for i in range(N):
    for j in range(N):
      priority_total[i*N+j][0] = -total_spin[i*N+j][0]
      if abs(total_spin[i*N+j][1]) > N//2:
        priority_total[i*N+j][1] = -np.sign(total_spin[i*N+j][1])
      else:
        priority_total[i*N+j][1] = 1 - np.abs(total_spin[i*N+j][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2), dtype=float)
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    priority_total[i][0] = -total_spin[i][0]
    if abs(total_spin[i][1]) > N//2:
      priority_total[i][1] = -np.sign(total_spin[i][1])
    else:
      priority_total[i][1] = 1 - np.abs(total_spin[i][1])

  return [list(p) for p in priority_total]




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  total_spin = np.zeros((N2, 2), dtype=int)
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  for i in range(N2):
    site = (i//N, i%N)
    neighbor = ((site[0]+((site[1]-1)%2 - 1)) % N, i%N)
    if np.abs(total_spin[i][0]) > np.abs(total_spin[i][1]):
      total_spin[i][0] += J[neighbor][i]
      if h[neighbor[0]][neighbor[1]] > 0:
        total_spin[i][1] -= 1
      else:
        total_spin[i][1] += 1
    
  priorities = [[x[0], -x[1]] for x in total_spin]
  
  return priorities




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.003827006172839506}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.23316527777777776}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k, i, j]
        else:
          total_spin -= J[k, i, j]
      priorities[i*N+j][0] += total_spin
  return(priorities)




#score: {'data2D.txt': -0.3365279320987644}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(2):
    interacting_spins = np.roll(h, -1, axis=i)
    interacting_spins += np.roll(h, 1, axis=i)
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[j*N+j][0] += 1
        priorities[j*N+j][1] -= 1
      else:
        priorities[j*N+j][0] -= 1
  for i in range(N):
    interacting_spins = np.roll(h, -1, axis=1)
    interacting_spins += np.roll(h, 1, axis=1)
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][site_nbr]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.11524583333333345}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    
    for j in range(N):
      total_spin = 0
      
      if J[3,i,j] > 0:
        total_spin += J[3,i,j]
      else:
        total_spin -= J[3,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.055820524691358044}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.004284722222222223}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      total_spin = h[(i + ((j-1)%2 - 1)) % N][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0012121913580246915}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1

  for k in range(4):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j][0] -= 1
    else:
      priorities[i*N+j][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.03237515432098765}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      for k in site_nbrs:
        if J[0,i,j] + h[k,j] > 0:
          priorities[i,j] += 1
        elif J[0,i,j] + h[k,j] < 0:
          priorities[i,j] -= 1
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if J[0,i,j] > 0:
        total_spin += J[0,i,j]
      else:
        total_spin -= J[0,i,j]
      
      if J[1,i,j] > 0:
        total_spin += J[1,i,(i+(j+1)%2 - 1)] % N
      else:
        total_spin -= J[1,i,(i+(j+1)%2 - 1)] % N
      
      if J[2,i,j] > 0:
        total_spin += J[2,i,(i+(j-1)%2 - 1)] % N
      else:
        total_spin -= J[2,i,(i+(j-1)%2 - 1)] % N
      
      if J[3,i,j] > 0:
        total_spin += J[3,i,j]
      else:
        total_spin -= J[3,i,j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.016941512345679012}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      # Calculate the priority based on the total spin
      if total_spin > 0:
        priorities[i*N+j,0] += total_spin
        priorities[i*N+j,1] -= total_spin
      else:
        priorities[i*N+j,0] -= total_spin
        
  return(priorities)




#score: {'data2D.txt': -0.004144598765432098}
#island_id: 3
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
      else:
        if h[i][j] > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      total_spin = np.sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1 * (np.any(h[site_nbrs] > 0) or total_spin > 0)
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1 * (np.any(h[site_nbrs] < 0) or total_spin < 0)
  return priorities




#score: {'data2D.txt': -0.29449891975308595}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.array([[0.0 for _ in range(2)] for _ in range(N**2)])
  interacting_spins = [np.zeros((N)) for _ in range(N)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  
  # Calculate the interaction term for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] -= J[0,i,j]*h[site_nbr][j]
        priorities[i*N+j][1] += J[0,i,j]*h[site_nbr][j]
      else:
        priorities[i*N+j][0] += J[0,i,j]*h[site_nbr][j]
        priorities[i*N+j][1] -= J[0,i,j]*h[site_nbr][j]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i]
    
    if h[i][i] > 0:
      priorities[i*N+i][0] -= J[3,i,i]*h[site_nbr][i]
      priorities[i*N+i][1] += J[3,i,i]*h[site_nbr][i]
    else:
      priorities[i*N+i][0] += J[3,i,i]*h[site_nbr][i]
      priorities[i*N+i][1] -= J[3,i,i]*h[site_nbr][i]
  
  return priorities




#score: {'data2D.txt': -0.31254922839506194}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += -0.5*J[k,i,j]*interacting_spins[k,site_nbr,j]
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + x + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priorities[i*N+j][0] += 3
        priorities[i*N+j][1] -= 2
      else:
        priorities[i*N+j][0] -= 2
        priorities[i*N+j][1] += 3
  return priorities




#score: {'data2D.txt': -0.28308811728395034}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site_nbr = (i + ((N-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] -= J[3,i,j]*h[site_nbr][j]
        priorities[i*N+j][1] += J[3,i,j]*h[site_nbr][j]
      else:
        priorities[i*N+j][0] += J[3,i,j]*h[site_nbr][j]
        priorities[i*N+j][1] -= J[3,i,j]*h[site_nbr][j]
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i]
    
    if h[i][i] > 0:
      priorities[i*N+i][0] -= J[3,i,i]*h[site_nbr][i]
      priorities[i*N+i][1] += J[3,i,i]*h[site_nbr][i]
    else:
      priorities[i*N+i][0] += J[3,i,i]*h[site_nbr][i]
      priorities[i*N+i][1] -= J[3,i,i]*h[site_nbr][i]
  
  return priorities




#score: {'data2D.txt': -0.28881250000000014}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(4):
    interacting_spins[i] = np.roll(h, -i%2, axis=i%2)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += -0.5*J[k,i,j]*(interacting_spins[k,site_nbr,j]+h[site_nbr][j])
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          priorities[i*N+j][1] -= 0.5*J[k,i,j]*(interacting_spins[k,site_nbr,j]+h[site_nbr][j])
        else:
          priorities[i*N+j][1] += 0.5

  return(priorities)




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = [0]*N*N
  for i in range(N):
    for j in range(N):
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + x + ((j+y-1)%2 - 1)) % N
          total_spin[i*N+j] += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return priorities




#score: {'data2D.txt': -0.004354475308641975}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin
      else:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
  
  return priorities




#score: {'data2D.txt': -0.0031433641975308645}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin * (1 + abs(total_spin))
        priorities[i*N+j][1] += total_spin * (1 + abs(total_spin))
      else:
        priorities[i*N+j][0] += total_spin * (1 - abs(total_spin))
        priorities[i*N+j][1] -= total_spin * (1 - abs(total_spin))
  
  return priorities




#score: {'data2D.txt': -0.2207300925925926}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0, i//N, i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin

  return priorities




#score: {'data2D.txt': -0.3352223765432089}
#island_id: 0
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin
      else:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
  
  # Calculate the priority for each site
  for i in range(N**2):
    if h[(i//N)%N][(i%N)] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return priorities




#score: {'data2D.txt': -0.2911662037037038}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] += total_spin
  return priorities




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # Iterate over each site and add contributions from magnetism and nearest neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      
  return priorities




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += h[site_nbr][j]
        else:
          total_spin -= h[site_nbr][j]
      priorities[i*N+j][0] += np.sum(h.flatten() == h[site_nbr][j])
      priorities[i*N+j][1] -= (2 if total_spin > 0 else -2)
  return priorities




#score: {'data2D.txt': -0.14831990740740747}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and h[neighbor_i][j] > 0:
          priorities[i*N+j][0] += 2
          priorities[i*N+j][1] -= 2
        elif J[k, i, j] < 0 and h[neighbor_i][j] < 0:
          priorities[i*N+j][0] += 2
          priorities[i*N+j][1] -= 2
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': -0.53650787037037}
#island_id: None
#version_generated: None
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((4,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(4):
        priorities[i,j] += -0.5*J[k,i,j]*interacting_spins[k,i,j]
  priorities = np.array([priorities.flatten(), np.zeros(N**2)]).T
  return(priorities)




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': -0.016941512345679012}
#island_id: 3
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      # Calculate the priority based on the total spin
      if total_spin > 0:
        priorities[i*N+j,0] += total_spin
        priorities[i*N+j,1] -= total_spin
      else:
        priorities[i*N+j,0] -= total_spin
      
  return(priorities)




#score: {'data2D.txt': -0.016941512345679012}
#island_id: 3
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      # Calculate the priority based on the total spin
      if total_spin > 0:
        priorities[i*N+j,0] += total_spin
        priorities[i*N+j,1] -= total_spin
      else:
        priorities[i*N+j,0] -= total_spin
        
  return(priorities)




#score: {'data2D.txt': -0.10568101851851858}
#island_id: 3
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        
      total_spin += h[site_nbr][j]
      
      site_spin = h[i][j]
      
      for k in range(4):
        if i != (k-1)%N and J[(k-1)%2,i,k] > 0:
          site_spin -= J[(k-1)%2,i,k]
        elif i != ((k+1)%N) and J[(k+1)%2,i,k] > 0:
          site_spin += J[(k+1)%2,i,k]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      # Calculate the priority based on the total spin and site spin
      if total_spin + site_spin > 0:
        priorities[i*N+j,0] += total_spin + site_spin
        priorities[i*N+j,1] -= total_spin + site_spin
      else:
        priorities[i*N+j,0] -= total_spin + site_spin
      
  return(priorities)




#score: {'data2D.txt': -0.015478858024691358}
#island_id: 3
#version_generated: 2
#generate time16:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] += total_spin + h[site_nbr][j]
        priorities[i*N+j,1] -= total_spin - h[site_nbr][j]
      else:
        priorities[i*N+j,0] -= total_spin - h[site_nbr][j]
        priorities[i*N+j,1] += total_spin + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.060910648148148144}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3, site_nbr//N, i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.0014720679012345675}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          total_spin += J[k, i, j]
          if h[neighbor_i][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          total_spin -= J[k, i, j]
          if h[neighbor_i][j] > 0:
            priorities[i*N+j][0] -= 1
            priorities[i*N+j][1] += 1
          else:
            priorities[i*N+j][0] += 1
      return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.06040108024691358}
#island_id: 1
#version_generated: 2
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
      if J[3, site_nbr//N, i%N] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.033485030864197525}
#island_id: 0
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin * (1 + abs(total_spin))
        priorities[i*N+j][1] += total_spin * (1 + abs(total_spin))
      else:
        priorities[i*N+j][0] += total_spin * (1 - abs(total_spin))
        priorities[i*N+j][1] -= total_spin * (1 - abs(total_spin))
      
      # Add the nearest neighbor interactions
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += J[1, i, j]
        priorities[i*N+j][1] -= J[1, i, j]
      else:
        priorities[i*N+j][0] -= J[1, i, j]
        priorities[i*N+j][1] += J[1, i, j]
  
  return priorities




#score: {'data2D.txt': -0.004354475308641975}
#island_id: 0
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[np.inf for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin
        priorities[i*N+j][1] = total_spin
      else:
        priorities[i*N+j][0] = total_spin
        priorities[i*N+j][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(4):
    interacting_spins[i] = np.roll(h, -1 if i%2==0 else 1, axis=i//2)
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1)%N, (j-1)%N]
      total_spin = np.sum(h[site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for k in range(N):
    site = (k + ((k-1)%2 - 1)) % N
    total_spin = np.sum(h[site])
    if h[k][0] > 0:
      priorities[k*N:][0] -= 1
    else:
      priorities[k*N:][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.008696141975308642}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,2))
  for k in itertools.product(range(N), range(N)):
    site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
    total_spin[k[0]][k[1]][0] += h[site_nbr][k[1]]
    if h[k[0]][k[1]] > 0:
      total_spin[k[0]][k[1]][1] -= 1
    else:
      total_spin[k[0]][k[1]][1] += 1

  for k in range(N**2):
    site = (k % N, k // N)
    if h[site[0]][site[1]] > 0:
      priorities[k][0] -= 1
    else:
      priorities[k][0] += 1

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      interacting_spins[2, i, j] = -h[(i+1)%N][j]
      interacting_spins[3, i, j] = -h[i][(j+1)%N]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.009238117283950617}
#island_id: 2
#version_generated: 2
#generate time16:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,2))
  for k in itertools.product(range(N), range(N)):
    site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
    total_spin[k[0]][k[1]][0] += h[site_nbr][k[1]]
    if h[k[0]][k[1]] > 0:
      total_spin[k[0]][k[1]][1] -= 1
    else:
      total_spin[k[0]][k[1]][1] += 1

  for k in range(N**2):
    site = (k % N, k // N)
    if h[site[0]][site[1]] > 0:
      priorities[k][0] -= 1
    else:
      priorities[k][0] += 1

  # additional logic to improve priority_v0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        priorities[i*N+j][0] -= 1
      else:
        priorities[i*N+j][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.00046064814814814894}
#island_id: 2
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N**2):
    total_spin=0
    site_nbr=(i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      total_spin += h[site_nbr][j]
      if h[i%N][j] > 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0037958333333333334}
#island_id: 3
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 2*J[k,i,j]
        else:
          total_spin -= 2*J[k,i,j]
      
      priority_total = [total_spin, -1*total_spin]
      
      priorities[i*N+j] = np.array(priority_total)
  
  return(priorities)




#score: {'data2D.txt': -0.2381572530864198}
#island_id: 3
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,1] += 1
          
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
        
  return(priorities)




#score: {'data2D.txt': -0.026268364197530866}
#island_id: 3
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    elif total_spin < 0:
      priorities[i,0] -= 1
    else:
      if h[i//N][i%N] > 0:
        priorities[i,0] += 1
        priorities[i,1] -= 1
      else:
        priorities[i,0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = np.sum(J[:,i//N,i%N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0022322530864197533}
#island_id: 2
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for k in range(N**2):
    site = (k % N, k // N)
    if h[site[0]][site[1]] > 0:
      if np.sum(J[0][site[0]*N+site[1]:]) > 0:
        priorities[k][0] -= 1
      else:
        priorities[k][0] += 1
    else:
      if np.sum(J[3][site[0]*N+site[1]:]) > 0:
        priorities[k][0] -= 1
      else:
        priorities[k][0] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.0005337962962962969}
#island_id: 2
#version_generated: 2
#generate time16:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for k in range(N**2):
    site_nbr1 = (k % N + ((k//N-1)%2 - 1)) % N
    site_nbr2 = (k // N + ((k%N-1)%2 - 1)) % N
    if h[site_nbr1][k%N] > 0:
      priorities[k][0] -= 1
    else:
      priorities[k][0] += 1
    if h[k//N][site_nbr2] > 0:
      priorities[k][1] -= 1
    else:
      priorities[k][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      
      if J[0,i,j] > 0:
        total_spin += J[0,i,j]
      else:
        total_spin -= J[0,i,j]
      
      if J[1,(i+1)%N,j] > 0:
        total_spin += J[1,(i+1)%N,j]
      else:
        total_spin -= J[1,(i+1)%N,j]
      
      if J[2,i,(j-1)%N] > 0:
        total_spin += J[2,i,(j-1)%N]
      else:
        total_spin -= J[2,i,(j-1)%N]
      
      if J[3,i,(i+j)%N >= N] > 0:
        total_spin += J[3,i,(i+j)%N >= N]
      else:
        total_spin -= J[3,i,(i+j)%N >= N]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.10580601851851852}
#island_id: 3
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      magnetism = h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      priorities[i*N+j,0] += magnetism
      
  return(priorities)




#score: {'data2D.txt': -0.10580601851851852}
#island_id: 3
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      magnetism = h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.0007834876543209878}
#island_id: 2
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]
  
  return(priorities)




#score: {'data2D.txt': -0.0093625}
#island_id: 2
#version_generated: 2
#generate time16:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for k in range(N**2):
    site = (k % N, k // N)
    if h[site[0]][site[1]] > 0:
      if np.sum(J[0][site[0]*N+site[1]:]) + np.sum(J[3][site[0]*N+site[1]:]) > 0:
        priorities[k][0] -= 2
      elif np.sum(J[1][site[0]*N+site[1]:]) + np.sum(J[2][site[0]*N+site[1]:]) > 0:
        priorities[k][0] -= 1
      else:
        priorities[k][0] += 1
    else:
      if np.sum(J[0][site[0]*N+site[1]:]) + np.sum(J[3][site[0]*N+site[1]:]) > 0:
        priorities[k][0] -= 2
      elif np.sum(J[1][site[0]*N+site[1]:]) + np.sum(J[2][site[0]*N+site[1]:]) > 0:
        priorities[k][0] += 1
      else:
        priorities[k][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priority = -np.sum(J[0][i*N+j:i*N+j+4]) + np.sum(J[3][i*N+j:i*N+j+4])
      else:
        priority = np.sum(J[0][i*N+j:i*N+j+4]) - np.sum(J[3][i*N+j:i*N+j+4])
      priorities[i*N+j][0] += 1 if h[i][j] > 0 else -1
      priorities[i*N+j][1] -= 1 if h[i][j] > 0 else 1
  
  return(priorities)




#score: {'data2D.txt': 0.0009828703703703703}
#island_id: 2
#version_generated: 2
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(J[0][(i//N)*N:i//N*N+1]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i%N,i%N]
    else:
      priorities[i][0] -= np.sum(J[3][(i//N)*N:i//N*N+1]) - np.sum(J[1][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) - J[2][i%N,i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0007834876543209878}
#island_id: 2
#version_generated: 2
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]
  
  return(priorities)




#score: {'data2D.txt': -0.0003174382716049385}
#island_id: 2
#version_generated: 2
#generate time17:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]
  
  # consider the interactions between sites
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][1] -= np.sum(J[1][i*N:i*N+N, j]) + J[2][i,j]
      else:
        priorities[i*N+j][1] += np.sum(J[3][i*N:i*N+N, j]) + J[2][i,j]
  
  return(priorities)




#score: {'data2D.txt': -0.004144598765432098}
#island_id: 3
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
      else:
        if h[i][j] > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.0548507716049383}
#island_id: 3
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j]) + h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
      else:
        if h[i][j] > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.004780092592592593}
#island_id: 2
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) + J[2][i//N,i%N]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i//N,i%N]
    else:
      priorities[i][1] += np.sum(J[3][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) + J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': -0.00023657407407407443}
#island_id: 2
#version_generated: 2
#generate time17:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]
        
  # consider the interactions between sites
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][1] -= np.sum(J[1][i*N:i*N+N, j]) + J[2][i,j]
      else:
        priorities[i*N+j][1] += np.sum(J[3][i*N:i*N+N, j]) + J[2][i,j]
        
  # consider the interactions between sites in the second half of the grid
  for i in range(N//2):
    site_nbr = (N - 1) % N
    for j in range(N):
      if h[i][j] > 0:
        priorities[(N-1)*N+j][1] -= np.sum(J[1][(N-1)*N:(N-1)*N+N, j]) + J[2][i,j]
      else:
        priorities[(N-1)*N+j][1] += np.sum(J[3][(N-1)*N:(N-1)*N+N, j]) + J[2][i,j]
        
  return(priorities)




#score: {'data2D.txt': -0.0003174382716049385}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][1] -= np.sum(J[1][i*N:i*N+N, j]) + J[2][i,j]
      else:
        priorities[i*N+j][1] += np.sum(J[3][i*N:i*N+N, j]) + J[2][i,j]
  
  return(priorities)




#score: {'data2D.txt': -0.0003174382716049385}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # Calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # Calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]

  # Consider the interactions between sites
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][1] -= np.sum(J[1][i*N:i*N+N, j]) + J[2][i,j]
      else:
        priorities[i*N+j][1] += np.sum(J[3][i*N:i*N+N, j]) + J[2][i,j]

  return(priorities)




#score: {'data2D.txt': 0.0009624999999999995}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(J[0][(i//N)*N:i//N*N+1]) + 2*np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i%N,i%N]
    else:
      priorities[i][0] -= np.sum(J[3][(i//N)*N:i//N*N+1]) - 2*np.sum(J[1][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) - J[2][i%N,i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.09334737654320996}
#island_id: 2
#version_generated: 2
#generate time17:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin + np.sum(J[2][np.ix_(range(N), [i%N])])
    else:
      priorities[i][0] -= total_spin - np.sum(J[3][np.ix_(range(N), [i%N])])
    
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    if h[i//N][i%N] > 0:
      priorities[i][1] -= sum(1 for site_nbr in site_nbrs if h[site_nbr][i%N] > 0)
    else:
      priorities[i][1] += sum(1 for site_nbr in site_nbrs if h[site_nbr][i%N] < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.0009828703703703703}
#island_id: 2
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(J[0][(i//N)*N:i//N*N+1]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i%N,i%N]
    else:
      priorities[i][0] -= np.sum(J[3][(i//N)*N:i//N*N+1]) - np.sum(J[1][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) - J[2][i%N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.01610077160493827}
#island_id: 2
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      total_spin = 0
      for k in site_nbrs:
        total_spin += h[k,j]
      if total_spin > 0:
        priorities[i,j] += 1
      elif total_spin < 0:
        priorities[i,j] -= 1
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': 0.0643905864197531}
#island_id: 2
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      J_sum = 0
      for k in site_nbrs:
        J_sum += J[0,k,j] - J[0,i,k]
      if J_sum > 0:
        priorities[i,j] += 1
      elif J_sum < 0:
        priorities[i,j] -= 1
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': 0.01610077160493827}
#island_id: 2
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  total_spins = np.zeros((N, N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      
      for k in site_nbrs:
        if J[0,k,j] + h[k,j] > 0:
          total_spins[i,j][1] -= 1
        elif J[0,k,j] + h[k,j] < 0:
          total_spins[i,j][1] += 1
        
      total_spin = 0
      for k in site_nbrs:
        total_spin += h[k,j]
      
      if total_spin > 0:
        priorities[i,j] += 1
      elif total_spin < 0:
        priorities[i,j] -= 1
  
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': 0.06968009259259259}
#island_id: 1
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.060910648148148144}
#island_id: 1
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3, site_nbr//N, i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': 0.0588804012345679}
#island_id: 1
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    site_nbr = (i + ((j-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      priorities[i*N+j][0] += 1
      priorities[i*N+j][1] -= 1
    else:
      priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3, site_nbr//N, i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.001377006172839506}
#island_id: 1
#version_generated: 2
#generate time17:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[i][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if h[neighbor_i][j] > 0 and J[k, i, j] < 0 or h[neighbor_i][j] < 0 and J[k, i, j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif h[neighbor_i][j] > 0 and J[k, i, j] > 0 or h[neighbor_i][j] < 0 and J[k, i, j] < 0:
          priorities[i*N+j][0] -= 1
        
      for k in range(4):
        neighbor_j = (j + ((k-1)%2 - 1)) % N
        if h[i][neighbor_j] > 0 and J[3, site_nbr//N, i%N] < 0 or h[i][neighbor_j] < 0 and J[3, site_nbr//N, i%N] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif h[i][neighbor_j] > 0 and J[3, site_nbr//N, i%N] > 0 or h[i][neighbor_j] < 0 and J[3, site_nbr//N, i%N] < 0:
          priorities[i*N+j][0] -= 1
        
      return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      J_term = np.sum(J[0][i*N:i*N+N]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i//N,i%N]
    else:
      J_term = np.sum(J[3][i*N:i*N+N]) + np.sum(J[1][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) + J[2][i//N,i%N]

    if h[i//N][i%N] > 0:
      magnetism_term = 1
    else:
      magnetism_term = -1

    priorities[i][0] -= np.sum(J[1][:,i%N]) * magnetism_term + J_term
    priorities[i][1] -= np.sum(J[1][:,i%N]) * magnetism_term + J_term

  return(priorities)




#score: {'data2D.txt': 0.3426702160493817}
#island_id: 2
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.0001785493827160498}
#island_id: 2
#version_generated: 2
#generate time17:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      J_sum = np.sum(J[1][:,i%N]*np.where(h[:,i%N]>0, 1, -1)) + J[2][i//N,i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J_sum
    else:
      J_sum = np.sum(J[3][:,i%N]*np.where(h[:,i%N]<0, 1, -1)) + J[2][i//N,i%N]
      priorities[i][0] += np.sum(J[0][i*N:i*N+N]) + J_sum
    
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J_sum
    else:
      priorities[i][1] += J_sum
  
  return(priorities)




#score: {'data2D.txt': -0.08575293209876564}
#island_id: 1
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += J[k, i, j]
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and abs(total_spin) < N**2/2:
          total_spin -= J[k, i, j]
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k,i,j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.06255787037037037}
#island_id: 1
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.003827006172839506}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
          
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.05778194444444451}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0,i,j] > 0:
        total_spin += J[0,i,j]
      else:
        total_spin -= J[0,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k+1,site_nbr,(i+j)%N >= N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.003827006172839506}
#island_id: 3
#version_generated: 2
#generate time17:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.14326836419753086}
#island_id: 2
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  total_spin = np.zeros((N,N,2))
  for k in itertools.product(range(N), range(N)):
    site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
    total_spin[k[0]][k[1]][0] += h[site_nbr][k[1]]
    if h[k[0]][k[1]] > 0:
      total_spin[k[0]][k[1]][1] -= 1
    else:
      total_spin[k[0]][k[1]][1] += 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][site_nbr] > 0:
        priorities[i*N+j][0] -= 1
      else:
        priorities[i*N+j][0] += 1

  for i in range(N):
    for j in range(N):
      total = np.sum(J[:, i, j])
      if total > 0:
        priorities[i*N+j][1] -= 1
      elif total < 0:
        priorities[i*N+j][1] += 1

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      priorities[i*N+j][0] += h[site_nbr1][j]
      priorities[i*N+j][0] -= h[site_nbr2][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] -= 1
      else:
        priorities[i*N+j][0] += 1
      
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  
  # Assign higher priority to sites with more favorable interactions
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin[i*N+j][1]
        priorities[i*N+j][1] += total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] += total_spin[i*N+j][1]
        priorities[i*N+j][1] -= total_spin[i*N+j][0]
  
  return priorities




#score: {'data2D.txt': 0.028843055555555552}
#island_id: 0
#version_generated: 2
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][1] += abs(total_spin) ** 3 / (abs(total_spin) + 1)
      else:
        priorities[i*N+j][0] += abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][1] -= abs(total_spin) ** 3 / (abs(total_spin) + 1)
  
  return priorities




#score: {'data2D.txt': -0.008106327160493827}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += np.sum(J[1, i//N, :] * np.where(h[:, i%N], 1, -1))
    else:
      priorities[i][0] += 1
      priorities[i][1] -= np.sum(J[3, i//N, :] * np.where(h[:, i%N], 1, -1))
  
  return(priorities)




#score: {'data2D.txt': 0.0020087962962962963}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if i > 0:
        total_spin += h[(i-1)%N][j]
      if i < N-1:
        total_spin += h[(i+1)%N][j]
      if j > 0:
        total_spin += h[i][(j-1)%N]
      if j < N-1:
        total_spin += h[i][(j+1)%N]
      
      if J[2][i,j] > 0:
        priorities[i*N+j][0] -= 2
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.16961620370370395}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]>0, 1, -1)) + J[2][i,j]
      else:
        priorities[i*N+j][0] += np.sum(J[3][i*N:j*N+1]) + np.sum(J[1][:,i]*np.where(h[:,j]<0, 1, -1)) + J[2][i,j]

  # additional improvement: consider the total spin at each site and prioritize spins that align with it
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][1] -= np.sum(total_spin[i])
      else:
        priorities[i*N+j][1] += np.sum(total_spin[i])

  return(priorities)




#score: {'data2D.txt': -0.019065277777777775}
#island_id: 3
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = np.sum(J[:,i//N,i%N])
    total_spin += h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.1219662037037037}
#island_id: 3
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.010483179012345783}
#island_id: 3
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      priorities[i*N+j,0] = total_spin
      priorities[i*N+j,1] = -total_spin
      
  return(priorities)




#score: {'data2D.txt': 0.03966929012345679}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      total_spin = 0
      for k in site_nbrs:
        total_spin += J[0,i,k] * h[k,j]
      if total_spin > 0:
        priorities[i,j] += 2
      elif total_spin < 0:
        priorities[i,j] -= 2
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': 0.004457870370370371}
#island_id: 2
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = -h.copy()
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (j+1)%N, (i-1+N)%N, (j-1+N)%N]
      site_nbrs.sort()
      total_spin = 0
      for k in site_nbrs:
        total_spin += J[0,k,j] + h[k,j]
      if total_spin > 0:
        priorities[i,j] += 2
      elif total_spin < 0:
        priorities[i,j] -= 2
  return np.array([priorities.flatten(), np.zeros(N**2)]).T




#score: {'data2D.txt': -0.0014526234567901234}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4): 
        if k == 0:
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 1 and j != 0: 
          site_nbr = (i + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 2 and j != N-1: 
          site_nbr = (i + ((j+1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 3 and i != 0: 
          site_nbr = (i-1 + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]

      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1

  return(priorities)




#score: {'data2D.txt': -0.056668364197530935}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0,i,j] > 0:
        total_spin += J[0,i,j]
      else:
        total_spin -= J[0,i,j]
      
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.2207300925925926}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      priorities[i*N+j,0] = -total_spin
      priorities[i*N+j,1] = total_spin

  return(priorities)




#score: {'data2D.txt': 0.0887714506172839}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
  
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.06261033950617287}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%N) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.21923410493827178}
#island_id: 3
#version_generated: 2
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      total_spin += np.sum(J[:,i,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.04609367283950617}
#island_id: 0
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum and interaction sum for each site
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin[i][j][0] += J[(x+1)//2, i, j]*h[site_nbr][j+y]
          if h[i][j] > 0:
            total_spin[i][j][1] -= 1
          else:
            total_spin[i][j][1] += 1
  
  # Assign higher priority to sites with more favorable interactions
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(np.abs(total_spin[i][j])) / (np.sum(np.abs(total_spin[i][j])) + 1)
        priorities[i*N+j][1] += np.sum(np.abs(total_spin[i][j])) / (np.sum(np.abs(total_spin[i][j])) + 1)
      else:
        priorities[i*N+j][0] += np.sum(np.abs(total_spin[i][j])) / (np.sum(np.abs(total_spin[i][j])) + 1)
        priorities[i*N+j][1] -= np.sum(np.abs(total_spin[i][j])) / (np.sum(np.abs(total_spin[i][j])) + 1)
  
  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin[i][j][0] += J[(x+1)//2, i, j]*h[site_nbr][j+y]
          if h[i][j] > 0:
            total_spin[i][j][1] -= 1
          else:
            total_spin[i][j][1] += 1
  
  # Calculate the priority based on the magnetism sum and site interactions
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(total_spin[i][j])
        priorities[i*N+j][1] += np.sum(total_spin[i][j])
      else:
        priorities[i*N+j][0] += np.sum(total_spin[i][j])
        priorities[i*N+j][1] -= np.sum(total_spin[i][j])
  
  return priorities




#score: {'data2D.txt': -0.049481018518518556}
#island_id: 0
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  # Assign higher priority to sites with more favorable interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin[i][1]
      priorities[i][1] -= total_spin[i][0]
    else:
      priorities[i][0] -= total_spin[i][1]
      priorities[i][1] += total_spin[i][0]
  
  return priorities




#score: {'data2D.txt': 0.3427591049382705}
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.22791898148148151}
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for k in range(4):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1

  return(priorities)




#score: {'data2D.txt': 0.06968009259259259}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.0045921296296295416}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': 0.06968009259259259}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k, site_nbr in enumerate(site_nbrs):
        if J[k, i, j] > 0 and total_spin < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': -0.0010211419753086422}
#island_id: 0
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  # Assign higher priority to sites with more favorable interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin[i][1]
      priorities[i][1] -= total_spin[i][0]
    else:
      priorities[i][0] -= total_spin[i][1]
      priorities[i][1] += total_spin[i][0]
      
  # Sort the sites by priority
  sorted_indices = np.argsort([sum(row) for row in priorities])
  
  return [priorities[i] for i in sorted_indices]




#score: {'data2D.txt': -0.21523626543209878}
#island_id: 0
#version_generated: 2
#generate time17:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  # Assign higher priority to sites with more favorable interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin[i][1]
      priorities[i][1] -= total_spin[i][0]
    else:
      priorities[i][0] -= total_spin[i][1]
      priorities[i][1] += total_spin[i][0]
      
  # Additional improvement: Assign higher priority to sites with stronger magnetism
  for i in range(N**2):
    if total_spin[i][0] > 0:
      priorities[i][0] += abs(total_spin[i][0])
      priorities[i][1] -= abs(total_spin[i][0])
    else:
      priorities[i][0] -= abs(total_spin[i][0])
      priorities[i][1] += abs(total_spin[i][0])
      
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
      else:
        priorities[i*N+j][0] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
  
  # Calculate the interaction sum for each site
  for i in range(N):
    for j in range(N):
      total_interaction = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_interaction += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
      else:
        priorities[i*N+j][0] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
  
  return priorities




#score: {'data2D.txt': 0.028843055555555552}
#island_id: 0
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (abs(total_spin) ** 3 / (abs(total_spin) + 1)) * abs(h[i][j])
        priorities[i*N+j][1] += (abs(total_spin) ** 3 / (abs(total_spin) + 1)) * abs(h[i][j])
      else:
        priorities[i*N+j][0] += (abs(total_spin) ** 3 / (abs(total_spin) + 1)) * abs(h[i][j])
        priorities[i*N+j][1] -= (abs(total_spin) ** 3 / (abs(total_spin) + 1)) * abs(h[i][j])
  
  return priorities




#score: {'data2D.txt': 0.0024007716049382704}
#island_id: 0
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions and account for magnetism
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][1] += abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][0] -= h[i][j]
      else:
        priorities[i*N+j][0] += abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][1] -= abs(total_spin) ** 3 / (abs(total_spin) + 1)
        priorities[i*N+j][0] += h[i][j]
  
  return priorities




#score: {'data2D.txt': 0.31782299382715967}
#island_id: 0
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]

  # Calculate the magnetism sum and interaction sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  # Calculate the interaction sum for each site
  for i in range(N):
    for j in range(N):
      total_spin[i*N+j][0] += h[i][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  # Assign higher priority to sites with more favorable interactions
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_spin[i*N+j][0]) ** 3 / (abs(total_spin[i*N+j][0]) + 1)
        priorities[i*N+j][1] += abs(total_spin[i*N+j][0]) ** 3 / (abs(total_spin[i*N+j][0]) + 1)
      else:
        priorities[i*N+j][0] += abs(total_spin[i*N+j][0]) ** 3 / (abs(total_spin[i*N+j][0]) + 1)
        priorities[i*N+j][1] -= abs(total_spin[i*N+j][0]) ** 3 / (abs(total_spin[i*N+j][0]) + 1)

  return priorities




#score: {'data2D.txt': 0.15284861111111137}
#island_id: 2
#version_generated: 2
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    row = i // N
    col = i % N
    if h[row][col] > 0:
      priority_total = total_spin[row][col]
      priorities[i][0] -= np.sum(J[0][row*N:row*N+N]) + J[1][row,col] - priority_total[1]
    else:
      priority_total = total_spin[row][col]
      priorities[i][0] += np.sum(J[3][row*N:row*N+N]) + J[1][row,col] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][1] -= J[k+2][i//N,i%N]
      else:
        priorities[i][1] += J[k+2][i//N,i%N]
        
  return(priorities)




#score: {'data2D.txt': 0.15284861111111137}
#island_id: 2
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # Calculate total spin for each site
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # Calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    row = i // N
    col = i % N
    if h[row][col] > 0:
      priority_total = total_spin[row][col]
      priorities[i][0] -= np.sum(J[0][row*N:row*N+N]) + J[1][row,col] - priority_total[1]
    else:
      priority_total = total_spin[row][col]
      priorities[i][0] += np.sum(J[3][row*N:row*N+N]) + J[1][row,col] + priority_total[1]

    # Consider the interactions between sites
    for k in range(2):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][1] -= J[k+2][i//N,i%N]
      else:
        priorities[i][1] += J[k+2][i//N,i%N]

  return(priorities)




#score: {'data2D.txt': 0.0045921296296295416}
#island_id: 1
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': 0.0045921296296295416}
#island_id: 1
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': 0.1154547839506173}
#island_id: 3
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.13697762345679013}
#island_id: 3
#version_generated: 2
#generate time17:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] * 2
      for k in range(3):
        if k==0:
          site_nbr = (i + ((k-1)%2 - 1)) % N
          total_spin += h[site_nbr][j]
        elif k==1 or k==2:
          total_spin += np.sum(J[:,i,j])
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin) < N**2/2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > N**2/2:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': -0.02030478395061739}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and total_spin < 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and total_spin > 0:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and abs(total_spin[i][j][0]) < N**2/2:
          total_spin[i][j][0] += 1
          total_spin[i][j][1] -= 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > N**2/2:
          total_spin[i][j][0] -= 1
          total_spin[i][j][1] += 1
  
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': 0.009469598765432097}
#island_id: 0
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]

  # Calculate the magnetism sum and interaction sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  # Assign higher priority to sites with more favorable interactions and neighbor distances
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= abs(total_spin[i][0]) ** 3 / (abs(total_spin[i][0]) + 1)
      priorities[i][1] += abs(total_spin[i][0]) ** 3 / (abs(total_spin[i][0]) + 1)
    else:
      priorities[i][0] += abs(total_spin[i][0]) ** 3 / (abs(total_spin[i][0]) + 1)
      priorities[i][1] -= abs(total_spin[i][0]) ** 3 / (abs(total_spin[i][0]) + 1)

  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum and interaction sum for each site
  total_spin = [[0.0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  # Assign higher priority to sites with more favorable interactions
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (total_spin[i*N+j][0] + total_spin[i*N+j][1]) ** 3 / ((abs(total_spin[i*N+j][0]) + 1) * (abs(total_spin[i*N+j][1]) + 1))
        priorities[i*N+j][1] += (total_spin[i*N+j][0] + total_spin[i*N+j][1]) ** 3 / ((abs(total_spin[i*N+j][0]) + 1) * (abs(total_spin[i*N+j][1]) + 1))
      else:
        priorities[i*N+j][0] += (total_spin[i*N+j][0] - total_spin[i*N+j][1]) ** 3 / ((abs(total_spin[i*N+j][0]) + 1) * (abs(total_spin[i*N+j][1]) + 1))
        priorities[i*N+j][1] -= (total_spin[i*N+j][0] - total_spin[i*N+j][1]) ** 3 / ((abs(total_spin[i*N+j][0]) + 1) * (abs(total_spin[i*N+j][1]) + 1))

  return priorities




#score: {'data2D.txt': 0.17784398148148148}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.1219662037037037}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.1219662037037037}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.03929953703703697}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  for k in range(N):
    for j in range(N):
      site = (k + ((j-1)%2 - 1)) % N
      if h[site][j] > 0:
        priorities[k*N+j,0] += 1
        priorities[k*N+j,1] -= 1
      else:
        priorities[k*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.015612808641975265}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[site_nbr][0] > 0:
      for j in range(N):
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
    else:
      for j in range(N):
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.06495354938271611}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      total_spin += h[i][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] = -1
      else:
        priorities[i*N+j,0] = 1

  return(priorities)




#score: {'data2D.txt': 0.0887714506172839}
#island_id: 3
#version_generated: 2
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      priority_total = np.zeros(2)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1
        priority_total[1] += 1
      
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k,i*N+j][0] > 0 and abs(total_spin[i][j][0]) < N**2/2:
          priority_total[0] += 1
          priority_total[1] -= 1
        elif J[k,i*N+j][0] < 0 and total_spin[i][j][0] > N**2/2:
          priority_total[0] -= 1
          priority_total[1] += 1
      
      return np.concatenate([[priority_total[0], -priority_total[1]] for i in range(N) for j in range(N)], axis=0).reshape(-1,2)




#score: {'data2D.txt': 0.1530001543209878}
#island_id: 1
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      total_spin[i][j][0] += np.sum(J[:,i,j])
      if total_spin[i][j][0] > N**2/2:
        total_spin[i][j][0] -= 2
        total_spin[i][j][1] += 1
      elif total_spin[i][j][0] < -N**2/2:
        total_spin[i][j][0] += 2
        total_spin[i][j][1] -= 1
      
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': 0.08855416666666685}
#island_id: 1
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin[i][j][0] += abs(total_spin[neighbor_i][j][0]) / np.sum(np.abs(J[:, i, j]))
          total_spin[i][j][1] -= 1
        elif J[k, i, j] < 0:
          total_spin[i][j][0] -= abs(total_spin[neighbor_i][j][0]) / np.sum(np.abs(J[:, i, j]))
          total_spin[i][j][1] += 1
        
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': 0.3255600308641967}
#island_id: 1
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      neighbor_sum = 0
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          neighbor_sum += 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > 0:
          neighbor_sum -= 1
      total_spin[i][j][0] += neighbor_sum
      if h[i][j] > 0:
        total_spin[i][j][1] -= neighbor_sum
      else:
        total_spin[i][j][1] += neighbor_sum
  
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        site_nbr_ = (k%2==0)*(i+((j-k//2)%2-1))%N+(k//2-1)%N
        if J[k,i,j] > 0:
          total_spin += 2*J[k,i,j]
        else:
          total_spin -= 2*J[k,i,j]
      
      priority_total = [total_spin, -1*total_spin]
      
      priorities[i*N+j] = np.array(priority_total)
  
  return(priorities)




#score: {'data2D.txt': -0.0037958333333333334}
#island_id: 3
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 2*J[k,i,j]
        else:
          total_spin -= 2*J[k,i,j]
      
      priority_total = [total_spin, -1*total_spin]
      
      priorities[i*N+j] = np.array(priority_total)
  
  return(priorities)




#score: {'data2D.txt': 0.1524405864197532}
#island_id: 3
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr_sum = 0
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin -= 1
          site_nbr_sum += 1
        else:
          total_spin += 1
      total_spin += np.sum(J[:,i,j]) - site_nbr_sum
      site_nbr = (i + ((2)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1      
  return(priorities)




#score: {'data2D.txt': 0.04677731481481477}
#island_id: 3
#version_generated: 2
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      total_spin += np.sum(J[:, i, j])
      
      if total_spin > 0:
        priorities[i*N+j, 0] += 1
        priorities[i*N+j, 1] -= 1
      else:
        priorities[i*N+j, 0] -= 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.15887391975308662}
#island_id: 3
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      
      # Calculate magnetism at the site
      if h[i][j] > 0:
        spin = -1
        energy_gain = 1
      else:
        spin = 1
        energy_gain = -1
      
      # Add contributions from nearest neighbors
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        
        # Update the spin based on the interaction
        if J[k,i,j] > 0 and h[site_nbr][j] > 0:
          spin = -1
          energy_gain = 1
        elif J[k,i,j] < 0 and h[site_nbr][j] < 0:
          spin = 1
          energy_gain = -1
        
      # Calculate the priority based on the total spin and magnetism
      if spin == -1:
        priorities[i*N+j,0] += total_spin + h[i][j]
        priorities[i*N+j,1] -= total_spin - h[i][j]
      else:
        priorities[i*N+j,0] -= total_spin - h[i][j]
        priorities[i*N+j,1] += total_spin + h[i][j]
      
      # Add a penalty term to encourage flipping the spin
      if energy_gain > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] = total_spin + h[site_nbr][j]
        priorities[i*N+j,1] = -total_spin + h[site_nbr][j]
      else:
        priorities[i*N+j,0] = -total_spin - h[site_nbr][j]
        priorities[i*N+j,1] = total_spin + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.015478858024691358}
#island_id: 3
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] += total_spin + h[site_nbr][j]
        priorities[i*N+j,1] -= total_spin - h[site_nbr][j]
      else:
        priorities[i*N+j,0] -= total_spin - h[site_nbr][j]
        priorities[i*N+j,1] += total_spin + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.3127208333333326}
#island_id: 3
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        
      if h[i][j] > 0:
        priorities[i*N+j,0] = total_spin + 1
        priorities[i*N+j,1] = -total_spin - 1
      else:
        priorities[i*N+j,0] = -total_spin + 1
        priorities[i*N+j,1] = total_spin - 1
        
  return(priorities)




#score: {'data2D.txt': 0.028843055555555552}
#island_id: 0
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetic field for each site
  B = np.zeros((N,N))
  for i in range(N):
    for j in range(N):
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          B[i][j] += J[(x+1)//2, i, j]*h[site_nbr][j+y]
  
  # Assign higher priority to sites with more favorable interactions
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(B[i][j]) ** 3 / (abs(B[i][j]) + 1)
        priorities[i*N+j][1] += abs(B[i][j]) ** 3 / (abs(B[i][j]) + 1)
      else:
        priorities[i*N+j][0] += abs(B[i][j]) ** 3 / (abs(B[i][j]) + 1)
        priorities[i*N+j][1] -= abs(B[i][j]) ** 3 / (abs(B[i][j]) + 1)
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
      else:
        priorities[i*N+j][0] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
  
  # Calculate the interaction sum for each site
  for i in range(N):
    for j in range(N):
      total_interaction = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_interaction += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
      else:
        priorities[i*N+j][0] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the interaction sum for each site
  for i in range(N):
    for j in range(N):
      total_interaction = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_interaction += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
      else:
        priorities[i*N+j][0] += abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
        priorities[i*N+j][1] -= abs(total_interaction) ** 3 / (abs(total_interaction) + 1)
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions and magnetism
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
      else:
        priorities[i*N+j][0] += (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
        priorities[i*N+j][1] -= (abs(total_spin) + 1)**3 / (abs(total_spin) + 2)
  
  return priorities




#score: {'data2D.txt': 0.3386452160493817}
#island_id: 0
#version_generated: 2
#generate time17:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
      
      # Assign higher priority to sites with more favorable interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(np.abs(J[:, i, j]))
        priorities[i*N+j][1] += np.sum(np.abs(J[:, i, j]))
      else:
        priorities[i*N+j][0] += np.sum(np.abs(J[:, i, j]))
        priorities[i*N+j][1] -= np.sum(np.abs(J[:, i, j]))
  
  return priorities




#score: {'data2D.txt': 0.22791898148148151}
#island_id: 2
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for k in range(3):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    if h[site_nbr][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.0006834876543209876}
#island_id: 3
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] = -1
        priorities[i*N+j,1] = 1
      elif total_spin < 0:
        priorities[i*N+j,0] = 1
        priorities[i*N+j,1] = -1
      else:
        priorities[i*N+j,0] = 0
      
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      priorities[i*N+j,0] = -total_spin
      priorities[i*N+j,1] = 1
      
  return(priorities)




#score: {'data2D.txt': -0.0037958333333333334}
#island_id: 3
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
          
      if total_spin > 0:
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.003827006172839506}
#island_id: 3
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
          
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.13797546296296317}
#island_id: 1
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      neighbor_sum = 0
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          neighbor_sum += 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > 0:
          neighbor_sum -= 1
      total_spin[i][j][0] += neighbor_sum
      if h[i][j] > 0:
        total_spin[i][j][1] -= neighbor_sum
      else:
        total_spin[i][j][1] += neighbor_sum
      
  priority_list = []
  for i in range(N):
    for j in range(N):
      if total_spin[i][j][0] > 0:
        priority_list.append([total_spin[i][j][0], -total_spin[i][j][1]])
      else:
        priority_list.append([-total_spin[i][j][0], total_spin[i][j][1]])
  return np.array(priority_list)




#score: {'data2D.txt': 0.3255600308641967}
#island_id: 1
#version_generated: 2
#generate time17:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      neighbor_sum = 0
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          neighbor_sum += 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > 0:
          neighbor_sum -= 1
      total_spin[i][j][0] += neighbor_sum
      if h[i][j] > 0:
        total_spin[i][j][1] -= neighbor_sum
      else:
        total_spin[i][j][1] += neighbor_sum
      
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': -0.2556054012345679}
#island_id: 1
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i][j][0] += 1
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] -= 1
        total_spin[i][j][1] += 1
      
      neighbor_sum = 0
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          if h[neighbor_i][j] > 0:
            neighbor_sum += 1
          else:
            neighbor_sum -= 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > 0:
          neighbor_sum -= 1
      total_spin[i][j][0] += neighbor_sum
      if h[i][j] > 0:
        total_spin[i][j][1] -= neighbor_sum
      else:
        total_spin[i][j][1] += neighbor_sum
  
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1, 2)




#score: {'data2D.txt': 0.3255600308641967}
#island_id: 1
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  for i in range(N):
    for j in range(N):
      neighbor_sum = 0
      for k in range(4):
        neighbor_i = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          neighbor_sum += 1
        elif J[k, i, j] < 0 and total_spin[i][j][0] > 0:
          neighbor_sum -= 1
      total_spin[i][j][0] += neighbor_sum
      if h[i][j] > 0:
        total_spin[i][j][1] -= neighbor_sum
      else:
        total_spin[i][j][1] += neighbor_sum
      
  priority_total = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[i*N+j][0] += 1
        priority_total[i*N+j][1] -= 1
      else:
        priority_total[i*N+j][0] -= 1
        priority_total[i*N+j][1] += 1
      
  return np.concatenate([[total_spin[i][j][0], -total_spin[i][j][1]] for i in range(N) for j in range(N)], axis=0).reshape(-1,2)




#score: {'data2D.txt': 0.3426702160493817}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
    
    # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
    
    # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.22796003086419755}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
  return(priorities)




#score: {'data2D.txt': 0.22779151234567904}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        priorities[i*N+i][0] -= np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i]
        priorities[i*N+i][1] -= J[3][i//N,i]
      else:
        priorities[i*N+i][0] += np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i]
        priorities[i*N+i][1] += J[3][i//N,i]
        
  return(priorities)




#score: {'data2D.txt': -0.006937808641975309}
#island_id: 2
#version_generated: 2
#generate time17:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N]
      
    if h[site_nbr1][i%N] > 0:
      priorities[i][1] -= 1
    else:
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k+1,site_nbr,(i+j)%N >= N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 3
#version_generated: 2
#generate time17:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k+1,site_nbr,(i+j)%N >= N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i*N+j,0] = total_spin
      priorities[i*N+j,1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.0339445987654321}
#island_id: 0
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the magnetism sum and interaction sum for each site
  for i in range(N):
    for j in range(N):
      total_spin = 0
      interaction_sum = 0
      for x in range(-1, 2):
        for y in range(-1, 2):
          if (x == 0 and y == 0) or not ((i + x) % N == j + y) % N:
            continue
          site_nbr = (i + ((j+y-1)%2 - 1)) % N
          total_spin += J[(x+1)//2, i, j]*h[site_nbr][j+y]
          interaction_sum += np.abs(J[(x+1)//2, i, j])
      
      # Assign higher priority to sites with more favorable interactions and magnetism
      if h[i][j] > 0:
        priorities[i*N+j][0] -= interaction_sum + total_spin
        priorities[i*N+j][1] += interaction_sum - total_spin
      else:
        priorities[i*N+j][0] += interaction_sum + total_spin
        priorities[i*N+j][1] -= interaction_sum - total_spin
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0 for _ in range(2)] for _ in range(N**2)]
  
  # Calculate the sum of magnetism and interactions for each site
  total_spin = np.zeros((N, N), dtype=int)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
  
  # Calculate the priority based on the interactions with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(np.abs(J[:, i, j]))
        priorities[i*N+j][1] += np.sum(np.abs(J[:, i, j]))
      else:
        priorities[i*N+j][0] += np.sum(np.abs(J[:, i, j]))
        priorities[i*N+j][1] -= np.sum(np.abs(J[:, i, j]))
  
  return priorities




#score: {'data2D.txt': 0.33967422839506073}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
    # add a penalty for having two sites with the same spin
    if i >= N and h[i//N][i%N] > 0:
      priorities[i][0] -= 2
    elif i >= N and h[i//N][i%N] < 0:
      priorities[i][0] += 2
      
  return(priorities)




#score: {'data2D.txt': 0.22793873456790126}
#island_id: 2
#version_generated: 2
#generate time17:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
  return(priorities)




#score: {'data2D.txt': 0.029135030864197532}
#island_id: 2
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
    # add the priority based on the number of -1 spins in the neighborhood
    for j in range(N):
      site = (i + ((j-1)%2 - 1)) % N
      if h[site][j] > 0:
        priorities[i][0] -= 1
      else:
        priorities[i][0] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.22793873456790126}
#island_id: 2
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
  return(priorities)




#score: {'data2D.txt': -0.06782854938271611}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      priority_total = [0, 0]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1

      for k in range(4):
        interacting_spin = interacting_spins[k][i][j]
        if interacting_spin > 0:
          priority_total[0] += J[k, i, j]
          priority_total[1] -= J[k, i, j]
        else:
          priority_total[0] -= J[k, i, j]

      priorities[i*N+j] = [total_spin + sum(J[:,i,j])/4, -sum(J[:,i,j])]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.23316527777777776}
#island_id: 1
#version_generated: 2
#generate time17:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k][i][j]
        else:
          total_spin -= J[k][i][j]
      priorities[i*N+j][0] += total_spin
  return(priorities)




#score: {'data2D.txt': 0.031431018518518435}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,site_nbr,i%N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,i,j])
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        J_sum = np.sum(J[:,i,j])
        if J_sum > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
          
  return(priorities)




#score: {'data2D.txt': 0.09111959876543209}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  # add more logic here to improve the algorithm
  for i in range(N):
    for j in range(N//2): 
      site = (i + ((j-1)%2 - 1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.0656050925925925}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i % N + ((j-1)%2 - 1)) % N
      site_nbr2 = (i % N + ((j+1)%2 - 1)) % N
      
      if h[site_nbr1][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      if h[site_nbr2][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,i,j])
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.002868981481481482}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
      else:
        if h[i][j] > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
  
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      for j in range(N):
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
    else:
      for j in range(N):
        priorities[i*N+j,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0037958333333333334}
#island_id: 3
#version_generated: 2
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.3426594135802458}
#island_id: 2
#version_generated: 2
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.3427591049382705}
#island_id: 2
#version_generated: 2
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': -0.0006908950617283956}
#island_id: 0
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.array([[0.5*(h[i][j]+J[0,i,j]-2*J[0,(i+1)%N,j]) for j in range(N)] for i in range(N)])
  return(np.concatenate((priorities.flatten(),np.zeros(N**2)),axis=0).reshape(-1, 2))




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.01016219135802469}
#island_id: 0
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N][site_nbr]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr][i%N]
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr]!=(i+1)%N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.06782854938271611}
#island_id: 1
#version_generated: 2
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      priority_total = [0, 0]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      else:
        priority_total[0] -= 1

      for k in range(4):
        interacting_spin = J[k, i, j]
        if interacting_spin > 0:
          priority_total[0] += 2*interacting_spin
          priority_total[1] -= 2*interacting_spin
        else:
          priority_total[0] -= 2*interacting_spin

      priorities[i*N+j] = [total_spin + sum(J[:,i,j])/4, -sum(J[:,i,j])]
  return(priorities)




#score: {'data2D.txt': 0.023594907407407405}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  site_neighbors = np.zeros((N*N, 4))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      site_neighbors[i*N+j, :] = [h[site_nbr][j], h[i][0], h[0][j], h[i][N-1]]

  total_spins = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spins[i*N+j] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spins[i*N+j][0] += 1
        total_spins[i*N+j][1] -= 1
      else:
        total_spins[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spins[i*N+j][0], -total_spins[i*N+j][1]]
      else:
        priorities[i*N+j] -= [total_spins[i*N+j][0], -total_spins[i*N+j][1]]

      for k in range(4):
        interacting_spin = interacting_spins[k][i][j]
        if interacting_spin > 0:
          priorities[i*N+j][0] += J[k, i, j]
          priorities[i*N+j][1] -= J[k, i, j]
        else:
          priorities[i*N+j][0] -= J[k, i, j]

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + sum(J[:,i,j]) // 4
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.06782854938271611}
#island_id: 1
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      priority_total = [0, 0]
      site_nbrs = [(i-1)%N, (i+1)%N, (j-1)%N, (j+1)%N]
      for k, site_nbr in enumerate(site_nbrs):
        if J[k, i, j] > 0:
          priority_total[0] += J[k, i, j]
          priority_total[1] -= J[k, i, j]
        else:
          priority_total[0] -= J[k, i, j]

      priorities[i*N+j] = [total_spin + sum(J[:,i,j])/4, -sum(J[:,i,j])]
  return(priorities)




#score: {'data2D.txt': 0.06691712962962969}
#island_id: 3
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.17382145061728396}
#island_id: 3
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      
  # Check and adjust for corners
  for i in range(N):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i*N+i][0] -= 1
      priorities[i*N+i][1] += 1
    else:
      priorities[i*N+i][0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.06691712962962969}
#island_id: 3
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
    
    # calculate priority based on site interactions and magnetism
    for k in range(2):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[i][k%N] > 0:
        total_spin[i][k][0] += np.sum(J[0][i*N+k:k*N+N]) + J[2][i,k]
        priorities[i*N+k][0] -= 1
        priorities[i*N+k][1] -= 1
      else:
        total_spin[i][k][0] -= np.sum(J[3][i*N+k:k*N+N]) - J[2][i,k]
        priorities[i*N+k][0] += 1
        priorities[i*N+k][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.004268672839506172}
#island_id: 2
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    if total_spin > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] - 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] + 1
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.023594907407407405}
#island_id: 1
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  site_neighbors = np.zeros((N*N, 4))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      site_neighbors[i*N+j, :] = [h[site_nbr][j], h[i][0], h[0][j], h[i][N-1]]

  total_spins = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spins[i*N+j] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spins[i*N+j][0] += 1
        total_spins[i*N+j][1] -= 1
      else:
        total_spins[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spins[i*N+j][0], -total_spins[i*N+j][1]]
      else:
        priorities[i*N+j] -= [total_spins[i*N+j][0], -total_spins[i*N+j][1]]

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        interacting_spin = interacting_spins[k][i][j]
        if interacting_spin > 0:
          priorities[i*N+j][0] += J[k, i, j]
          priorities[i*N+j][1] -= J[k, i, j]
        else:
          priorities[i*N+j][0] -= J[k, i, j]

  return(priorities)




#score: {'data2D.txt': 0.02446496913580247}
#island_id: 1
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spin += 1
        priorities[i*N+j] -= [total_spin, -1]
      else:
        total_spin -= 1
        priorities[i*N+j] += [total_spin, -1]
      for k in range(4):
        interacting_spin = J[k, i, j]
        if interacting_spin > 0:
          priorities[i*N+j][0] += 2*interacting_spin
          priorities[i*N+j][1] -= 2*interacting_spin
        else:
          priorities[i*N+j][0] -= 2*interacting_spin
  return(priorities)




#score: {'data2D.txt': -0.3413714506172836}
#island_id: 1
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in range(4):
        interacting_spin = J[k, i, j]
        if interacting_spin > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N+j][0] = total_spin
        if h[i][j] > 0:
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.005916203703703703}
#island_id: 1
#version_generated: 2
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  # Calculate the magnetism and interaction terms
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      # Calculate the total spin and priority term
      if h[i][j] > 0:
        priorities[i * N + j, 0] += 1
        priorities[i * N + j, 1] -= 1
      else:
        priorities[i * N + j, 0] -= 1
      
      # Add the interaction terms
      if J[0, i, j] > 0:
        priorities[i * N + j, 0] += J[0, i, j]
        priorities[i * N + j, 1] -= J[0, i, j]
      elif J[0, i, j] < 0:
        priorities[i * N + j, 0] -= J[0, i, j]
      
      if J[1, i, j] > 0:
        priorities[i * N + j, 0] += J[1, i, j]
        priorities[i * N + j, 1] -= J[1, i, j]
      elif J[1, i, j] < 0:
        priorities[i * N + j, 0] -= J[1, i, j]
      
      if J[2, i, j] > 0:
        priorities[i * N + j, 0] += J[2, i, j]
        priorities[i * N + j, 1] -= J[2, i, j]
      elif J[2, i, j] < 0:
        priorities[i * N + j, 0] -= J[2, i, j]
      
      if J[3, i, j] > 0:
        priorities[i * N + j, 0] += J[3, i, j]
        priorities[i * N + j, 1] -= J[3, i, j]
      elif J[3, i, j] < 0:
        priorities[i * N + j, 0] -= J[3, i, j]
  
  return priorities




#score: {'data2D.txt': 0.22889675925925929}
#island_id: 2
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  # consider the interactions between sites and their neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N]) - J[2][i//N,i%N]
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.3426594135802458}
#island_id: 2
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.3427591049382705}
#island_id: 2
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])

  return(priorities)




#score: {'data2D.txt': 0.04732916666666667}
#island_id: 2
#version_generated: 2
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    for j in range(N):
      if i % N == j or (i % N + (j-1)%2 - 1) % N == site_nbr:
        if h[i//N][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    priorities[i][0] = np.sum(J[1][i*N:i*N+N]) + J[2][i//N,i%N]
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.023594907407407405}
#island_id: 1
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  site_neighbors = np.zeros((N*N,4))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      site_neighbors[i*N+j,:] = [h[site_nbr][j], h[i][0], h[0][j], h[i][N-1]]

  total_spins = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spins[i*N+j] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spins[i*N+j][0] += 1
        total_spins[i*N+j][1] -= 1
      else:
        total_spins[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spins[i*N+j][0], -total_spins[i*N+j][1]]
      else:
        priorities[i*N+j] -= [total_spins[i*N+j][0], -total_spins[i*N+j][1]]

  for i in range(N):
    for j in range(N):
      for k in range(4):
        interacting_spin = interacting_spins[k][i][j]
        if interacting_spin > 0:
          priorities[i*N+j][0] += J[k,i,j]
          priorities[i*N+j][1] -= J[k,i,j]
        else:
          priorities[i*N+j][0] -= J[k,i,j]

  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spin, -total_spin]
      else:
        priorities[i*N+j] -= [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.023594907407407405}
#island_id: 1
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  site_neighbors = np.zeros((N*N, 4))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      site_neighbors[i*N+j, :] = [h[site_nbr][j], h[i][0], h[0][j], h[i][N-1]]

  total_spins = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spins[i*N+j] += h[site_nbr][j]
      if h[site_nbr][j] > 0:
        total_spins[i*N+j][0] += 1
        total_spins[i*N+j][1] -= 1
      else:
        total_spins[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spins[i*N+j][0], -total_spins[i*N+j][1]]
      else:
        priorities[i*N+j] -= [total_spins[i*N+j][0], -total_spins[i*N+j][1]]

  for k in range(4):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((j-1)%2 - 1)) % N
        interacting_spin = interacting_spins[k][i][j]
        if interacting_spin > 0:
          priorities[i*N+j][0] += J[k, i, j]
          priorities[i*N+j][1] -= J[k, i, j]
        else:
          priorities[i*N+j][0] -= J[k, i, j]

  return(priorities)




#score: {'data2D.txt': -0.0397125}
#island_id: 3
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] = -total_spin + h[site_nbr][j]
      else:
        priorities[i*N+j,0] = total_spin - h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.01664891975308642}
#island_id: 3
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] += np.abs(total_spin) + h[site_nbr][j]
        priorities[i*N+j,1] -= np.abs(total_spin) - h[site_nbr][j]
      else:
        priorities[i*N+j,0] -= np.abs(total_spin) - h[site_nbr][j]
        priorities[i*N+j,1] += np.abs(total_spin) + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.07880972222222221}
#island_id: 3
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] += np.sum(np.abs(J[:,i,j])) + h[site_nbr][j]
        priorities[i*N+j,1] -= np.sum(np.sign(J[:,i,j])) - h[site_nbr][j]
      else:
        priorities[i*N+j,0] -= np.sum(np.abs(J[:,i,j])) - h[site_nbr][j]
        priorities[i*N+j,1] += np.sum(np.sign(J[:,i,j])) + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.062354166666666704}
#island_id: 3
#version_generated: 2
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,1] += 1
      
      # Calculate the priority based on the total spin and magnetism
      if total_spin > 0:
        priorities[i*N+j,0] = total_spin + h[site_nbr][j]
      else:
        priorities[i*N+j,0] = -total_spin + h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.009977623456790123}
#island_id: 0
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N][site_nbr]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr][i%N]
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr]!=(i+1)%N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
    else:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][1] += 2
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i//N*N+i%N][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1

  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.0009816358024691356}
#island_id: 0
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    if i % (N * N) < N:
      site_nbr1 = ((i // N + i % N) % N)
      site_nbr2 = ((i // N - 1) % N)
    else:
      site_nbr1 = ((i // N - 1) % N)
      site_nbr2 = (i % N)

    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      if h[site_nbr1][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1

    if J[0,i%N][site_nbr2]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr2][i%N]
      if h[site_nbr2][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.33967422839506073}
#island_id: 2
#version_generated: 2
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
    # add a penalty for having two sites with the same spin
    if i >= N and h[i//N][i%N] > 0:
      priorities[i][0] -= 2
    elif i >= N and h[i//N][i%N] < 0:
      priorities[i][0] += 2
      
  return(priorities)




#score: {'data2D.txt': -0.34291959876543104}
#island_id: 2
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(4):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
    # add a penalty for having two sites with the same spin
    if i >= N and h[i//N][i%N] > 0:
      priorities[i][0] -= 2
    elif i >= N and h[i//N][i%N] < 0:
      priorities[i][0] += 2
    
  # add a bias term to the priority function
  for i in range(N**2):
    if total_spin[i//N][i%N][1] > 0:
      priorities[i][0] -= 10
    elif total_spin[i//N][i%N][1] < 0:
      priorities[i][0] += 10
  
  return(priorities)




#score: {'data2D.txt': 0.33967422839506073}
#island_id: 2
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= J[k][i*N:i*N+N].sum()
      else:
        priorities[i][0] += J[k][i*N:i*N+N].sum()
        
    # add a penalty for having two sites with the same spin
    if i >= N and h[i//N][i%N] > 0:
      priorities[i][0] -= 2
    elif i >= N and h[i//N][i%N] < 0:
      priorities[i][0] += 2
      
  return(priorities)




#score: {'data2D.txt': 0.33963935185185085}
#island_id: 2
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
    # consider the interactions between sites
    site_nbr_2d = (i % N + ((i//N-1)%2 - 1)) % N
    if i >= N:
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][i%N] > 0:
          priorities[i][0] -= J[k][i*N:i*N+N].sum()
        else:
          priorities[i][0] += J[k][i*N:i*N+N].sum()
          
    # add a penalty for having two sites with the same spin
    if i >= N and h[i//N][i%N] > 0:
      priorities[i][0] -= 2
    elif i >= N and h[i//N][i%N] < 0:
      priorities[i][0] += 2
      
  return(priorities)




#score: {'data2D.txt': -0.004284722222222223}
#island_id: 3
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    total_spin += h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0020751543209876545}
#island_id: 3
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if total_spin > 0:
      priorities[i,0] = np.sum(J[1:,i//N,i//N]) + h[site_nbr][i%N]
      priorities[i,1] = -np.sum(J[1:,i//N,i//N])
    else:
      priorities[i,0] = -np.sum(J[1:,i//N,i//N])
      priorities[i,1] = np.sum(J[1:,i//N,i//N]) + h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0017591049382716054}
#island_id: 3
#version_generated: 2
#generate time17:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]

    if total_spin > 0:
      priorities[i,0] = np.sum([J[j,i%N,i//N] for j in range(4) if J[j,i%N,i//N] > 0])
      priorities[i,1] = -np.sum([J[j,i%N,i//N] for j in range(4) if J[j,i%N,i//N] < 0])
    else:
      priorities[i,0] = -np.sum([J[j,i%N,i//N] for j in range(4) if J[j,i%N,i//N] > 0])
      priorities[i,1] = np.sum([J[j,i%N,i//N] for j in range(4) if J[j,i%N,i//N] < 0])

  return(priorities)




#score: {'data2D.txt': 0.01016219135802469}
#island_id: 0
#version_generated: 2
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      if h[site_nbr1][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr2]!=(i+1)%N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.12613966049382724}
#island_id: 0
#version_generated: 2
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr4 = (i // N + 1) % N
    total_spin[i][0] += h[site_nbr1][i%N] + h[site_nbr2][i%N] + h[site_nbr3][i%N] + h[site_nbr4][i%N]
    if (h[site_nbr1][i%N]>0 and J[0,i%N][site_nbr1]%N==i) or (h[site_nbr1][i%N]<0 and J[0,i%N][site_nbr1]%N!=(i+1)%N):
      total_spin[i][1] -= 2
    if (h[site_nbr3][i%N]>0 and J[0,i%N][site_nbr3]%N==i) or (h[site_nbr3][i%N]<0 and J[0,i%N][site_nbr3]%N!=(i+1)%N):
      total_spin[i][1] -= 2
    if (h[site_nbr2][i%N]>0 and J[0,i%N][site_nbr2]%N==i) or (h[site_nbr2][i%N]<0 and J[0,i%N][site_nbr2]%N!=(i+1)%N):
      total_spin[i][1] += 1
    if (h[site_nbr4][i%N]>0 and J[0,i%N][site_nbr4]%N==i) or (h[site_nbr4][i%N]<0 and J[0,i%N][site_nbr4]%N!=(i+1)%N):
      total_spin[i][1] += 1
  return(total_spin.flatten().reshape(-1,2))




#score: {'data2D.txt': -0.0015541666666666662}
#island_id: 0
#version_generated: 2
#generate time17:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    if J[0,i%N][i//N]%N==i:
      total_spin[i//N*N+i%N][0] += h[i//N][i%N]
      if h[i//N][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[1,i//N][i%N]%N==i:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
    elif J[2,i//N][i%N]%N==i:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
    elif J[3,i//N][i%N]%N==i:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.009225154320987654}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # adjust the priority based on the spin of neighboring sites
  for k in range(3):
    for i in range(N**2):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.3426652777777767}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # Calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # Calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # Consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # Calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  # Adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  # Consider the interactions between sites and their neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.3426652777777767}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
      
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  # adjust the priority based on the spin of neighboring sites (optimized)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.34263317901234464}
#island_id: 2
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]

  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.028202623456790137}
#island_id: 1
#version_generated: 2
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [total_spin + 2, -total_spin]
      else:
        priorities[i*N+j] = [-total_spin, total_spin+2]
  
  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spin, -total_spin]
      else:
        priorities[i*N+j] -= [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin

  return(priorities)




#score: {'data2D.txt': 0.038096141975308855}
#island_id: 3
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1

      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      elif total_spin < 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] = 0

  return(priorities)




#score: {'data2D.txt': -0.01583719135802469}
#island_id: 3
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j][0] -= 1
      priorities[i*N+j][1] += 1
    else:
      priorities[i*N+j][0] += 1
      
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
  
  for i in range(N):
    for j in range(N-1):
      site_nbr = (i + ((j)%2 - 1)) % N
      if h[site_nbr][j+1] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
        
  return(priorities)




#score: {'data2D.txt': -0.013988425925925923}
#island_id: 3
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i % N + (i//N)%2) - 1) % N
    
    total_spin = np.sum(J[:,i//N,i%N]) + h[site_nbr1][i%N]
    
    if total_spin > 0:
      priorities[i,0] -= 1
      priorities[i,1] += 1
    else:
      priorities[i,0] += 1
    
    for k in range(2):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i,0] -= 1
        priorities[i,1] += 1
      else:
        priorities[i,0] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.005534104938271605}
#island_id: 0
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, (i % N + ((i//N-1)%2)) % N]
    total_spin[i//N*N+i%N][0] += sum(J[0,i%N][site_nbr] for site_nbr in site_nbrs)
    if any(h[site_nbr][i%N] > 0 for site_nbr in site_nbrs):
      total_spin[i//N*N+i%N][1] -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] > 0])
    else:
      total_spin[i//N*N+i%N][1] += len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] < 0])
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.1698341049382711}
#island_id: 0
#version_generated: 2
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if J[0,i][site_nbr] == i:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[i][j] > 0:
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][1] += 1
      
      elif J[0,i][site_nbr] == (i+1)%N:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] -= h[site_nbr][j]
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += h[site_nbr][j]
          total_spin[i*N+j][1] -= 1
      
      else:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        
        if h[site_nbr][j] > 0:
          total_spin[i*N+j][0] += h[site_nbr][j]
          total_spin[i*N+j][1] -= 1
        else:
          total_spin[i*N+j][0] -= h[site_nbr][j]
          total_spin[i*N+j][1] += 1
  
  return(total_spin.flatten().reshape(-1,2))




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
        
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]
        
  return priorities




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N*N,2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  site_nbr = (N-1) % N
  for i in range(N):
    if h[site_nbr][i] > 0:
      total_spin[i*N+site_nbr][0] -= 2
      total_spin[i*N+site_nbr][1] += 2
    else:
      total_spin[i*N+site_nbr][0] += 2
      total_spin[i*N+site_nbr][1] -= 2

  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]

  return priorities




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]

  return priorities




#score: {'data2D.txt': 0.3427270061728384}
#island_id: 2
#version_generated: 2
#generate time17:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])

  # calculate additional priority based on site interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N])

  return(priorities)




#score: {'data2D.txt': 0.09390262345679022}
#island_id: 2
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # adjust the priority based on the spin of neighboring sites
  for k in range(3):
    for i in range(N**2):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] -= np.sum(J[1][i*N:i*N+N])
        priorities[i][1] += 1
      else:
        priorities[i][0] += np.sum(J[1][i*N:i*N+N])
        priorities[i][1] -= 1

  return(priorities)




#score: {'data2D.txt': -0.005534104938271605}
#island_id: 0
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, (i % N + ((i//N-1)%2)) % N]
    total_spin[i//N*N+i%N][0] += sum(J[0,i%N][site_nbr] for site_nbr in site_nbrs)
    if any(h[site_nbr][i%N] > 0 for site_nbr in site_nbrs):
      total_spin[i//N*N+i%N][1] -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] > 0])
    else:
      total_spin[i//N*N+i%N][1] += len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] < 0])
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      total_spin += h[i][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] = -1
      else:
        priorities[i*N+j,0] = 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1

  return(priorities)




#score: {'data2D.txt': 0.06495354938271611}
#island_id: 3
#version_generated: 2
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,i,j]) + h[i][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] = -1
      else:
        priorities[i*N+j,0] = 1

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j, 0] += 1
        priorities[i*N+j, 1] -= 1
      else:
        priorities[i*N+j, 0] -= 1
        
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if J[k][site_nbr][j] > 0:
          total_spin += J[k][site_nbr][j]
        elif J[k][site_nbr][j] < 0:
          total_spin -= J[k][site_nbr][j]
        
      priorities[i*N+j, 0] += total_spin
      if h[i][j] > 0:
        priorities[i*N+j, 1] -= 2*total_spin
      else:
        priorities[i*N+j, 1] += 2*total_spin
  
  return priorities




#score: {'data2D.txt': -0.020583487654320987}
#island_id: 1
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      if J[0, i, j] > 0:
        total_spin -= J[0, i, j]
      elif J[0, i, j] < 0:
        total_spin += J[0, i, j]
      
      if J[1, i, j] > 0:
        total_spin -= J[1, i, j]
      elif J[1, i, j] < 0:
        total_spin += J[1, i, j]
      
      priorities[i * N + j, 0] = total_spin
      priorities[i * N + j, 1] = -total_spin
  
  return priorities




#score: {'data2D.txt': -0.2279186728395062}
#island_id: 1
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i * N + j, 0] += 1
        priorities[i * N + j, 1] -= 1
      else:
        priorities[i * N + j, 0] -= 1
        
      interaction_terms = J[0, i, j] if (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0) else -J[0, i, j]
      priorities[i * N + j, 0] += interaction_terms
      priorities[i * N + j, 1] -= interaction_terms
      
  return priorities




#score: {'data2D.txt': -0.2287023148148146}
#island_id: 0
#version_generated: 2
#generate time17:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%2) % N
      
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.3427270061728384}
#island_id: 2
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  # Calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # Calculate priorities based on site interactions and magnetism
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - total_spin[i//N][i%N][1]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + total_spin[i//N][i%N][1]

  # Consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # Adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])

  # Calculate additional priority based on site interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N])

  return(priorities)




#score: {'data2D.txt': 0.3427270061728384}
#island_id: 2
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])

  # calculate additional priority based on site interactions
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N])

  return(priorities)




#score: {'data2D.txt': -0.10885509259259259}
#island_id: 3
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j,0] += 1
      priorities[i*N+j,1] -= 1
    else:
      priorities[i*N+j,0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.21984212962962948}
#island_id: 3
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.09909182098765433}
#island_id: 3
#version_generated: 2
#generate time17:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      total_spin += h[i][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.18642638888888916}
#island_id: 2
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # Calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
  
  # Consider the interactions between sites
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.sum(J[1, i*N:i*N+N]) + J[2][i//N,j%N]
      else:
        priorities[i*N+j][0] -= np.sum(J[1, i*N:i*N+N]) - J[2][i//N,j%N]
  
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin += 1
    else:
      total_spin -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0013714506172839507}
#island_id: 2
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N]
      priorities[i][1] = -J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N]
      priorities[i][1] = J[2][i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.004027623456790124}
#island_id: 2
#version_generated: 2
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N]
      priorities[i][1] += J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) - J[2][i//N,i%N]
      priorities[i][1] -= J[2][i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.22483379629629635}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for k in range(2):
    for i in range(N):
      for j in range(N):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] -= np.sum(J[k][i*N:i*N+N]) + J[k][i//N,j]
          priorities[i*N+j][1] -= J[k][i//N,j]
        else:
          priorities[i*N+j][0] += np.sum(J[3-k][i*N:i*N+N]) + J[k][i//N,j]
          priorities[i*N+j][1] += J[k][i//N,j]

  return(priorities)




#score: {'data2D.txt': 0.13537299382716067}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] -= np.sum(J[3][i*N:i*N+N]) + J[3][i//N,j]
        priorities[i*N+j][1] -= J[3][i//N,j]
      else:
        priorities[i*N+j][0] += np.sum(J[0][i*N:i*N+N]) + J[3][i//N,j]
        priorities[i*N+j][1] += J[3][i//N,j]
        
  # Consider the interactions with itself
  for i in range(N**2):
    if h[i%N][i//N] > 0:
      priorities[i][0] -= J[3][i//N,i%N]
      priorities[i][1] -= 1
    else:
      priorities[i][0] += J[3][i//N,i%N]
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.11261250000000013}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][i] > 0:
        priorities[i*N+i][0] -= np.sum(J[3][i*N:i*N+N]) + J[3][i//N,i]
        priorities[i*N+i][1] -= J[3][i//N,i]
      else:
        priorities[i*N+i][0] += np.sum(J[0][i*N:i*N+N]) + J[3][i//N,i]
        priorities[i*N+i][1] += J[3][i//N,i]

  # add a correction term based on the interaction between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= J[3][i//N,i%N]
    else:
      priorities[i][0] += J[3][i//N,i%N]

  return(priorities)




#score: {'data2D.txt': 0.3426702160493817}
#island_id: 2
#version_generated: 2
#generate time17:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
    
    # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.3426702160493817}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
  
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.3426702160493817}
#island_id: 2
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - total_spin[i//N][i%N][1]
    else:
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + total_spin[i//N][i%N][1]

    # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      total_spin = h[site_nbr][j]
      
      if J[0, i, j] > 0:
        total_spin += J[0, i, j]
      elif J[0, i, j] < 0:
        total_spin -= J[0, i, j]
      
      if J[1, i, j] > 0:
        total_spin += J[1, i, j]
      elif J[1, i, j] < 0:
        total_spin -= J[1, i, j]
      
      priorities[i * N + j, 0] = np.abs(total_spin)
      if h[i][j] > 0:
        priorities[i * N + j, 1] = -total_spin
      else:
        priorities[i * N + j, 1] = total_spin
      
  return priorities




#score: {'data2D.txt': -0.003827006172839506}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the magnetism and interaction terms
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j, 0] += 1
        priorities[i*N+j, 1] -= 1
      else:
        priorities[i*N+j, 0] -= 1
        
      # Add the interaction terms
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j, 0] += J[k][i][j]
          priorities[i*N+j, 1] -= J[k][i][j]
        elif J[k][i][j] < 0:
          priorities[i*N+j, 0] -= J[k][i][j]
          
  return priorities




#score: {'data2D.txt': -0.005916203703703703}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  # Calculate the magnetism term
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i * N + j, 0] += 1
        priorities[i * N + j, 1] -= 1
      else:
        priorities[i * N + j, 0] -= 1
      
      # Add the interaction terms
      for k in range(4):
        if J[k, i, j] > 0:
          priorities[i * N + j, 0] += J[k, i, j]
          priorities[i * N + j, 1] -= J[k, i, j]
        elif J[k, i, j] < 0:
          priorities[i * N + j, 0] -= J[k, i, j]
          
  return priorities




#score: {'data2D.txt': 0.11446250000000013}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for d in [(1,0), (-1,0), (0,1), (0,-1)]:
      dx, dy = d
      x, y = i % N, i // N
      site_nbr = (x + dx) % N + ((y+dy)%2-1)*N
      if J[3,x,y] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16607978395061754}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # calculate the priority based on the current state
    for k in range(4):
      site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.004281635802469135}
#island_id: 1
#version_generated: 2
#generate time17:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i] = [site_magnetism, -site_magnetism]
    else:
      priorities[i] = [-site_magnetism, site_magnetism]

  return priorities




#score: {'data2D.txt': -0.018136574074074163}
#island_id: 3
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr1,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0 and h[site_nbr2][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif h[site_nbr1][j] < 0 and h[site_nbr2][j] < 0:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.031431018518518435}
#island_id: 3
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.25150138888888834}
#island_id: 3
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,site_nbr,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
        else:
          priorities[i*N+j,0] -= 1
          
  return(priorities)




#score: {'data2D.txt': 0.014537191358024622}
#island_id: 3
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      site_nbr = (i + ((j-1)%2 - 1)) % N

      if h[site_nbr][j] > 0:
        spin_diff = 1
      else:
        spin_diff = -1

      priorities[i*N+j,0] += total_spin + spin_diff

  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N

    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
    else:
      priorities[i][0] += 1

  return(priorities)




#score: {'data2D.txt': 0.17778348765432123}
#island_id: 1
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr_k = (j + k%2) % N
        if J[k, i, site_nbr_k] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] += [total_spin, -total_spin]
      else:
        priorities[i*N+j] -= [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.22751126543209882}
#island_id: 1
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        if J[k][i][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      magnetism = h[site_nbr][j]
      
      priorities[i*N+j, 0] = total_spin + magnetism
      priorities[i*N+j, 1] = -total_spin - magnetism
  
  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 1
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      total_spin_mag = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
          total_spin_mag -= h[site_nbr][k]
        else:
          total_spin -= 1
          total_spin_mag += h[site_nbr][k]
      
      priorities[i*N+j, 0] = total_spin + total_spin_mag
      priorities[i*N+j, 1] = -total_spin + total_spin_mag
  
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if h[site_nbr1][i%N] > 0:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      total_spin[i//N*N+i%N][1] -= 1
    else:
      total_spin[i//N*N+i%N][0] -= h[site_nbr1][i%N]
      total_spin[i//N*N+i%N][1] += 1

    if h[site_nbr2][i%N] > 0:
      total_spin[i//N*N+i%N][0] += h[site_nbr2][i%N]
      total_spin[i//N*N+i%N][1] -= 1
    else:
      total_spin[i//N*N+i%N][0] -= h[site_nbr2][i%N]
      total_spin[i//N*N+i%N][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N]>0:
      total_spin[i//N*N+i%N][0] += 2*h[site_nbr][i%N]
      total_spin[i//N*N+i%N][1]-=2
    else:
      total_spin[i//N*N+i%N][0]-=2*h[site_nbr][i%N]
      total_spin[i//N*N+i%N][1]+=2
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time17:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N*N+i%N][0] += 1
      total_spin[i//N*N+i%N][1] -= 1
    else:
      total_spin[i//N*N+i%N][0] -= 1
      total_spin[i//N*N+i%N][1] += 1
  return total_spin.flatten().reshape(-1, 2)




#score: {'data2D.txt': -0.0015754629629629625}
#island_id: 1
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      
      if J[0, i, j] > 0:
        total_spin += J[0, i, j]
      elif J[0, i, j] < 0:
        total_spin -= J[0, i, j]
      
      if J[1, i, j] > 0:
        total_spin += J[1, i, j]
      elif J[1, i, j] < 0:
        total_spin -= J[1, i, j]
      
      if J[2, i, j] > 0:
        total_spin += J[2, i, j]
      elif J[2, i, j] < 0:
        total_spin -= J[2, i, j]
      
      if J[3, i, j] > 0:
        total_spin += J[3, i, j]
      elif J[3, i, j] < 0:
        total_spin -= J[3, i, j]
      
      if h[i][j] > 0:
        priorities[i * N + j, 0] += 1
        priorities[i * N + j, 1] -= 1
      else:
        priorities[i * N + j, 0] -= 1
      
      return priorities




#score: {'data2D.txt': -0.0006908950617283956}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.array([[0.5*(h[i][j]+J[0,i,j]-2*J[0,(i+1)%N,j]) for j in range(N)] for i in range(N)])
  return(np.concatenate((priorities.flatten(),np.zeros(N**2)),axis=0).reshape(-1, 2))




#score: {'data2D.txt': -0.2077594135802464}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + ((j-1)%2 - 1)) % N if i else (i-1 + ((N-1)%2 - 1)) % N
      site_nbr4 = (i + ((j+1)%2 - 1)) % N if i==N-1 else (i+1 + ((0)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j] + h[site_nbr2][j] + h[site_nbr3][j] + h[site_nbr4][j]
      if np.sum(h[[site_nbr1, site_nbr2, site_nbr3, site_nbr4], j]) > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.01016219135802469}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      if h[site_nbr1][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr2]!=(i+1)%N:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N]>0:
        total_spin[i//N*N+i%N][0]-=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h[site_nbr][i%N]
        total_spin[i//N*N+i%N][1]-=1
  if sum(total_spin[:,0]) > 0:
    return total_spin.flatten().reshape(-1,2) * np.array([[1,-1]])
  else:
    return total_spin.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.01016219135802469}
#island_id: 0
#version_generated: 2
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      if h[site_nbr1][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr2]!=(i+1)%N:
      if h[site_nbr1][i%N]+h[site_nbr2][i%N]>0:
        total_spin[i//N*N+i%N][0]-=min(h[site_nbr1][i%N], h[site_nbr2][i%N])
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=max(h[site_nbr1][i%N], h[site_nbr2][i%N])
        total_spin[i//N*N+i%N][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.22908410493827164}
#island_id: 2
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  # optimize the priority based on the total spin of each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N]
      priorities[i][1] -= np.sum(J[0][i*N:i*N+N])
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N]) - J[2][i//N,i%N]
      priorities[i][1] += np.sum(J[3][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.001997685185185185}
#island_id: 2
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[[1, 3], i*N:i*N+N]) + J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[[0, 3], i*N:i*N+N]) - J[2][i//N,i%N]

  return priorities




#score: {'data2D.txt': -0.0013800925925925927}
#island_id: 2
#version_generated: 2
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N]
    else:
      priorities[i][0] += np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N]
    
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N] - np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += J[2][i//N,i%N] + np.sum(J[1][i*N:i*N+N])
  
  return(priorities)




#score: {'data2D.txt': 0.2289726851851852}
#island_id: 2
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  # calculate the priority based on the site interactions
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] -= J[2][i//N,i%N]
      priorities[i][1] += J[3][i*N:i*N+N].sum()
    else:
      priorities[i][0] += J[2][i//N,i%N]
      priorities[i][1] -= J[0][i*N:i*N+N].sum()
      
  return(priorities)




#score: {'data2D.txt': -0.3428322530864187}
#island_id: 2
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1 - total_spin
      priorities[i][1] -= 1 + J[2][i//N,i%N]
    else:
      priorities[i][0] -= 1 + total_spin
      priorities[i][1] += 1 - J[2][i//N,i%N]
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[3][i*N:i*N+N].sum()
    else:
      priorities[i][1] += J[0][i*N:i*N+N].sum()
      
  return(priorities)




#score: {'data2D.txt': 0.2290220679012346}
#island_id: 2
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])

  # adjust the priority based on the interaction with itself
  for i in range(N**2):
    if h[(i % N + ((i//N-1)%2 - 1)) % N][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]

  return(priorities)




#score: {'data2D.txt': 0.02121188271604938}
#island_id: 3
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4): 
        if k == 0:
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 1 and j != 0: 
          site_nbr = (i + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 2 and j != N-1: 
          site_nbr = (i + ((j+1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 3 and i != 0: 
          site_nbr = (i-1 + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]

      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += np.sum(J[:,i,j]) + h[site_nbr][j]
        priorities[i*N+j,1] -= np.sum(J[:,i,j]) + h[site_nbr][j]
      elif total_spin < 0:
        priorities[i*N+j,0] -= np.sum(J[:,i,j]) + h[site_nbr][j]
        priorities[i*N+j,1] += np.sum(J[:,i,j]) + h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': -0.0014526234567901234}
#island_id: 3
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N

      for k in range(4): 
        if k == 0:
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 1 and j != 0: 
          site_nbr = (i + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 2 and j != N-1: 
          site_nbr = (i + ((j+1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]
        elif k == 3 and i != 0: 
          site_nbr = (i-1 + ((j-1)%2 - 1)) % N
          if J[k,i,j] > 0:
            total_spin += J[k,i,j]
          else:
            total_spin -= J[k,i,j]

      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1

  return(priorities)




#score: {'data2D.txt': 0.013300154320987655}
#island_id: 3
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in range(4): 
        if k == 0:
          total_spin += J[k,i,j]
        elif k == 1 and j != 0: 
          site_nbr = (i + ((j-1)%2 - 1)) % N
          total_spin += J[k,i,j]
        elif k == 2 and j != N-1: 
          site_nbr = (i + ((j+1)%2 - 1)) % N
          total_spin += J[k,i,j]
        elif k == 3 and i != 0: 
          site_nbr = (i-1 + ((j-1)%2 - 1)) % N
          total_spin += J[k,i,j]

      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1

  return(priorities)




#score: {'data2D.txt': -0.0003381172839506173}
#island_id: 3
#version_generated: 2
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(J[k,i,j] * h[site_nbr][k] for k in range(4))
      if J[0,i,j] > 0:
        total_spin += J[0,i,j]
      else:
        total_spin -= J[0,i,j]

      priorities[i*N+j,0] = total_spin
      priorities[i*N+j,1] = -total_spin

  return(priorities)




#score: {'data2D.txt': -0.00899027777777778}
#island_id: 1
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      if h[site_nbr][i%N] > 0:
        priorities[i] = [2*abs(site_magnetism), -2*abs(site_magnetism)]
      else:
        priorities[i] = [-2*abs(site_magnetism), 2*abs(site_magnetism)]
    elif site_magnetism + neighbor_interactions < 0:
      if h[site_nbr][i%N] > 0:
        priorities[i] = [2*abs(site_magnetism), -2*abs(site_magnetism)]
      else:
        priorities[i] = [-2*abs(site_magnetism), 2*abs(site_magnetism)]
    else:
      if h[site_nbr][i%N] > 0:
        priorities[i] = [1, -1]
      else:
        priorities[i] = [-1, 1]

  return priorities




#score: {'data2D.txt': 0.001897376543209876}
#island_id: 1
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
     if J[k,i%N,i//N] > 0:
       neighbor_interactions += 1
     else:
       neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = site_magnetism - neighbor_interactions
      priorities[i][1] = -site_magnetism + neighbor_interactions
    else:
      priorities[i][0] = -site_magnetism - neighbor_interactions
      priorities[i][1] = site_magnetism - neighbor_interactions

  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_magnetism = h[site_nbr][i%N]
    
    neighbor_interactions = J[:,i//N].dot(J[:,i//N].T)

    if np.sum(neighbor_interactions) > 0:
      priorities[i] = [np.sum(neighbor_interactions), -np.sum(neighbor_interactions)]
    else:
      priorities[i] = [-np.sum(neighbor_interactions), np.sum(neighbor_interactions)]

  return priorities




#score: {'data2D.txt': -0.34314521604938164}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(3):
    site = (i + ((j-1)%2 - 1)) % N
    if h[site][j] > 0:
      total_spin[i*N+j][1] += 1
    else:
      total_spin[i*N+j][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.157948919753086}
#island_id: 0
#version_generated: 2
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0,i][site_nbr]%N==i:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[site_nbr][j]>0:
          total_spin[i*N+j][1]-=1
        else:
          total_spin[i*N+j][1]+=1
      elif J[0,i][site_nbr]!=(i+1)%N:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][j]>0:
          total_spin[i*N+j][0]-=h[site_nbr][j]
          total_spin[i*N+j][1]+=1
        else:
          total_spin[i*N+j][0]+=h[site_nbr][j]
          total_spin[i*N+j][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.07976527777777775}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
  for i in range(N):
    site_nbr = (i % N + ((N-1)//2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i*N+i,0] += 1
      priorities[i*N+i,1] -= 1
    else:
      priorities[i*N+i,0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.01072422839506164}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j]) + h[i][j]
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.07004058641975308}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N):
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if h[site_nbr][i] > 0:
      priorities[i*N+i,0] -= 1
      priorities[i*N+i,1] += 1
    else:
      priorities[i*N+i,0] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.188633796296296}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr1][j] + h[site_nbr2][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
      
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for k in range(N):
    for j in range(N):
      site = (k + ((j-1)%2 - 1)) % N
      if h[site][j] > 0:
        priorities[k*N+j,0] += 1
        priorities[k*N+j,1] -= 1
      else:
        priorities[k*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.1461510802469136}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.02780632716049383}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (j + ((i-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][i]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.1219662037037037}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  
  return(priorities)




#score: {'data2D.txt': 0.018307561728395066}
#island_id: 3
#version_generated: 2
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += np.sum(J[:,i,j])
        priorities[i*N+j,1] -= 2
      else:
        priorities[i*N+j,0] -= np.sum(J[:,i,j])
        
  return(priorities)




#score: {'data2D.txt': 0.21201064814814827}
#island_id: 2
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1

  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]

  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N]) + J[2][i//N,i%N]
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N]) - J[2][i//N,i%N]

  return(priorities)




#score: {'data2D.txt': -0.2224375}
#island_id: 2
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,j]
      else:
        priorities[i*N+j][0] -= np.sum(J[0][i*N:i*N+N]) - J[2][i//N,j]
        
  return(priorities)




#score: {'data2D.txt': 0.00012947530864197487}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[site_nbr][i%N] > 0:
      total_spin += 1
      total_spin -= 1
    else:
      total_spin -= 1
      total_spin += 1
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.00027145061728395026}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if total_spin > 0:
      priorities[i,0] = np.sum((h + h.T - 2*h[site_nbr]).flatten())
      priorities[i,1] = -priorities[i,0]
    else:
      priorities[i,0] = np.sum((h + h.T - 2*h[site_nbr]).flatten())
  
  return(priorities)




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N]:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
    
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    elif h[site_nbr][i%N] < 0:
      priorities[i,0] -= 1
      priorities[i,1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0011766975308641974}
#island_id: 3
#version_generated: 2
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = sum(h[site_nbr][j] for j in range(4) if J[j,i%N,i//N])
    
    if total_spin > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.3427591049382705}
#island_id: 2
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
    
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
    
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
    
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[3][i*N:i*N+N])
    
  return(priorities)




#score: {'data2D.txt': 0.3426594135802458}
#island_id: 2
#version_generated: 2
#generate time17:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # calculate total spin for each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
        
  # calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] -= np.sum(J[0][i*N:i*N+N]) + J[2][i//N,i%N] - priority_total[1]
    else:
      priority_total = total_spin[i//N][i%N]
      priorities[i][0] += np.sum(J[3][i*N:i*N+N]) + J[2][i//N,i%N] + priority_total[1]
      
  # consider the interactions between sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= J[2][i//N,i%N]
    else:
      priorities[i][1] += J[2][i//N,i%N]
      
  # calculate priority based on neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[1][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[1][i*N:i*N+N])
      
  # adjust the priority based on the spin of neighboring sites
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= np.sum(J[3][i*N:i*N+N])
    else:
      priorities[i][1] += np.sum(J[0][i*N:i*N+N])
      
  return(priorities)




#score: {'data2D.txt': 0.005565277777777778}
#island_id: 3
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    site_magnetisms = [h[site_nbr][i%N] for site_nbr in site_nbrs]
    
    total_spin = np.sum(J[:,i//N,i%N]) + sum(site_magnetisms)
    
    if total_spin > 0:
      priorities[i,0] -= len([1 for magnetism in site_magnetisms if magnetism > 0])
      priorities[i,1] += len([1 for magnetism in site_magnetisms if magnetism < 0])
    else:
      priorities[i,0] += len([1 for magnetism in site_magnetisms if magnetism > 0])
      
  return(priorities)




#score: {'data2D.txt': 0.040474537037037066}
#island_id: 3
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    else:
      priorities[i][0] += 1
      
  # additional improvement: calculate the sum of J and h for each site and add it to the priority
  for i in range(N2):
    total_spin = np.sum(J[:,i//N,i%N]) + h[(i//N)%N][i%N]
    if total_spin > 0:
      priorities[i,0] -= 1
      priorities[i,1] += 1
    else:
      priorities[i,0] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.025572067901234594}
#island_id: 3
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum(J[:,i,j])
      total_spin += h[site_nbr][j]
      
      if total_spin > 0:
        priorities[i*N+j,0] -= 1
        priorities[i*N+j,1] += 1
      else:
        priorities[i*N+j,0] += 1
        
  for k in range(3):
    site = (i + ((k-1)%2 - 1)) % N
    if h[site][j] > 0:
      priorities[i*N+j,0] -= 1
      priorities[i*N+j,1] += 1
    else:
      priorities[i*N+j,0] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.005534104938271605}
#island_id: 0
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((i//N-1)%2 - 1)) % N, (i % N + ((i//N-1)%2)) % N]
    total_spin[i//N*N+i%N][0] += sum(J[0,i%N][site_nbr] for site_nbr in site_nbrs)
    if any(h[site_nbr][i%N] > 0 for site_nbr in site_nbrs):
      total_spin[i//N*N+i%N][1] -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] > 0])
    else:
      total_spin[i//N*N+i%N][1] += len([site_nbr for site_nbr in site_nbrs if h[site_nbr][i%N] < 0])
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.017405092592592594}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for j in range(4):
      k = (j+3)%4
      site_nbr_k = (site_nbr + ((k-1)%2 - 1)) % N
      if J[k, i//N, site_nbr_k] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.18842453703703702}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(4):
      site_nbr_k = (i % N + ((k-1)%2 - 1)) % N
      if J[k, i//N, site_nbr_k] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    priorities[i][0] += total_spin
    priorities[i][1] -= 2*total_spin

  return(priorities)




#score: {'data2D.txt': 0.17778348765432123}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    
    for j in range(N):
      total_spin = 0
      for k in range(4):
        if J[k, i, (j+k%2)%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [total_spin, -total_spin]
      else:
        priorities[i*N+j] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr_k = (j + k%2) % N
        if J[k, i, site_nbr_k] > 0:
          total_spin += h[site_nbr][site_nbr_k]
        else:
          total_spin -= h[site_nbr][site_nbr_k]
      
      if total_spin > 0:
        priorities[i*N+j] += [total_spin, -total_spin]
      else:
        priorities[i*N+j] -= [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03461774691358025}
#island_id: 3
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(J[:,i,j])
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1

  for k in range(N):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site][j] > 0:
        for i in range(N):
          priorities[i*N+j,0] += 1
          priorities[i*N+j,1] -= 1
      else:
        for i in range(N):
          priorities[i*N+j,0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.1154547839506173}
#island_id: 3
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + (((i//N)-1)%2 - 1)) % N
    
    if h[site_nbr1][i%N] > 0:
      priorities[i][0] += 2
      priorities[i][1] -= 2
    elif h[site_nbr2][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      
      if total_spin > 0:
        priorities[i*N+j,0] += 2
        priorities[i*N+j,1] -= 2
      else:
        priorities[i*N+j,0] -= 2
        
  return(priorities)




#score: {'data2D.txt': 0.015637499999999912}
#island_id: 3
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(J[:,i,j])
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      else:
        priorities[i*N+j,0] -= 1
        
      if total_spin > 0:
        priorities[i*N+j,0] += 1
        priorities[i*N+j,1] -= 1
      elif total_spin < 0:
        priorities[i*N+j,0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 3
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(J[:,site_nbr,i%N])
    
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
      priorities[i,1] -= 1
    else:
      priorities[i,0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%2) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time17:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + (j-1)%2 - 1) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      site_nbr3 = (i - 1) % N
      site_nbr4 = (i + 1) % N
      if j == 0:
        site_nbr3 = i
      elif j == N-1:
        site_nbr4 = i

      total_spin[i*N+j][0] += h[site_nbr3][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      total_spin[i*N+j][0] += h[site_nbr4][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 2
        total_spin[i*N+j][1] += 2
      else:
        total_spin[i*N+j][0] += 2
        total_spin[i*N+j][1] -= 2

  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]

  return priorities




#score: {'data2D.txt': -0.0010628086419753084}
#island_id: 0
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N*N, 2))
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1

  site_nbr = (N-1) % N
  for i in range(N):
    if h[site_nbr][i] > 0:
      total_spin[i*N+site_nbr][0] -= 2
      total_spin[i*N+site_nbr][1] += 2
    else:
      total_spin[i*N+site_nbr][0] += 2
      total_spin[i*N+site_nbr][1] -= 2

  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[i*N+j][1]
        priorities[i*N+j][1] = total_spin[i*N+j][0]
      else:
        priorities[i*N+j][0] = total_spin[i*N+j][1]
        priorities[i*N+j][1] = -total_spin[i*N+j][0]

  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] = total_spin + N**2
        priorities[i*N+j][1] = -total_spin - N**2
      else:
        priorities[i*N+j][0] = -total_spin - N**2
        priorities[i*N+j][1] = total_spin + N**2
      
  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = np.sum([1 if J[k,i,j] > 0 else -1 for k in range(4)])
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin
        
  return(priorities)




#score: {'data2D.txt': -0.049664660493827284}
#island_id: 1
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      spin_h = h[site_nbr][j]
      
      priorities[i*N+j][0] += (1 - 2 * np.sign(spin_h)) * total_spin
      priorities[i*N+j][1] -= (1 - 2 * np.sign(spin_h)) * total_spin
      
  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -total_spin
        priorities[i*N+j][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 2
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin = sum([h[(i+((k-1)%2 - 1))%N][j] for k in range(4)])
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        total_spin = sum([-h[(i+((k-1)%2 - 1))%N][j] for k in range(4)])
        priorities[i*N+j][0] -= total_spin/8.0
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        total_spin += -0.5*J[k,i,j]*interacting_spins[k,i,j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        total_spin += -0.5*J[k,i,j]*interacting_spins[k,i,j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.22751126543209882}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      magnetism = h[site_nbr][j]
      
      priorities[i*N+j, :] = [total_spin + magnetism, -total_spin - magnetism]
  
  return(priorities)




#score: {'data2D.txt': 0.17755910493827173}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in [0,1]:
        site_nbr = (i + ((j+(-k)%2 - 1)) % N)
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[i][j] > 0:
        priorities[i*N+j] = [total_spin, -total_spin]
      else:
        priorities[i*N+j] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      priority_total = [total_spin, -total_spin]
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [priority_total[1], -priority_total[0]]
      else:
        priorities[i*N+j] = [-priority_total[0], priority_total[1]]

  return(priorities)




#score: {'data2D.txt': 0.12083101851851866}
#island_id: 1
#version_generated: 2
#generate time17:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time17:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.16723379629629584}
#island_id: 2
#version_generated: 2
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # calculate interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[site_nbr2][j]
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  # calculate interaction with all neighbors
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin = sum([h[(k+((l-1)%2 - 1))%N][j] for k, l in itertools.product(range(N), range(4))])
        priorities[i*N+j][0] += total_spin/16.0
        priorities[i*N+j][1] -= total_spin/16.0
      else:
        total_spin = sum([-h[(k+((l-1)%2 - 1))%N][j] for k, l in itertools.product(range(N), range(4))])
        priorities[i*N+j][0] -= total_spin/16.0
        
  return(priorities)




#score: {'data2D.txt': -0.2767473765432094}
#island_id: 2
#version_generated: 2
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # Calculate interacting spins
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  
  # Calculate site-specific priorities
  for i in range(N):
    for j in range(N):
      total_spin = sum([h[(i+((k-1)%2 - 1))%N][j] for k in range(4)])
      
      # Add magnetism to the priority
      total_spin += h[i][j]
      
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.0015004629629629632}
#island_id: 2
#version_generated: 2
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  return(priorities)




#score: {'data2D.txt': -0.1471930555555557}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k][i,j]
        else:
          total_spin -= J[k][i,j]
      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= total_spin
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        if i % 2 == 0 and k == 0: 
          site_nbr = (i + 1) % N
        elif i % 2 != 0 and k == 3:
          site_nbr = (i - 1) % N
        else: 
          site_nbr = (j + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][int((k-1)/2)]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.06621527777777764}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[2, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[3, i, j] < 0:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0011587962962962962}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
      return(priorities)




#score: {'data2D.txt': 0.06621527777777764}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[2, i, j] < 0:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[3, i, j] < 0:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.06621527777777764}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0:
          priorities[i*N+j][0] -= 1
          
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1 * len([k for k, site_nbr in enumerate(site_nbrs) if J[0, i, j] == J[k, site_nbr, j]])
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1 * len([k for k, site_nbr in enumerate(site_nbrs) if J[0, i, j] == -J[k, site_nbr, j]])
  return(priorities)




#score: {'data2D.txt': -0.026645524691358023}
#island_id: 2
#version_generated: 2
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      priority_total = [0, 0]
      for k in range(4):
        if h[site_nbr][k] > 0:
          priority_total[0] += 1
          priority_total[1] -= 1
        else:
          priority_total[0] -= 1
        priorities[i*N+j][0] += J[k][i][j]*priority_total[0]
        priorities[i*N+j][1] -= J[k][i][j]*priority_total[1]
  return(priorities)




#score: {'data2D.txt': 0.0041612654320987656}
#island_id: 2
#version_generated: 2
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.03578533950617283}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      for k in [0,1]:
        if J[k][site_nbr][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      if h[i][j] > 0:
        priorities[i*N+j] = [total_spin+1, -total_spin-1]
      else:
        priorities[i*N+j] = [-total_spin-1, total_spin+1]
  
  return(priorities)




#score: {'data2D.txt': 0.005383179012345678}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in [0,1]:
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k][site_nbr][i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.17755910493827173}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr_sum = 0
      
      # Calculate sum of interactions with nearest neighbors
      for k in [0,1]:
        site_nbr = (i + ((j+(-k)%2 - 1)) % N)
        if J[k,i,j] > 0:
          site_nbr_sum += 1
        else:
          site_nbr_sum -= 1
      
      # Calculate total spin based on magnetism and neighbor interactions
      if h[i][j] > 0:
        priorities[i*N+j] = [site_nbr_sum, -site_nbr_sum]
      else:
        priorities[i*N+j] = [-site_nbr_sum, site_nbr_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.14481496913580266}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # calculate the priority based on the current state
    for k in range(4):
      site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # calculate the priority based on the interaction with neighboring sites
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # calculate the priority based on the current state
    for k in range(4):
      site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # calculate the priority based on the total spin
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # calculate the priority based on the current state
    for k in range(4):
      site_nbr = site_nbrs[k]
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.019379166666666666}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the current state and interactions
    for k in range(4):
      neighbor = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[neighbor][i%N]
        priorities[i][0] -= h[neighbor][i%N]
        priorities[i][1] += h[neighbor][i%N]
      else:
        total_spin -= h[neighbor][i%N]
        priorities[i][0] += h[neighbor][i%N]
        priorities[i][1] -= h[neighbor][i%N]
    
    # Adjust the priority based on magnetism
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': -0.05778194444444451}
#island_id: 1
#version_generated: 2
#generate time18:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0, i, j] > 0:
        total_spin += J[0, i, j]
      elif J[0, i, j] < 0:
        total_spin -= J[0, i, j]
      
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.0023115740740740744}
#island_id: 1
#version_generated: 2
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, i//N] > 0:
      total_spin += 1
    elif J[0, i%N, i//N] < 0:
      total_spin -= 1
    
    if J[1, i%N, (i//N+N-1)%N] > 0:
      total_spin += 1
    elif J[1, i%N, (i//N+N-1)%N] < 0:
      total_spin -= 1
    
    if J[2, i//N, i%N] > 0:
      total_spin += 1
    elif J[2, i//N, i%N] < 0:
      total_spin -= 1
    
    if J[3, (i//N+N-1)%N, i%N] > 0:
      total_spin += 1
    elif J[3, (i//N+N-1)%N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.08575293209876564}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      if h[i][j] > 0:
        total_spin = 1
      else:
        total_spin = -1
        
      for k in range(4):
        if J[k, i, j] > 0:
          total_spin += 1
        elif J[k, i, j] < 0:
          total_spin -= 1
      
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.06621527777777764}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      if i > 0:
        total_spin += h[(i-1)%N][j]
      if i < N-1:
        total_spin += h[(i+1)%N][j]
      if j > 0:
        total_spin += J[1, i, j]
      if j < N-1:
        total_spin += J[3, i, j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0:
          priorities[i*N+j][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.23762052469135783}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += J[k, i, j]
          
        if J[k, i, j] > 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] -= 1
          
  return(priorities)




#score: {'data2D.txt': -0.0006239197530864195}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      spin_energy = sum([h[site_nbr][jj] if J[0, i, jj] > 0 else -h[site_nbr][jj] for jj in range(N) if J[0, i, jj] != 0])
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += spin_energy
        priorities[i*N+j][1] -= 2*spin_energy
      else:
        priorities[i*N+j][0] -= spin_energy
        
  return(priorities)




#score: {'data2D.txt': -0.15767083333333357}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += J[k, i, j]
          
        if J[k, i, j] > 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] -= 1
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += J[0, i, j]
        priorities[i*N+j][1] -= J[0, i, j]
        
  return(priorities)




#score: {'data2D.txt': -0.23762052469135783}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] -= 1
          
  return(priorities)




#score: {'data2D.txt': -0.24375663580246895}
#island_id: 3
#version_generated: 2
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += J[k, i, j]
          
        if J[k, i, j] > 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif J[k, i, j] < 0 and h[site_nbr][j] > 0:
          priorities[i*N+j][0] -= 1
          
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3, i, j] > 0 and h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[3, i, j] < 0 and h[site_nbr][j] > 0:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N

      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.0028307098765432094}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i // N - 1) % N
    site_nbr2 = (i % N + ((i // N - 1) % 2 - 1)) % N

    total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
    if h[site_nbr1][i%N]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1

    total_spin[i//N*N+i%N][0] += J[(i // N) % 2, i%N][site_nbr2]
    if h[site_nbr2][i%N]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.11511774691358027}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = ((i + j) % N)
      site_nbr2 = ((i - 1 + j) % N)
      site_nbr3 = ((i + (j-1)%2 - 1)) % N
      site_nbr4 = ((i + (j+1)%2 - 1)) % N

      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      total_spin[i*N+j][0] += J[0,i%N][site_nbr3]*h[site_nbr3][j]
      if h[site_nbr3][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      total_spin[i*N+j][0] += J[0,i%N][site_nbr4]*h[site_nbr4][j]
      if h[site_nbr4][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.34319120370370265}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    if i % (N * N) < N:
      site_nbr1 = ((i // N + i % N) % N)
      site_nbr2 = ((i // N - 1) % N)
    else:
      site_nbr1 = ((i // N - 1) % N)
      site_nbr2 = (i % N)

    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
      if h[site_nbr1][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1

    if J[0,i%N][site_nbr2]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr2][i%N]
      if h[site_nbr2][i%N]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.0883918209876543}
#island_id: 3
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.004785030864197524}
#island_id: 3
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 2
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      total_magnetism = h[i][j]
      if total_spin > 0:
        priorities[i*N+j][0] += 3
        priorities[i*N+j][1] -= 3
      elif total_spin < 0:
        priorities[i*N+j][0] -= 3
      if total_magnetism > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif total_magnetism < 0:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.0883918209876543}
#island_id: 3
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 2
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 2
      if total_spin > 0:
        priorities[i*N+j][0] += 4
        priorities[i*N+j][1] -= 4
      elif total_spin < 0:
        priorities[i*N+j][0] -= 4
  return(priorities)




#score: {'data2D.txt': 0.007288425925925928}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  h_flatten = h.flatten()
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h_flatten[site_nbr1]
      if h_flatten[site_nbr1]>0:
        total_spin[i//N*N+i%N][1]-=1
      else:
        total_spin[i//N*N+i%N][1]+=1
    elif J[0,i%N][site_nbr2]!=(i+1)%N:
      if h_flatten[site_nbr1]>0:
        total_spin[i//N*N+i%N][0]-=h_flatten[site_nbr1]
        total_spin[i//N*N+i%N][1]+=1
      else:
        total_spin[i//N*N+i%N][0]+=h_flatten[site_nbr1]
        total_spin[i//N*N+i%N][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      elif h[site_nbr2][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.09068966049382711}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * (h[site_nbr1][j] > 0) - 1
        priorities[i*N+j][1] -= 3 * (h[site_nbr1][j] > 0) + 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * (h[site_nbr1][j] > 0) - 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * (h[i][site_nbr2] > 0) - 1
        priorities[i*N+j][1] -= 3 * (h[i][site_nbr2] > 0) + 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * (h[i][site_nbr2] > 0) - 1
      if total_spin > 0:
        priorities[i*N+j][0] += 4
        priorities[i*N+j][1] -= 4
      elif total_spin < 0:
        priorities[i*N+j][0] -= 4
  return(priorities)




#score: {'data2D.txt': 0.09982916666666665}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 * abs(interaction)
        priorities[i*N+j][1] -= 3 * abs(interaction)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 * abs(interaction)
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.08115077160493815}
#island_id: 3
#version_generated: 2
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      for j in range(N):
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0006013888888888885}
#island_id: 1
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, i//N] > 0:
      total_spin += 1
    elif J[0, i%N, i//N] < 0:
      total_spin -= 1
    
    if J[1, i%N, (i//N+N-1)%N] > 0:
      total_spin += 1
    elif J[1, i%N, (i//N+N-1)%N] < 0:
      total_spin -= 1
    
    if J[2, i//N, i%N] > 0:
      total_spin += 1
    elif J[2, i//N, i%N] < 0:
      total_spin -= 1
    
    if J[3, (i//N+N-1)%N, i%N] > 0:
      total_spin += 1
    elif J[3, (i//N+N-1)%N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(J[:, i%N, i//N])
      priorities[i][1] = -total_spin - np.sum(J[:, i%N, i//N])
    else:
      priorities[i][0] = -total_spin - np.sum(J[:, i%N, i//N])
      priorities[i][1] = total_spin + np.sum(J[:, i%N, i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.002127932098765432}
#island_id: 1
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    if J[0, i%N, i//N] > 0:
      total_spin += 1
    elif J[0, i%N, i//N] < 0:
      total_spin -= 1
    
    if J[1, i%N, (i//N+N-1)%N] > 0:
      total_spin += 1
    elif J[1, i%N, (i//N+N-1)%N] < 0:
      total_spin -= 1
    
    if J[2, i//N, i%N] > 0:
      total_spin += 1
    elif J[2, i//N, i%N] < 0:
      total_spin -= 1
    
    if J[3, (i//N+N-1)%N, i%N] > 0:
      total_spin += 1
    elif J[3, (i//N+N-1)%N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.007799228395061728}
#island_id: 1
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i // N + ((j - 1) % 2) - 1) % N
      total_spin += J[j, site_nbr, i % N]
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0023115740740740744}
#island_id: 1
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, i//N] > 0:
      total_spin += 1
    elif J[0, i%N, i//N] < 0:
      total_spin -= 1
    
    if J[1, i%N, (i//N+N-1)%N] > 0:
      total_spin += 1
    elif J[1, i%N, (i//N+N-1)%N] < 0:
      total_spin -= 1
    
    if J[2, i//N, i%N] > 0:
      total_spin += 1
    elif J[2, i//N, i%N] < 0:
      total_spin -= 1
    
    if J[3, (i//N+N-1)%N, i%N] > 0:
      total_spin += 1
    elif J[3, (i//N+N-1)%N, i%N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.157948919753086}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0,i][site_nbr]%N==i:
        total_spin[i*N+j][0] += h[site_nbr][j]
        if h[site_nbr][j]>0:
          total_spin[i*N+j][1]-=1
        else:
          total_spin[i*N+j][1]+=1
      elif J[0,i][site_nbr]!=(i+1)%N:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][j]>0:
          total_spin[i*N+j][0]-=h[site_nbr][j]
          total_spin[i*N+j][1]+=1
        else:
          total_spin[i*N+j][0]+=h[site_nbr][j]
          total_spin[i*N+j][1]-=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.07085756172839545}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if J[0,i][site_nbr]%N==i:
        if h[site_nbr][j]>0:
          total_spin[i*N+j][1]-=1
        else:
          total_spin[i*N+j][1]+=1
      elif J[0,i][site_nbr]!=(i+1)%N:
        if h[site_nbr][j]>0:
          total_spin[i*N+j][0]-=h[site_nbr][j]
          total_spin[i*N+j][1]+=1
        else:
          total_spin[i*N+j][0]+=h[site_nbr][j]
          total_spin[i*N+j][1]-=1
      else:
        if h[i][j]>0:
          total_spin[i*N+j][0]+=1
          total_spin[i*N+j][1]-=1
        else:
          total_spin[i*N+j][0]-=1
          total_spin[i*N+j][1]+=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j]>0:
        total_spin[i*N+j][1]-=1
      else:
        total_spin[i*N+j][1]+=1
      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j]>0:
        total_spin[i*N+j][1]-=1
      else:
        total_spin[i*N+j][1]+=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N]>0:
      delta_h = 2*h[site_nbr][i%N]
      total_spin[i//N*N+i%N][0] += delta_h
      total_spin[i//N*N+i%N][1]-=delta_h
    else:
      delta_h = -2*h[site_nbr][i%N]
      total_spin[i//N*N+i%N][0]-=delta_h
      total_spin[i//N*N+i%N][1]+=delta_h

  # Calculate priority for each site
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    if total_spin[i//N*N+i%N][0] > 0:
      priorities[i//N*N+i%N][1] -= total_spin[i//N*N+i%N][0]
    else:
      priorities[i//N*N+i%N][0] += -total_spin[i//N*N+i%N][0]

  return priorities




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.21338410493827162}
#island_id: 3
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] * (h[i][j] - 2) + J[1, i, j] * (h[site_nbr1][j] - 2)
      if interaction > 0:
        priorities[i*N+j][0] += 3 * abs(interaction)
        priorities[i*N+j][1] -= 3 * abs(interaction)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 * abs(interaction)
  return(priorities)




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      elif h[site_nbr2][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.17020941358024638}
#island_id: 0
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      elif h[site_nbr2][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.0006168209876543209}
#island_id: 1
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i%N, i//N] > 0:
      total_spin += 1
    elif J[0, i%N, i//N] < 0:
      total_spin -= 1
    
    if J[1, i%N, (i//N+N-1)%N] > 0:
      total_spin += 1
    elif J[1, i%N, (i//N+N-1)%N] < 0:
      total_spin -= 1
    
    for j in range(2):
      if J[j+2, i//N, i%N] > 0:
        total_spin += 1
      elif J[j+2, i//N, i%N] < 0:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0023115740740740744}
#island_id: 1
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in [(0, i%N, i//N), (1, i%N, (i//N+N-1)%N), (2, i//N, i%N), (3, (i//N+N-1)%N, i%N)]:
      if J[j[0], j[1], j[2]] > 0:
        total_spin += 1
      elif J[j[0], j[1], j[2]] < 0:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0009029320987654326}
#island_id: 1
#version_generated: 2
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for j in range(4):
      if J[j,i%N,(i//N+N-1)%N] > 0:
        total_spin += 1
      elif J[j,i%N,(i//N+N-1)%N] < 0:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.015044598765432099}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i * N + j, 0] += J[0, i, j]
        priorities[i * N + j, 1] -= J[1, i, j]
        
        if (i + 1) % N != 0:  # Check for right boundary
          priorities[i * N + j, 0] += J[2, i, j]
          priorities[i * N + j, 1] -= J[3, i, j]
          
      else:
        priorities[i * N + j, 0] -= J[0, i, j]
        priorities[i * N + j, 1] += J[1, i, j]
        
        if (i + 1) % N != 0:  # Check for right boundary
          priorities[i * N + j, 0] -= J[2, i, j]
          priorities[i * N + j, 1] += J[3, i, j]
          
  return priorities




#score: {'data2D.txt': -0.037851388888888886}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  # Calculate the magnetism term
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j - 1) % 2 - 1)) % N
      
      if h[i][j] > 0:
        priorities[i * N + j, 0] += 1
        priorities[i * N + j, 1] -= 1
      else:
        priorities[i * N + j, 0] -= 1
      
      # Add the interaction terms with only nearest neighbors
      for k in range(4):
        if J[k, i, j] > 0:
          if k == 0 or k == 2:  # Up and down interactions
            priorities[i * N + j, 0] += J[k, i, j]
            priorities[i * N + j, 1] -= J[k, i, j]
          else:  # Left and right interactions
            site_nbr = (i + ((j - 1) % 2 - 1)) % N
            if k == 1:  # Left interaction
              priorities[site_nbr * N + min(i, site_nbr), 0] += J[k, i, j]
              priorities[site_nbr * N + min(i, site_nbr), 1] -= J[k, i, j]
            else:  # Right interaction
              priorities[site_nbr * N + max(i, site_nbr), 0] += J[k, i, j]
              priorities[site_nbr * N + max(i, site_nbr), 1] -= J[k, i, j]
        elif J[k, i, j] < 0:
          if k == 0 or k == 2:  # Up and down interactions
            priorities[i * N + j, 0] -= J[k, i, j]
          else:  # Left and right interactions
            site_nbr = (i + ((j - 1) % 2 - 1)) % N
            if k == 1:  # Left interaction
              priorities[site_nbr * N + min(i, site_nbr), 0] -= J[k, i, j]
            else:  # Right interaction
              priorities[site_nbr * N + max(i, site_nbr), 0] -= J[k, i, j]

  return priorities




#score: {'data2D.txt': -0.0027239197530864196}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = -site_magnetism - neighbor_interactions
      priorities[i][1] = site_magnetism + neighbor_interactions
    else:
      priorities[i][0] = site_magnetism + neighbor_interactions
      priorities[i][1] = -site_magnetism - neighbor_interactions
  
  return priorities




#score: {'data2D.txt': -0.003604783950617284}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism > 0:
      priorities[i][0] = -neighbor_interactions
      priorities[i][1] = neighbor_interactions
    elif site_magnetism < 0:
      priorities[i][0] = neighbor_interactions
      priorities[i][1] = -neighbor_interactions
    else:
      if neighbor_interactions > 0:
        priorities[i][0] = -1
        priorities[i][1] = 1
      elif neighbor_interactions < 0:
        priorities[i][0] = 1
        priorities[i][1] = -1
      else:
        priorities[i][0] = 0.5
        priorities[i][1] = 0.5
  
  return priorities




#score: {'data2D.txt': 0.010623919753086419}
#island_id: 1
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = (site_magnetism - 2*neighbor_interactions)**2
      priorities[i][1] = (-site_magnetism + 2*neighbor_interactions)**2
    else:
      priorities[i][0] = (-site_magnetism - 2*neighbor_interactions)**2
      priorities[i][1] = (site_magnetism - 2*neighbor_interactions)**2
  
  return priorities




#score: {'data2D.txt': -0.29572608024691294}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      else:
        priorities[i*N+j][0] -= abs(total_spin)
  
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    total_spin = sum([h[site_nbr][k] for k in range(4)])
    
    if h[i][0] > 0:
      priorities[i*N][0] += abs(total_spin/8.0)
      priorities[i*N][1] -= abs(total_spin/8.0)
    else:
      priorities[i*N][0] -= abs(total_spin/8.0)
  
  for j in range(N):
    site_nbr = (j + ((N-1)%2 - 1)) % N
    total_spin = sum([h[k][site_nbr] for k in range(4)])
    
    if h[0][j] > 0:
      priorities[N*j][0] += abs(total_spin/8.0)
      priorities[N*j][1] -= abs(total_spin/8.0)
    else:
      priorities[N*j][0] -= abs(total_spin/8.0)
  
  return(priorities)




#score: {'data2D.txt': -0.172191203703704}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = [np.roll(h, i, axis=1) for i in range(4)] + [np.roll(np.roll(h, i, axis=0), j, axis=1) for i in range(2) for j in range(2)]
  for i in range(N):
    for j in range(N):
      total_spin = sum([h[i][j] * (1 if interacting_spins[k][i][j] > 0 else -1) for k in range(8)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/16.0
        priorities[i*N+j][1] -= total_spin/16.0
      else:
        priorities[i*N+j][0] -= total_spin/16.0
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on site interactions and magnetism
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on neighboring sites
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k, i%N, i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Calculate the priority based on site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': -8.31790123456784e-05}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N//2):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j*2] > 0:
        priorities[i*N+j*2][0] += total_spin/8.0
        priorities[i*N+j*2][1] -= total_spin/8.0
      else:
        priorities[i*N+j*2][0] -= total_spin/8.0

  return(priorities)




#score: {'data2D.txt': 0.00021003086419753238}
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # Calculate total spin at each site
  total_spin = np.zeros((N, N))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j] += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin[i][j]/8.0
        priorities[i*N+j][1] -= total_spin[i][j]/8.0
      else:
        priorities[i*N+j][0] -= total_spin[i][j]/8.0
  
  # Calculate priority for each site based on the total spin and interactions with neighbors
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        priorities[i*N+j][0] += sum([h[k][j] for k in range(4)])/8.0
        priorities[i*N+j][1] -= sum([h[k][j] for k in range(4)])/8.0
      else:
        priorities[i*N+j][0] -= sum([h[k][j] for k in range(4)])/8.0
  
  return(priorities)




#score: {'data2D.txt': -0.11511774691358027}
#island_id: 0
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + j) % N
      site_nbr2 = (i - 1 + j) % N
      site_nbr3 = ((i + (j-1)%2 - 1)) % N
      site_nbr4 = ((i + (j+1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      total_spin[i*N+j][0] += J[0,i%N][site_nbr3]*h[site_nbr3][j]
      if h[site_nbr3][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      total_spin[i*N+j][0] += J[0,i%N][site_nbr4]*h[site_nbr4][j]
      if h[site_nbr4][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.005756635802469136}
#island_id: 0
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + j) % N
      site_nbr2 = (i - 1 + j) % N
      site_nbr3 = ((i + (j-1)%2 - 1)) % N
      site_nbr4 = ((i + (j+1)%2 - 1)) % N

      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

      if J[0, i % N, site_nbr3] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

      if J[0, i % N, site_nbr4] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.00019984567901234573}
#island_id: 0
#version_generated: 2
#generate time18:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      for k in range(2):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.02367237654320988}
#island_id: 1
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if site_nbr == i or site_nbr2 == j:
        continue
      else:
        for k in range(4):
          if J[k,site_nbr,site_nbr2] > 0:
            total_spin += 1
          else:
            total_spin -= 1
        
        priority[0] += total_spin
        priority[1] -= total_spin
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': 0.11911682098765436}
#island_id: 1
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 2
        priority[1] -= 2
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 2
        priority[1] += 2
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 2
        priority[1] -= 2
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 2
        priority[1] += 2
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 2
        priority[1] -= 2
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 2
        priority[1] += 2
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 2
        priority[1] -= 2
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 2
        priority[1] += 2
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': 0.12083101851851866}
#island_id: 1
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = [0, 0]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      else:
        priorities[i*N+j] = [-x-1 for x in total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10363009259259261}
#island_id: 1
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 4
        priority[1] -= 4
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 4
        priority[1] += 4
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 4
        priority[1] -= 4
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 4
        priority[1] += 4
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 4
        priority[1] -= 4
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 4
        priority[1] += 4
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 4
        priority[1] -= 4
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 4
        priority[1] += 4
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+2 for x in priority]
      else:
        priorities[i*N+j] = [-x-2 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      total_downspin = 0
      
      for k in range(4):
        if J[k,i,j] > 0:
          if h[(i + ((j-1)%2 - 1)) % N][j] > 0:
            total_spin += 2
            total_downspin -= 2
          elif h[i][(j+1)%N] > 0:
            total_spin += 2
            total_downspin -= 2
          else:
            if J[k,i,j] < 0:
              total_spin -= 2
              total_downspin += 2
      priorities[i*N+j] = [total_spin, -total_downspin]
  
  return(priorities)




#score: {'data2D.txt': -0.3183229938271597}
#island_id: 0
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr1][j]
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= h[site_nbr1][j]
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
  return(total_spin.flatten().reshape(-1,2))




#score: {'data2D.txt': -0.010405401234567903}
#island_id: 0
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    h_flatten = h.flatten()
    total_spin[i//N*N+i%N][0] += h_flatten[site_nbr1]
    if h_flatten[site_nbr1]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin[i//N*N+i%N][0] += h_flatten[site_nbr2]
    if h_flatten[site_nbr2]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 0
#version_generated: 2
#generate time18:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] += h[site_nbr1][j]
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= h[site_nbr1][j]
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return(total_spin)




#score: {'data2D.txt': -0.00398503086419753}
#island_id: 2
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += (total_spin+sum(J[k][i][j] for k in range(4)))/16.0
        priorities[i*N+j][1] -= (total_spin+sum(J[k][i][j] for k in range(4)))/16.0
      else:
        priorities[i*N+j][0] -= (total_spin+sum(J[k][i][j] for k in range(4)))/16.0
  return(priorities)




#score: {'data2D.txt': 0.004274537037037037}
#island_id: 2
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  return(priorities)




#score: {'data2D.txt': 0.014113734567901236}
#island_id: 2
#version_generated: 2
#generate time18:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 2
        priorities[i*N+j][1] -= abs(total_spin) * 2
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 2
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 2
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.0010103395061728394}
#island_id: 2
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/2.0
        priorities[i*N+j][1] -= total_spin/2.0
      else:
        priorities[i*N+j][0] -= total_spin/2.0
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  return(priorities)




#score: {'data2D.txt': 0.014113734567901236}
#island_id: 2
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.009648611111111111}
#island_id: 2
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin) if h[i][j] < 0 else 3 - abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.28815725308641976}
#island_id: 3
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) - 1
        priorities[i*N+j][1] -= abs(total_spin) - 1
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) - 1
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.1402915123456788}
#island_id: 2
#version_generated: 2
#generate time18:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]

  # calculate interaction with nearest neighbors
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[site_nbr2][j]
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  # calculate interaction with all neighbors using convolutions
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      h_conv = np.convolve(h[site_nbr], [1, -1], mode='same')[j]
      if h_conv > 0:
        priorities[i*N+j][0] += h_conv
        priorities[i*N+j][1] -= h_conv
      else:
        priorities[i*N+j][0] -= h_conv
        
  return(priorities)




#score: {'data2D.txt': -0.17290385802469083}
#island_id: 2
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]

  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin1 = h[site_nbr1][j]
      total_spin2 = h[site_nbr2][j]

      if total_spin1 > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      if total_spin2 > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin = sum([h[(k+((l-1)%2 - 1))%N][j] for k, l in itertools.product(range(N), range(4))])
        priorities[i*N+j][0] += total_spin/16.0
        priorities[i*N+j][1] -= total_spin/16.0
      else:
        total_spin = sum([-h[(k+((l-1)%2 - 1))%N][j] for k, l in itertools.product(range(N), range(4))])
        priorities[i*N+j][0] -= total_spin/16.0

  return(priorities)




#score: {'data2D.txt': -0.007119598765432098}
#island_id: 0
#version_generated: 2
#generate time18:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i // N - 1) % N
    site_nbr2 = (i % N + ((i // N - 1) % 2 - 1)) % N

    total_spin[i//N*N+i%N][0] += h[site_nbr1][i%N]
    if h[site_nbr1][i%N]>0:
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][1]+=1

    site_nbr3 = (i // N + ((i % N - 1) % 2 - 1)) % N
    site_nbr4 = (i % N + (i // N - 1) % N)

    if J[0, i%N][site_nbr2] > 0:
      total_spin[i//N*N+i%N][0] += 1
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][0] -= 1
      total_spin[i//N*N+i%N][1]+=1

    if J[1, i%N][site_nbr3] > 0:
      total_spin[i//N*N+i%N][0] += 1
      total_spin[i//N*N+i%N][1]-=1
    else:
      total_spin[i//N*N+i%N][0] -= 1
      total_spin[i//N*N+i%N][1]+=1

  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.342665586419752}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum([h[site_nbr][j] if (k-1)%2 == (i+((j-1)%2)-1)%N else 0 for k, site_nbr in enumerate(site_nbrs)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= len([k for k in site_nbrs if h[k][j] > 0])
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += len([k for k in site_nbrs if h[k][j] < 0])
  return(priorities)




#score: {'data2D.txt': -0.01370570987654321}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  total_spins = [[sum([h[(i + ((k-1)%2 - 1)) % N][j] for k in range(4)]) for j in range(N)] for i in range(N)]
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spins[site_nbr][j]
        priorities[i*N+j][1] -= total_spins[site_nbr][j]
      else:
        priorities[i*N+j][0] -= total_spins[site_nbr][j]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0013257716049382712}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      total_spin = sum([h[(i+k)%N][j] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k][site_nbr][j] > 0:
          priorities[i*N+j][0] += J[k][site_nbr][j]
          priorities[i*N+j][1] -= J[k][site_nbr][j]
        else:
          priorities[i*N+j][0] -= J[k][site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.023303549382716046}
#island_id: 2
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= total_spin
      for k in range(4):
        site = ((i + (k-1)%2 - 1)) % N
        if J[k][site][j] > 0:
          priorities[i*N+j][0] += J[k][site][j]
          priorities[i*N+j][1] -= J[k][site][j]
        else:
          priorities[i*N+j][0] -= J[k][site][j]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.23884274691357998}
#island_id: 3
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 2
        priorities[i*N+j][1] -= abs(total_spin) * 2
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 2
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0050473765432099}
#island_id: 3
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 2
        priorities[i*N+j][1] -= abs(total_spin) * 2
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 2
      else:
        if total_spin > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 4
        priorities[i*N+j][1] -= abs(total_spin) * 4
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 4
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  site_nbr = lambda i, j: ((i + (j-1)%2 - 1)) % N
  for i in range(N):
    for j in range(N):
      total_spin[i*N+j][0] += h[site_nbr(i, j)][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N**2):
    site_nbr1 = (i // N + i % N) % N
    site_nbr2 = (i // N - 1) % N if i % N < N//2 else (i // N + 1) % N
    total_spin[i//N*N+i%N][0] += h[site_nbr(i//N, i%N)][i%N]
    if h[i//N][i%N] > 0:
      total_spin[i//N*N+i%N][1] -= 1
    else:
      total_spin[i//N*N+i%N][1] += 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.0016347222222222219}
#island_id: 0
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  site_nbr1 = ((np.arange(N**2) // N + np.arange(N**2) % N) % N)
  site_nbr2 = ((np.arange(N**2) // N - 1) % N)

  h_flat = h.flatten()
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    if J[0, :, i % N][site_nbr1[i]].ravel()[0] == i:
      total_spin[i // N * N + i % N, 0] += h_flat[site_nbr1[i]]
      if h_flat[site_nbr1[i]] > 0:
        total_spin[i // N * N + i % N, 1] -= 1
      else:
        total_spin[i // N * N + i % N, 1] += 1

    if J[0, :, i % N][site_nbr2[i]].ravel()[0] == i:
      total_spin[i // N * N + i % N, 0] += h_flat[site_nbr2[i]]
      if h_flat[site_nbr2[i]] > 0:
        total_spin[i // N * N + i % N, 1] -= 1
      else:
        total_spin[i // N * N + i % N, 1] += 1

  return total_spin.flatten().reshape(-1, 2)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 0
#version_generated: 2
#generate time18:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
      total_spin[i*N+j][0] += h[site_nbr2][j]
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.15339830246913602}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1664504629629632}
#island_id: 1
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on site magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the current state and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 2
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 2
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.049356635802469136}
#island_id: 2
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2), dtype=int)
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j] if J[k][site_nbr][j] > 0 else -h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] = total_spin + sum([J[k][i][j] for k in range(4)])
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][0] = -total_spin
        priorities[i*N+j][1] = total_spin - sum([J[k][i][j] for k in range(4)])
  return priorities.tolist()




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      total_spin = sum([h[(i+k)%N][j] for k in range(4)])
      if h[i][j] > 0:
        spin = 1
      else:
        spin = -1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        interaction = J[k][site_nbr][j]
        if interaction > 0 and h[site_nbr][j] == spin:
          priorities[i*N+j][0] += 2 * interaction
          priorities[i*N+j][1] -= 2 * interaction
        elif interaction < 0 and h[site_nbr][j] != spin:
          priorities[i*N+j][0] += 2 * abs(interaction)
          priorities[i*N+j][1] -= 2 * abs(interaction)
  return(priorities)




#score: {'data2D.txt': -0.0029918209876543212}
#island_id: 2
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_spin
    for k in range(4):
      if J[k][site_nbr][i%N] > 0:
        priorities[i][0] += J[k][site_nbr][i%N]
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= J[k][site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.0016266975308641975}
#island_id: 2
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  total_spins = [[[sum(J[k][site_nbr][j] for k in range(4)) + h[site_nbr][j] if h[site_nbr][j] > 0 else -h[site_nbr][j] for j in range(N)] for site_nbr in range(N)]]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += sum(total_spins[0][site_nbr][j] for j in range(N))
    if h[site_nbr][i%N] > 0:
      priorities[i][1] -= total_spins[0][site_nbr][i%N]
    else:
      priorities[i][1] += total_spins[0][site_nbr][i%N]
  return(priorities)




#score: {'data2D.txt': 0.1893251543209879}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[:, i%N, i//N]), -total_spin - sum(J[:, i%N, i//N])]
    else:
      priorities[i] = [-total_spin - sum(J[:, i%N, i//N]), total_spin + sum(J[:, i%N, i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.00010787037037037045}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k, i//N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0]), 
               -np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])]
    else:
      priorities[i] = [-np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0]), 
               np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])]
  
  return(priorities)




#score: {'data2D.txt': 0.16135570987654346}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.020891820987654325}
#island_id: 1
#version_generated: 2
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [J[3,i//N,i%N], J[1,i//N,i%N]]
    else:
      priorities[i] = [-J[3,i//N,i%N], -J[1,i//N,i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.034004783950617165}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin)/8.0
        priorities[i*N+j][1] -= abs(total_spin)/8.0
      else:
        priorities[i*N+j][0] -= abs(total_spin)/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += abs(J[k][i][j])
          priorities[i*N+j][1] -= abs(J[k][i][j])
        else:
          priorities[i*N+j][0] -= abs(J[k][i][j])
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3352300925925928}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + sum([J[k][i][j] for k in range(4)])
      
      # Calculate priority for each spin
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= abs(total_spin)
        priorities[i*N+j][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0009242283950617286}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += (total_spin/8.0) + np.sum(interacting_spins[:,i,j])
        priorities[i*N+j][1] -= (total_spin/8.0) - np.sum(interacting_spins[:,i,j])
      else:
        priorities[i*N+j][0] -= (total_spin/8.0) - np.sum(interacting_spins[:,i,j])

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]

  return(priorities)




#score: {'data2D.txt': 0.0041612654320987656}
#island_id: 2
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum([h[site_nbr][k] for k in range(4)])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if J[k][i][j] > 0:
          priorities[i*N+j][0] += J[k][i][j]
          priorities[i*N+j][1] -= J[k][i][j]
        else:
          priorities[i*N+j][0] -= J[k][i][j]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.01432422839506173}
#island_id: 3
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] * np.sign(J[0, i, j]) + J[1, i, j] * np.sign(J[1, i, j])
      if interaction > 0:
        priorities[i*N+j][0] += 3
        priorities[i*N+j][1] -= 3
      elif interaction < 0:
        priorities[i*N+j][0] -= 3
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.006454475308641974}
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # Calculate total spin for each site
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  # Calculate priority for each spin
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += np.sum(total_spin[site_nbr,:,0])
      priorities[i][1] -= np.sum(total_spin[site_nbr,:,1])
    else:
      priorities[i][0] -= np.sum(total_spin[site_nbr,:,0])
      priorities[i][1] += np.sum(total_spin[site_nbr,:,1])
  
  return(priorities)




#score: {'data2D.txt': -0.3352300925925928}
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]

  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + sum([J[k][i][j] for k in range(4)])
      
      # Calculate priority for each spin based on the magnetism and interactions
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin) - total_spin
        priorities[i*N+j][1] -= 2*total_spin
      else:
        priorities[i*N+j][0] -= abs(total_spin) + total_spin
        priorities[i*N+j][1] += 2*total_spin

  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  
  # Calculate total spin for each site
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j] + sum([J[k][i][j] for k in range(4)])
      
      # Calculate priority for each spin based on its energy
      if total_spin > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += total_spin
      
      # If the site is on the boundary, its priority is adjusted
      if i == 0 or j == 0 or i == N-1 or j == N-1:
        if h[i][j] > 0:
          priorities[i*N+j][0] -= np.abs(total_spin)
          priorities[i*N+j][1] += total_spin
        else:
          priorities[i*N+j][0] += np.abs(total_spin)
          priorities[i*N+j][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': 0.0004115740740740742}
#island_id: 0
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if J[0,i%N][site_nbr1]%N==i:
      total_spin[i//N*N+i%N][0] += h[site_nbr1][0]
      total_spin[i//N*N+i%N][1]-=h[site_nbr1][0]
    else:
      site = (i % N + ((i//N-1)%2 - 1)) % N
      if h[site][0] > 0:
        total_spin[i//N*N+i%N][0] -= 1
        total_spin[i//N*N+i%N][1] += 1
      else:
        total_spin[i//N*N+i%N][0] += 1
        total_spin[i//N*N+i%N][1] -= 1
  return(total_spin.flatten().reshape(-1, 2))




#score: {'data2D.txt': -0.02235416666666673}
#island_id: 3
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      else:
        site_nbr = (i + ((j-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin)/8.0
        priorities[i*N+j][1] -= abs(total_spin)/8.0
      else:
        priorities[i*N+j][0] -= abs(total_spin)/8.0

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))
  for i in range(2):
    interacting_spins[i] = np.roll(h,-1,axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h,1,axis=i)

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin/8.0
        priorities[i*N+j][1] -= total_spin/8.0
      else:
        priorities[i*N+j][0] -= total_spin/8.0

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[0][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[2][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3][i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N, N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i][j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][1] += 1
  
  priority_total = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i//N][i%N][0] += 1
      total_spin[i//N][i%N][1] -= 1
    else:
      total_spin[i//N][i%N][0] -= 1
  
  return priority_total.flatten().reshape(-1,2)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return priorities




#score: {'data2D.txt': -0.0006908950617283956}
#island_id: 0
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.array([[0.5*(h[i][j]+J[0,i,j]-2*J[0,(i+1)%N,j]) for j in range(N)] for i in range(N)])
  return(np.concatenate((priorities.flatten(),np.zeros(N**2)),axis=0).reshape(-1, 2))




#score: {'data2D.txt': -0.003951080246913581}
#island_id: 2
#version_generated: 2
#generate time18:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  interacting_spins = np.zeros((4,N,N))
  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N//2):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j*2][0] += sum([h[site_nbr][k] for k in range(4)])
      if h[i][j*2] > 0:
        total_spin[i*N+j*2][1] -= sum([h[site_nbr][k] for k in range(4)])/8.0
      else:
        total_spin[i*N+j*2][0] += sum([h[site_nbr][k] for k in range(4)])/8.0

  return(total_spin)




#score: {'data2D.txt': 0.03469953703703704}
#island_id: 3
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      else:
        for _ in range(2):
          site_nbr = (i + ((j-1)%2 - 1)) % N
          total_spin = h[site_nbr][j]
          interaction = J[0, i, j]
          if interaction > 0:
            priorities[i*N+j][0] += abs(total_spin) * 3
            priorities[i*N+j][1] -= abs(total_spin) * 3
          else:
            priorities[i*N+j][0] -= abs(total_spin) * 3
            priorities[i*N+j][1] += abs(total_spin) * 3
  return(priorities)




#score: {'data2D.txt': 0.3087597222222222}
#island_id: 3
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin)
      elif interaction < 0:
        total_spin = h[site_nbr2][j] + h[i][site_nbr1]
        if interaction > 0:
          priorities[i*N+j][0] += 3 - abs(total_spin)
          priorities[i*N+j][1] -= 3 - abs(total_spin)
        elif interaction < 0:
          priorities[i*N+j][0] -= 3 - abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 3
  return(priorities)




#score: {'data2D.txt': 0.05594768518518519}
#island_id: 1
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if sum(J[:,i%N,i//N]) < 0:
      priorities[i] = [total_spin + abs(sum(J[:,i%N,i//N])), -total_spin - abs(sum(J[:,i%N,i//N]))]
    elif sum(J[:,i%N,i//N]) > 0:
      priorities[i] = [-total_spin - abs(sum(J[:,i%N,i//N])), total_spin + abs(sum(J[:,i%N,i//N]))]
    else:
      if h[i//N][i%N] > 0:
        priorities[i] = [total_spin + sum(J[:,i%N,i//N]), -total_spin - sum(J[:,i%N,i//N])]
      else:
        priorities[i] = [-total_spin - sum(J[:,i%N,i//N]), total_spin + sum(J[:,i%N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': -0.006981944444444443}
#island_id: 1
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_neighbors = [(i+1)%N, (i-1+N*N)%N, ((i%N)+N*(i//N-1)) % N, ((i%N)+N*(i//N-2)) % N]
    neighbor_spins = [h[j][i%N] for j in site_neighbors]
    
    if sum(neighbor_spins) > 0:
      priorities[i] = [-total_spin - sum(J[:, i%N, i//N]), total_spin + sum(J[:, i%N, i//N])]
    else:
      priorities[i] = [total_spin + sum(J[:, i%N, i//N]), -total_spin - sum(J[:, i%N, i//N])]

  return(priorities)




#score: {'data2D.txt': 0.09570324074074082}
#island_id: 1
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_magnetism = h[i//N][i%N]
    interaction_sum = sum(J[:, i%N, i//N])
    
    if spin_magnetism > 0:
      priorities[i] = [total_spin + spin_magnetism + interaction_sum, -total_spin - spin_magnetism - interaction_sum]
    else:
      priorities[i] = [-total_spin - spin_magnetism - interaction_sum, total_spin + spin_magnetism + interaction_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.006629166666666666}
#island_id: 1
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = sum(J[:, i%N, i//N]) - total_spin
      priorities[i][1] = -total_spin - sum(J[:, i%N, i//N])
    else:
      priorities[i][0] = -total_spin - sum(J[:, i%N, i//N])
      priorities[i][1] = total_spin + sum(J[:, i%N, i//N])
  
  return(priorities)




#score: {'data2D.txt': 8.873456790123469e-05}
#island_id: 3
#version_generated: 2
#generate time18:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    spin_energy = sum([J[0, i//N, jj] * h[site_nbr][jj] if J[0, i//N, jj] > 0 else -J[0, i//N, jj] * h[site_nbr][jj] for jj in range(N) if J[0, i//N, jj] != 0])
    
    if sum([h[jj][i%N] for jj in range(N) if J[0, jj, i%N] > 0]) > 0:
      priorities[i][0] += spin_energy
      priorities[i][1] -= 2*spin_energy
    else:
      priorities[i][0] -= spin_energy
  
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.00917824074074074}
#island_id: 2
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += -J[0,i%N,site_nbr]*h[site_nbr,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr]*h[site_nbr,i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0015541666666666668}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = np.sum([J[k,i%N,i//N] for k in range(4) if (k == 0 and i % N > 0) or (k == 1 and i % N < N-1) or (k == 2 and i // N > 0) or (k == 3 and i // N < N-1)])
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i] = [site_magnetism, -site_magnetism]
    else:
      priorities[i] = [-site_magnetism, site_magnetism]

  return priorities




#score: {'data2D.txt': -0.00968287037037037}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += J[k,i%N,i//N]
      else:
        neighbor_interactions -= J[k,i%N,i//N]
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i] = [site_magnetism, -site_magnetism]
    elif site_magnetism > 0:
      priorities[i] = [-site_magnetism/abs(site_magnetism), site_magnetism/abs(site_magnetism)]
    else:
      priorities[i] = [site_magnetism/abs(site_magnetism), -site_magnetism/abs(site_magnetism)]
  
  return priorities




#score: {'data2D.txt': 0.16108163580246865}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_magnetism = h[site_nbr][i%N]
    
    neighbor_interactions = 0
    for k in [3, 2, 0]:
      neighbor_site = (i // N + k) % N * N + i % N
      if J[k,i//N,neighbor_site//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    site_magnetism += neighbor_interactions
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = [site_magnetism, -site_magnetism]
    else:
      priorities[i] = [-site_magnetism, site_magnetism]

  return priorities




#score: {'data2D.txt': 0.010959722222222221}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin=np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr=(i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N]>0:
        site_magnetism=h[site_nbr][i%N]+J[k,i%N,i//N]
        break
      else:
        site_magnetism=-h[site_nbr][i%N]-J[k,i%N,i//N]
    total_spin[i][0]+=site_magnetism
    if J[k,i%N,i//N]>0:
      total_spin[i][1]-=1
    else:
      total_spin[i][1]+=1
  return total_spin




#score: {'data2D.txt': -0.007115895061728395}
#island_id: 1
#version_generated: 2
#generate time18:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = -site_magnetism - neighbor_interactions - sum([J[1,i//N,j//N] for j in range(N) for k in range(4) if (j==i%N and k!=1)])
      priorities[i][1] = site_magnetism + neighbor_interactions + sum([J[1,i//N,j//N] for j in range(N) for k in range(4) if (j==i%N and k!=1)])
    else:
      priorities[i][0] = site_magnetism + neighbor_interactions + sum([J[1,i//N,j//N] for j in range(N) for k in range(4) if (j==i%N and k!=1)])
      priorities[i][1] = -site_magnetism - neighbor_interactions - sum([J[1,i//N,j//N] for j in range(N) for k in range(4) if (j==i%N and k!=1)])
  
  return priorities




#score: {'data2D.txt': -0.0005050925925925925}
#island_id: 1
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = np.sum([J[k,i%N,i//N] for k in range(4) if ((k-1)%2 - 1) % N == (i//N+((i%N-1)%2 - 1)) % N])
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = -site_magnetism - neighbor_interactions
      priorities[i][1] = site_magnetism + neighbor_interactions
    else:
      priorities[i][0] = site_magnetism + neighbor_interactions
      priorities[i][1] = -site_magnetism - neighbor_interactions
  
  return priorities




#score: {'data2D.txt': -0.03980756172839506}
#island_id: 1
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at each site
    site_magnetism = h[site_nbr][i%N]
    
    # Calculate the interactions with neighboring sites
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    # Assign priorities based on magnetism and interactions
    if site_magnetism + neighbor_interactions > 0:
      priorities[i][0] = -site_magnetism - neighbor_interactions
      priorities[i][1] = site_magnetism + neighbor_interactions
    else:
      priorities[i][0] = site_magnetism + neighbor_interactions
      priorities[i][1] = -site_magnetism - neighbor_interactions
  
  return priorities




#score: {'data2D.txt': 0.2585285493827161}
#island_id: 3
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.0001390432098765424}
#island_id: 3
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] * abs(J[0, i, j]) + J[1, i, j] * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 3 * interaction
        priorities[i*N+j][1] -= 3 * interaction
      elif total_spin < 0:
        priorities[i*N+j][0] -= 3 * interaction
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[(i + ((j-1)%2 - 1)) % N])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  
  for i in range(4):
    interacting_spins[i] = (np.roll(h, -1, axis=0) if i < 2 else 
                 np.roll(h, 1, axis=0),
                np.roll(h, -1, axis=1) if i % 2 == 0 else 
                 np.roll(h, 1, axis=1))[i//2]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.013162191358024706}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0, i, j] > 0:
        total_spin += J[0, i, j]
      elif J[0, i, j] < 0:
        total_spin -= J[0, i, j]
      
      priorities[i*N+j][0] = total_spin
      if h[i][j] > 0:
        priorities[i*N+j][1] += np.sum(np.where(h[:, j] > 0, -J[0, :, j], J[0, :, j]))
      else:
        priorities[i*N+j][1] -= np.sum(np.where(h[:, j] > 0, -J[0, :, j], J[0, :, j]))
  
  return priorities




#score: {'data2D.txt': -0.0037958333333333334}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      for k in range(4):
        if J[k, i, j] > 0:
          total_spin += J[k, i, j]
        elif J[k, i, j] < 0:
          total_spin -= J[k, i, j]
        
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
      
  return priorities




#score: {'data2D.txt': 0.03397422839506172}
#island_id: 1
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N * N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0, i//N, i%N] > 0:
      total_spin += 1
    elif J[0, i//N, i%N] < 0:
      total_spin -= 1
    
    if J[1, i//N, i%N] > 0:
      total_spin += 1
    elif J[1, i//N, i%N] < 0:
      total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  sites_nbrs = ((i + ((j-1)%2 - 1)) % N for i in range(N) for j in range(N))
  site_nbrs = np.array(list(sites_nbrs))
  h_sum = np.sum(h[site_nbrs], axis=0)
  
  for k in range(4):
    sites_nbrs_k = ((i + ((k-1)%2 - 1)) % N for i in range(N) for j in range(N))
    site_nbrs_k = np.array(list(sites_nbrs_k))
    J_sum = np.sum(J[k, :, :], axis=0)
    h_sum += J_sum
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return priorities




#score: {'data2D.txt': -0.09011527777777778}
#island_id: 0
#version_generated: 2
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[(i + ((j-1)%2 - 1)) % N])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += np.sum(h[site_nbr])
          priorities[i*N+j][1] -= np.sum(J[k,site_nbr,:])
        else:
          priorities[i*N+j][0] -= np.sum(h[site_nbr])
          priorities[i*N+j][1] += np.sum(J[k,site_nbr,:])
  return(priorities)




#score: {'data2D.txt': -0.3069766975308636}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  # Calculate interacting spins
  interacting_spins = (np.roll(h, -1, axis=0) + 
             np.roll(h, 1, axis=0) + 
             np.roll(h, -1, axis=1) + 
             np.roll(h, 1, axis=1))
  
  # Calculate priorities based on site interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += -J[0,i%N,site_nbr]*h[site_nbr,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr]*h[site_nbr,i%N]
    
  # Adjust priorities based on site magnetism
  priorities[:, 0] += h.flatten()
  priorities[:, 1] -= h.flatten()
  
  return(priorities)




#score: {'data2D.txt': -0.007622067901234568}
#island_id: 2
#version_generated: 2
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,site_nbr]:
      priorities[i][0] += h[site_nbr,i%N]
      priorities[i][1] -= h[site_nbr,i%N]
    elif J[1,i%N,site_nbr]:
      priorities[i][0] -= h[site_nbr,i%N]
      priorities[i][1] += h[site_nbr,i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[2,i%N,site_nbr]:
      priorities[i][0] += h[site_nbr,i%N]
      priorities[i][1] -= h[site_nbr,i%N]
    elif J[3,i%N,site_nbr]:
      priorities[i][0] -= h[site_nbr,i%N]
      priorities[i][1] += h[site_nbr,i%N]
  return(priorities)




#score: {'data2D.txt': -0.001399228395061728}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      if h[i][site_nbr2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += (total_spin + 2)
        priorities[i*N+j][1] -= (total_spin + 2)
      elif total_spin < 0:
        priorities[i*N+j][0] -= (abs(total_spin) + 2)
      return(priorities)




#score: {'data2D.txt': 0.0883918209876543}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.02705879629629638}
#island_id: 3
#version_generated: 2
#generate time18:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 1
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 1
      total_spin += h[i][j]
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 0
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N_half
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.27402361111111123}
#island_id: 0
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      elif J[0,i,j] < 0:
        total_spin -= 1
      
      site_nbr = (i + ((j+1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if J[1,i,j] > 0:
        total_spin += 1
      elif J[1,i,j] < 0:
        total_spin -= 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if J[3,i,j] > 0:
        total_spin += 1
      elif J[3,i,j] < 0:
        total_spin -= 1
      
      site_nbr = (i + ((j+1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if J[2,i,j] > 0:
        total_spin += 1
      elif J[2,i,j] < 0:
        total_spin -= 1
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= np.sign(total_spin) * np.abs(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += np.sign(total_spin) * np.abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.2429260802469135}
#island_id: 0
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[(i + ((j-1)%2 - 1)) % N])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += h[site_nbr][j]
          if h[site_nbr][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif J[k,i,j] < 0:
          total_spin -= h[site_nbr][j]
          if h[site_nbr][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.20601651234567903}
#island_id: 3
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + (0)%N)
      site_nbr4 = (i + ((j+2)%2 - 1)) % N if j < N-1 else (i, (j-1)%N)
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[i][site_nbr3]
      interaction = J[0, i, j] + J[1, i, j] + J[2, i, j] if i < N-1 else 0
      
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.3087597222222222}
#island_id: 3
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.3087597222222222}
#island_id: 3
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': -0.013108487654320987}
#island_id: 1
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[k, i//N, site_nbr] for k in range(4))
      priorities[i][1] -= sum(J[k, i//N, site_nbr] for k in range(4))
    else:
      priorities[i][0] -= sum(J[k, i//N, site_nbr] for k in range(4))
      priorities[i][1] += sum(J[k, i//N, site_nbr] for k in range(4))
  
  return(priorities)




#score: {'data2D.txt': 0.06242608024691361}
#island_id: 1
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      site_nbr_k = (i%N + (k-1)%2) % N
      if J[k, i//N, site_nbr_k] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -total_spin-1]
    else:
      priorities[i] = [-total_spin-1, total_spin+1]
  
  return(priorities)




#score: {'data2D.txt': -0.004624228395061728}
#island_id: 1
#version_generated: 2
#generate time18:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += sum(J[k][i//N,site_nbr] for k in range(4))
      priorities[i][1] -= len([k for k in range(4) if J[k][i//N,site_nbr] > 0])
    else:
      priorities[i][0] -= sum(J[k][i//N,site_nbr] for k in range(4))
      priorities[i][1] += len([k for k in range(4) if J[k][i//N,site_nbr] < 0])
  
  return(priorities)




#score: {'data2D.txt': -0.1389402777777778}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0]), 
               np.sum([abs(J[k,i//N,i%N]) for k in range(4) if J[k,i//N,i%N] < 0])]
    else:
      priorities[i] = [np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0]), 
               np.sum([abs(J[k,i//N,i%N]) for k in range(4) if J[k,i//N,i%N] > 0])]
  
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      neighbors_up = [J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0]
      neighbors_down = [J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0]
      priorities[i] = [np.sum(neighbors_up), -np.sum(neighbors_down)]
    else:
      neighbors_up = [J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0]
      neighbors_down = [J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0]
      priorities[i] = [-np.sum(neighbors_up), np.sum(neighbors_down)]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin_plus = sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0])
      total_spin_minus = -sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])
      priorities[i] = [total_spin_plus, -total_spin_minus]
    else:
      total_spin_plus = -sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0])
      total_spin_minus = sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])
      priorities[i] = [-total_spin_plus, total_spin_minus]
  
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      up_spin = np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])
      down_spin = np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0])
      priorities[i][0] = up_spin
      priorities[i][1] -= down_spin
    else:
      up_spin = np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] > 0])
      down_spin = np.sum([J[k,i//N,i%N] for k in range(4) if J[k,i//N,i%N] < 0])
      priorities[i][0] -= up_spin
      priorities[i][1] += down_spin
  
  return(priorities)




#score: {'data2D.txt': -0.00917824074074074}
#island_id: 2
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += -J[0,i%N,site_nbr]*h[site_nbr,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr]*h[site_nbr,i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.01053287037037037}
#island_id: 2
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if h[site_nbr1,i%N] > 0:
      priorities[i][0] += J[0,i%N,site_nbr1]
      priorities[i][1] -= J[1,i%N,site_nbr1]
    
    if h[site_nbr2,i%N] > 0:
      priorities[i][0] += J[0,i%N,site_nbr2]
      priorities[i][1] -= J[1,i%N,site_nbr2]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.00917824074074074}
#island_id: 2
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += -J[0,i%N,site_nbr]*h[site_nbr,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr]*h[site_nbr,i%N]
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0022853395061728393}
#island_id: 2
#version_generated: 2
#generate time18:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += J[0,i%N,site_nbr]
      priorities[i][1] -= J[1,i%N,site_nbr]
    else:
      priorities[i][0] -= J[0,i%N,site_nbr]
      priorities[i][1] += J[1,i%N,site_nbr]
  return(priorities)




#score: {'data2D.txt': -0.2288844135802467}
#island_id: 0
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = [h[site_nbr][j] for site_nbr in site_nbrs]
      if sum(total_spin) > 0:
        priorities[i*N+j][0] += len([spin for spin in total_spin if spin > 0])
        priorities[i*N+j][1] -= len([spin for spin in total_spin if spin < 0])
      else:
        priorities[i*N+j][0] -= len([spin for spin in total_spin if spin > 0])
        priorities[i*N+j][1] += len([spin for spin in total_spin if spin < 0])
  return priorities




#score: {'data2D.txt': -0.2288844135802467}
#island_id: 0
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(4)]
      total_spin = [h[site][j] for site in site_nbrs]
      if sum(total_spin) > 0:
        priorities[i*N+j][0] += len([spin for spin in total_spin if spin > 0])
        priorities[i*N+j][1] -= len([spin for spin in total_spin if spin < 0])
      else:
        priorities[i*N+j][0] -= len([spin for spin in total_spin if spin > 0])
        priorities[i*N+j][1] += len([spin for spin in total_spin if spin < 0])
  return(priorities)




#score: {'data2D.txt': -0.22789830246913603}
#island_id: 0
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))

  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N if k == 0 else (i-1)%N if k == 3 else (j+1)%N if k == 1 else (j-1)%N if k == 2 else i for k in [0,1,2,3]]
      total_spin = np.sum([h[site_nbr][j] if J[k,i,j] > 0 else -h[site_nbr][j] for site_nbr, k in zip(site_nbrs, [0,1,2,3])])
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= np.sign(total_spin) * np.abs(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += np.sign(total_spin) * np.abs(total_spin)

  return(priorities)




#score: {'data2D.txt': -0.184871450617284}
#island_id: 0
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [j-1,j+1,i-1,i+1]]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs) + h[i][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      elif J[0,i,j] < 0:
        total_spin -= 1
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= np.sign(total_spin) * np.abs(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += np.sign(total_spin) * np.abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.243563425925926}
#island_id: 0
#version_generated: 2
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [j-1, j+1, (i-1)%N, (i+1)%N]]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      
      if J[0,i,j] > 0:
        total_spin += 1
      elif J[0,i,j] < 0:
        total_spin -= 1
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= np.sign(total_spin) * np.abs(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += np.sign(total_spin) * np.abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': -0.03032638888888889}
#island_id: 1
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_product = total_spin * sum(J[:, i%N, i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + spin_product, -total_spin - spin_product]
    else:
      priorities[i] = [-total_spin - spin_product, total_spin + spin_product]
  
  return(priorities)




#score: {'data2D.txt': -0.3388887345679002}
#island_id: 1
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += J[k, i%N, i//N]
      else:
        total_spin -= J[k, i%N, i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] += -J[0,i%N,site_nbr]*h[site_nbr,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr]*h[site_nbr,i%N]
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.008142438271604938}
#island_id: 2
#version_generated: 2
#generate time18:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    priorities[i][0] += J[0,i%N,site_nbr1]*h[site_nbr1,i%N]
    priorities[i][1] -= J[1,i%N,site_nbr1]*h[site_nbr1,i%N]
    priorities[i][0] += J[2,i%N,site_nbr2]*h[site_nbr2,i%N]
    priorities[i][1] -= J[3,i%N,site_nbr2]*h[site_nbr2,i%N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  total_spin = np.zeros(2)
  
  # Calculate total magnetism at each site
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    for k, j in zip([0,1,2,3],[1,-1,0,0]):
      total_spin[0] += J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N]
      if h[i//N,i%N] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
    
  # Calculate priority for each site based on total magnetism
  for i in range(N**2):
    priorities[i][0] = -total_spin[0]
    if h[i//N,i%N] > 0:
      priorities[i][1] = -total_spin[1] - 1
    else:
      priorities[i][1] = -total_spin[1] + 1
  
  return(priorities)




#score: {'data2D.txt': -0.29424521604938214}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    total_interaction = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] += total_interaction
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= total_interaction
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.20842052469135802}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = [0,0]
    for j in range(4):
      if J[j,i//N,site_nbrs[j]] > 0:
        total_spin[0] += h[site_nbrs[j],i%N]
        total_spin[1] -= 1
      else:
        total_spin[0] -= h[site_nbrs[j],i%N]
        total_spin[1] += 1
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.3200520061728387}
#island_id: 2
#version_generated: 2
#generate time18:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.09676219135802469}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_magnetism = h[site_nbr][i%N]
    
    neighbor_interactions = 0
    for k in [3, 2, 0]:
      neighbor_site = (i // N + k) % N * N + i % N
      if J[k,i//N,neighbor_site//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    site_magnetism += neighbor_interactions

    spin_up = site_magnetism + np.sum(J[:,i//N,i%N], axis=0)
    spin_down = -site_magnetism + np.sum(-J[:,i//N,i%N], axis=0)

    priorities[i] = [spin_down, spin_up]

  return priorities




#score: {'data2D.txt': 0.16108163580246865}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_magnetism = h[site_nbr][i%N]
    
    neighbor_interactions = 0
    for k in [3, 2, 0]:
      neighbor_site = (i // N + k) % N * N + i % N
      if J[k,i//N,neighbor_site//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    site_magnetism += neighbor_interactions
  
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = [site_magnetism, -site_magnetism]
    else:
      priorities[i] = [-site_magnetism, site_magnetism]

  return priorities




#score: {'data2D.txt': -0.0007486111111111108}
#island_id: 1
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    site_magnetism = h[site_nbr][i%N]
    
    neighbor_interactions = 0
    for k in [3, 2, 0]:
      neighbor_site = (i // N + k) % N * N + i % N
      if J[k,i//N,neighbor_site//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    
    site_magnetism += neighbor_interactions
    
    # Adjust spin based on magnetism and interactions
    if site_magnetism >= N*N/2:
      priorities[i][0] = 1
      priorities[i][1] = -1
    elif site_magnetism <= -N*N/2:
      priorities[i][0] = -1
      priorities[i][1] = 1
    else:
      # If magnetism is small, assign spin randomly
      priorities[i][np.random.randint(0, 2)] = np.random.choice([-1, 1])
    
  return priorities




#score: {'data2D.txt': -0.001764351851851852}
#island_id: 2
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1

  # Sort sites by priority
  site_priorities = np.sum(priorities, axis=1)

  for i in range(N**2):
    if h[i//N,i%N] > 0:
      site_priorities[i] *= -1
    priorities[i][0], priorities[i][1] = site_priorities[i], -site_priorities[i]

  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.05261064814814816}
#island_id: 2
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k, i%N, site_nbrs[j]] * h[site_nbrs[j], i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if np.sum(h[i//N]) > 0:
      priorities[i][1] += len(np.where(h[i//N]>0)[0])
    else:
      priorities[i][1] -= len(np.where(h[i//N]<0)[0])
  return(priorities)




#score: {'data2D.txt': -0.1990797839506173}
#island_id: 0
#version_generated: 2
#generate time18:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N_half
        if J[k,i,j] > 0:
          if h[site][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 0
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N_half
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 0
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      # Calculate the total magnetism at this site
      total_spin = np.sum(h[site_nbr])
      
      # Calculate the priority to assign a spin up
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      # Check all nearest neighbors
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N_half
        
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.10955169753086431}
#island_id: 0
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin2
        priorities[i*N+j][1] -= total_spin2
      else:
        priorities[i*N+j][0] -= total_spin2
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin) - total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin) - total_spin
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin) - (h[i][j] * np.sign(interaction))
        priorities[i*N+j][1] -= 3 - abs(total_spin) - (h[i][j] * np.sign(interaction))
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin) + (h[i][j] * np.sign(interaction))
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin) * 2
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin) * 2
  return(priorities)




#score: {'data2D.txt': 0.10045756172839507}
#island_id: 3
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + ((N-1)%2 - 1)) % N if i else (i-1) % N
      site_nbr4 = (j + ((N-1)%2 - 1)) % N if j else (j-1) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j] + J[0, site_nbr3, j] + J[0, i, site_nbr4]
      if interaction > 0:
        priorities[i*N+j][0] += 5 - abs(total_spin)
        priorities[i*N+j][1] -= 5 - abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= 5 - abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.002646759259259259}
#island_id: 1
#version_generated: 2
#generate time18:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on site magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
     if J[k,i%N,i//N] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    # Calculate the priority based on the current state and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
     site_nbr = (i % N + ((k)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
     else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  # Sort the priority for each site based on the total spin
  for i in range(N**2):
    priorities[i][0],priorities[i][1] = sorted([priorities[i][0],priorities[i][1]])
  
  return(priorities)




#score: {'data2D.txt': 0.17675817901234595}
#island_id: 1
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on site magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the current state and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    # Check if all neighbors have the same spin as the current site
    for k in range(4):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        if h[site_nbr][i%N] != h[i//N][i%N]:
          priorities[i][0] += 1
          priorities[i][1] -= 1
      else:
        if h[site_nbr][i%N] == h[i//N][i%N]:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': -0.015418981481481494}
#island_id: 1
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbrs[j]][i%N]
        priorities[i][1] -= h[site_nbrs[j]][i%N]
      else:
        priorities[i][0] -= h[site_nbrs[j]][i%N]
        priorities[i][1] += h[site_nbrs[j]][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.0005986111111111114}
#island_id: 1
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on site magnetism and interactions
    for k in [0,1]:
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][k]
      else:
        total_spin -= h[site_nbr][k]
    
    # Calculate the priority based on the current state and interactions
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.06813070987654318}
#island_id: 3
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 3
      else:
        if total_spin > 0:
          priorities[i*N+j][0] += 2
        elif total_spin < 0:
          priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.07750354938271607}
#island_id: 3
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 3
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 2
      else:
        priorities[i*N+j][0] += 2

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] -= 3
      priorities[i][1] += 3
    else:
      priorities[i][0] += 3

  return(priorities)




#score: {'data2D.txt': -0.04639429012345693}
#island_id: 3
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 3
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin) * 3
        priorities[i*N+j][1] -= abs(total_spin) * 3
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin) * 3
  return(priorities)




#score: {'data2D.txt': 0.10526033950617296}
#island_id: 1
#version_generated: 2
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      magnetism = h[site_nbr][j]
      
      if magnetism > 0:
        priorities[i*N+j] = [total_spin+magnetism, -total_spin-magnetism]
      else:
        priorities[i*N+j] = [-total_spin-magnetism, total_spin+magnetism]
  
  return(priorities)




#score: {'data2D.txt': -0.3433307098765422}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in range(3)]
      spin_directions = [np.sign(h[site_nbr][j]) for site_nbr in site_nbrs]
      
      total_spin = sum(spin_directions)
      if h[i][j] > 0:
        priorities[i*N+j][0] += len([spin_direction for spin_direction in spin_directions if spin_direction > 0])
        priorities[i*N+j][1] -= len([spin_direction for spin_direction in spin_directions if spin_direction < 0])
      else:
        priorities[i*N+j][0] -= len([spin_direction for spin_direction in spin_directions if spin_direction > 0])
        priorities[i*N+j][1] += len([spin_direction for spin_direction in spin_directions if spin_direction < 0])
  
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      else:
        priorities[i*N+j][0] -= 2
        priorities[i*N+j][1] += 2
      
      site_nbr3 = (i + ((j-1)%2 - 1)) % N
      site_nbr4 = (i + ((j+1)%2 - 1)) % N
      if j < N-1:
        total_spin += h[site_nbr1][j+1] - h[site_nbr3][j]
        if h[i][j+1] > 0:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
        else:
          priorities[i*N+j][0] += 1
      if i < N-1:
        total_spin += h[site_nbr2][i+1] - h[site_nbr4][i]
        if h[i+1][j] > 0:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 1
        else:
          priorities[i*N+j][0] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.07167391975308647}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0, 0]
      site_nbrs = [(i+1)%N, (j+1)%N, (i+N-1)%N, (j+N-1)%N]
      for site_nbr in site_nbrs:
        if h[site_nbr][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin[0]
        priorities[i*N+j][1] = -total_spin[1]
      else:
        priorities[i*N+j][0] = total_spin[0]
        priorities[i*N+j][1] = total_spin[1]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [j-1, j+1, (i-1)%N, (i+1)%N]]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return priorities




#score: {'data2D.txt': 0.3200520061728387}
#island_id: 2
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    site_interaction_sum = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
    priorities[i][0] = -site_interaction_sum
  return(priorities)




#score: {'data2D.txt': -0.09870725308641984}
#island_id: 2
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    total_spin = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] -= total_spin
      priorities[i][0] += abs(total_spin)
    else:
      priorities[i][1] += total_spin
      priorities[i][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.1975038580246913}
#island_id: 2
#version_generated: 2
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = sum(J[k,i%N,j] * h[site_nbrs[j],i%N] for k,j in itertools.product([0,1],[0,1]))
    priorities[i][0] -= spin_interactions
    if np.sum(h[i//N:i//N+2,i%N]) > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.017748302469135804}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + (0)%N)
      site_nbr4 = (i + ((j+2)%2 - 1)) % N if j < N-1 else (i, (j-1)%N)

      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[i][site_nbr3]
      interaction = J[0, i, j] + J[1, i, j] + J[2, i, j] if i < N-1 else 0

      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      elif total_spin < 0:
        priorities[i*N+j][0] -= 1
      interaction_sum = J[0, i, j] + J[1, i, j] + J[2, i, j]
      if interaction_sum > 0:
        priorities[i*N+j][0] += abs(interaction_sum)
        priorities[i*N+j][1] -= interaction_sum
      elif interaction_sum < 0:
        priorities[i*N+j][0] -= interaction_sum
  return(priorities)




#score: {'data2D.txt': -0.0016476851851851848}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + (0)%N)
      site_nbr4 = (i + ((j+2)%2 - 1)) % N if j < N-1 else (i, (j-1)%N)
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[i][site_nbr3]
      interaction = J[0, i, j] + J[1, i, j] + J[2, i, j] if i < N-1 else 0
      
      # calculate priorities based on the total spin and interaction
      priorities[i*N+j][0] += np.sum(np.abs(total_spin))
      priorities[i*N+j][1] -= np.sign(total_spin)
      
  return(priorities)




#score: {'data2D.txt': 0.24075941358024694}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.20601651234567903}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + (0)%N)
      site_nbr4 = (i + ((j+2)%2 - 1)) % N if j < N-1 else (i, (j-1)%N)

      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[i][site_nbr3]
      interaction = J[0, i, j] + J[1, i, j] + J[2, i, j] if i < N-1 else 0

      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif interaction < 0:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': -0.002130709876543209}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin1 = np.sum(h[site_nbr1])
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin1 + total_spin2
        priorities[i*N+j][1] -= total_spin1 + total_spin2
      else:
        priorities[i*N+j][0] -= total_spin1 + total_spin2
  return(priorities)




#score: {'data2D.txt': -0.15548287037037056}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      priorities[i*N+j][0] += total_spin
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
        
  return(priorities)




#score: {'data2D.txt': 0.05658966049382716}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      if J[0,i,j] + J[1,i,j] > 0:
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (i + ((j+1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif J[0,i,j] + J[1,i,j] < 0:
        site_nbr1 = (i + ((j-1)%2 - 1)) % N
        site_nbr2 = (i + ((j+1)%2 - 1)) % N
        total_spin = h[site_nbr1][j] + h[i][site_nbr2]
        priorities[i*N+j][0] -= abs(total_spin)
        priorities[i*N+j][1] += abs(total_spin)
      else:
        if np.sum(J[:,i,j]) > 0:
          site_nbr1 = (i + ((j-1)%2 - 1)) % N
          total_spin = h[site_nbr1][j]
          priorities[i*N+j][0] += abs(total_spin)
          priorities[i*N+j][1] -= abs(total_spin)
        else:
          site_nbr1 = (i + ((j+1)%2 - 1)) % N
          total_spin = h[i][site_nbr1]
          priorities[i*N+j][0] -= abs(total_spin)
          priorities[i*N+j][1] += abs(total_spin)

  return(priorities)




#score: {'data2D.txt': 0.32537638888888887}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.24904583333333336}
#island_id: 3
#version_generated: 2
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.1476121913580249}
#island_id: 0
#version_generated: 2
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = [0,0]
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
      priorities[i*N+j][0] = total_spin[0]
      priorities[i*N+j][1] = -total_spin[1]
  return(priorities)




#score: {'data2D.txt': 0.17898040123456793}
#island_id: 3
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + ((j-N)%2 - 1)) % N
      site_nbr4 = (i + ((j+N)%2 - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[site_nbr3][j] + h[i][site_nbr4]
      
      interaction = J[0, i, j] + J[1, i, j] + J[0, site_nbr1, j] + J[0, site_nbr3, j] + J[1, i, site_nbr2] + J[1, i, site_nbr4]
      
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.24715787037037037}
#island_id: 3
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.24904583333333336}
#island_id: 3
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.3200520061728387}
#island_id: 2
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.002130709876543209}
#island_id: 0
#version_generated: 2
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin1 = np.sum(h[site_nbr1])
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin1 + total_spin2
        priorities[i*N+j][1] -= (total_spin1 + total_spin2)
      else:
        priorities[i*N+j][0] -= total_spin1 + total_spin2
  return(priorities)




#score: {'data2D.txt': -0.002130709876543209}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin1 = np.sum(h[site_nbr1])
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin1 + total_spin2
        priorities[i*N+j][1] -= total_spin1 + total_spin2
      else:
        priorities[i*N+j][0] -= total_spin1 + total_spin2
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': -0.3409322530864187}
#island_id: 2
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if h[i//N,i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N if k%2==0 else (i-1)%N if k%2!=0 else i for k in range(4)]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs) + h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.2381572530864198}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.10952114197530874}
#island_id: 0
#version_generated: 2
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, i, j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= 2*np.sign(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += 2*np.sign(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.11162114197530865}
#island_id: 0
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if J[0,i,j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(1,4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.07898225308641975}
#island_id: 0
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += h[neighbor][j]
          if h[neighbor][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          total_spin -= h[neighbor][j]
          if h[neighbor][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.12083101851851866}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
      
  return(priorities)




#score: {'data2D.txt': -0.19845169753086442}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      
      # Calculate magnetism contribution from nearest neighbors
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priority_total = [total_spin+1, -(total_spin+1)]
      else:
        priority_total = [-total_spin-1, total_spin+1]
      
      # Calculate interaction contributions from nearest neighbors
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if J[3,i,j] > 0 and h[i][site_nbr2] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      elif J[3,i,j] < 0 and h[i][site_nbr2] < 0:
        priority_total[0] -= 1
        priority_total[1] += 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[1,i,j] > 0 and h[i][site_nbr] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      elif J[1,i,j] < 0 and h[i][site_nbr] < 0:
        priority_total[0] -= 1
        priority_total[1] += 1
      
      if J[2,i,j] > 0 and h[i,(j-1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      elif J[2,i,j] < 0 and h[i,(j-1)%N] < 0:
        priority_total[0] -= 1
        priority_total[1] += 1
      
      if J[0,i,j] > 0 and h[i,(j+1)%N] > 0:
        priority_total[0] += 1
        priority_total[1] -= 1
      elif J[0,i,j] < 0 and h[i,(j+1)%N] < 0:
        priority_total[0] -= 1
        priority_total[1] += 1
      
      priorities[i*N+j] = priority_total
  
  return(priorities)




#score: {'data2D.txt': -0.20742546296296277}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0:
        priority = [3, -3]
      else:
        priority = [-3, 3]

      for k in range(4):
        if J[k,i,j] > 0:
          priority[0] += 1
          priority[1] -= 1
        else:
          priority[0] -= 1
          priority[1] += 1

      priorities[i*N+j] = [x+1 for x in priority]

  return(priorities)




#score: {'data2D.txt': 0.12083101851851866}
#island_id: 1
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = 0
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priority = [total_spin, -total_spin]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': 0.12023256172839507}
#island_id: 3
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= total_spin
      else:
        if h[site_nbr1][j] > 0 and h[i][site_nbr2] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 2
        elif h[site_nbr1][j] < 0 and h[i][site_nbr2] < 0:
          priorities[i*N+j][0] -= 1
          priorities[i*N+j][1] += 2
        else:
          if np.random.rand() > 0.5:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
            priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.24075941358024694}
#island_id: 3
#version_generated: 2
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= total_spin
        
  return(priorities)




#score: {'data2D.txt': 0.24075941358024694}
#island_id: 3
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= total_spin
        
  return(priorities)




#score: {'data2D.txt': -0.21951990740740746}
#island_id: 0
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin1 = np.sum(h[site_nbr1])
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin1) + abs(total_spin2)
        priorities[i*N+j][1] -= 2 * (total_spin1 + total_spin2)
      else:
        priorities[i*N+j][0] -= abs(total_spin1) + abs(total_spin2)
  return(priorities)




#score: {'data2D.txt': -0.002130709876543209}
#island_id: 0
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((N-1)%2 - 1)) % N
      total_spin1 = np.sum(h[site_nbr1])
      total_spin2 = np.sum(h[site_nbr2])
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin1 + total_spin2
        priorities[i*N+j][1] -= total_spin1 + total_spin2
      else:
        priorities[i*N+j][0] -= total_spin1 + total_spin2
  return(priorities)




#score: {'data2D.txt': -0.10952114197530874}
#island_id: 0
#version_generated: 2
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if J[0,i,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in range(3):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, i, j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += np.abs(total_spin)
        priorities[i*N+j][1] -= 2*np.sign(total_spin)
      else:
        priorities[i*N+j][0] -= np.abs(total_spin)
        priorities[i*N+j][1] += 2*np.sign(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [j-1,j+1,i-1,i+1]]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs) + h[i][j]
      
      if J[0,i,j] > 0:
        total_spin += 1
      elif J[0,i,j] < 0:
        total_spin -= 1
      
      priorities[i*N+j][0] = np.abs(total_spin)
      if h[i][j] > 0:
        priorities[i*N+j][1] = -total_spin
      else:
        priorities[i*N+j][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.019769907407407413}
#island_id: 0
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((k-1)%2 - 1)) % N for k in [j-1,j+1,i-1,i+1]]
      total_spin = sum(J[0,k,j]*h[k][j] for k in site_nbrs) + h[i][j]
      
      if J[0, i, j] > 0:
        total_spin += 1
      elif J[0, i, j] < 0:
        total_spin -= 1
      
      priorities[i*N+j][0] = np.abs(total_spin)
      priorities[i*N+j][1] = -np.sign(total_spin) * (total_spin + sum(J[0,k,j]*h[k][j] for k in site_nbrs))
  
  return(priorities)




#score: {'data2D.txt': -0.004200771604938272}
#island_id: 0
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      total_spin = np.sum(h[site_nbr1])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 2 * total_spin
        priorities[i*N+j][1] -= 2 * total_spin
      else:
        priorities[i*N+j][0] -= 2 * total_spin
  return(priorities)




#score: {'data2D.txt': -1.4043209876543283e-05}
#island_id: 0
#version_generated: 2
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr1][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.0883918209876543}
#island_id: 3
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction_sum = J[0, i, j] + J[1, i, j]
      if interaction_sum > 0:
        priorities[i*N+j][0] += abs(J[0, i, j]) + abs(J[1, i, j])
        priorities[i*N+j][1] -= abs(J[0, i, j]) + abs(J[1, i, j])
      elif interaction_sum < 0:
        priorities[i*N+j][0] -= abs(J[0, i, j]) + abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  return(priorities)




#score: {'data2D.txt': 0.21597762345679006}
#island_id: 3
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.24886929012345677}
#island_id: 3
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[0, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[0, i, j])
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[0, i, j])
      if J[1, i, j] > 0:
        priorities[i*N+j][0] += 3 * abs(J[1, i, j])
        priorities[i*N+j][1] -= 3 * abs(J[1, i, j])
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= 3 * abs(J[1, i, j])
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
  for k in range(3):
    for i in range(N):
      site = (i + ((k-1)%2 - 1)) % N
      if h[site][0] > 0:
        for j in range(N):
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.1052270061728395}
#island_id: 3
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr1][j] > 0:
        priorities[i*N+j][0] += abs(J[0, i, j]) * 3
        priorities[i*N+j][1] -= abs(J[0, i, j]) * 3
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= abs(J[0, i, j]) * 3
        
      if h[i][site_nbr2] > 0:
        priorities[i*N+j][0] += abs(J[1, i, j]) * 3
        priorities[i*N+j][1] -= abs(J[1, i, j]) * 3
      elif J[1, i, j] < 0:
        priorities[i*N+j][0] -= abs(J[1, i, j]) * 3
        
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      
      if total_spin > 0:
        priorities[i*N+j][0] += 2
        priorities[i*N+j][1] -= 2
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2
        
  for k in range(N):
    site_nbr = (k + ((N-1)%2 - 1)) % N
    for j in range(N):
      if h[site_nbr][j] > 0:
        priorities[k*N+j][0] += 1
        priorities[k*N+j][1] -= 1
      else:
        priorities[k*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': 0.32115416666666585}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.3200520061728387}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.3414131172839496}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[0]]*h[site_nbrs[0],i%N] + J[k,i%N,site_nbrs[1]]*h[site_nbrs[1],i%N] for k in [0, 1]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.32115416666666585}
#island_id: 2
#version_generated: 2
#generate time18:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0007032407407407408}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += sum(2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] -= sum(2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
    else:
      priorities[i][1] -= sum(-2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] += sum(-2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = sum(J[k,i%N,site_nbr] * h[site_nbr,i%N] for k,site_nbr in zip([0,1], site_nbrs))
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.count_nonzero(h==h[i//N,i%N])
    else:
      priorities[i][1] -= np.count_nonzero(h!=h[i//N,i%N])
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += sum(1 for _ in range(N))
    else:
      priorities[i][1] -= sum(1 for _ in range(N))
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.29519058641975304}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin) - min(2*abs(h[site_nbr1][j]), 2*abs(h[i][site_nbr2]))
        priorities[i*N+j][1] -= 3 - abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= 3 - abs(total_spin) - min(2*abs(h[site_nbr1][j]), 2*abs(h[i][site_nbr2]))
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += 3 - abs(total_spin)
        priorities[i*N+j][1] -= 3 - abs(total_spin) - total_spin
      else:
        site_nbr3 = (i + ((j-2)%2 - 1)) % N if j > 0 else i
        site_nbr4 = (i + ((j+2)%2 - 1)) % N if j < N-1 else i
        total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[site_nbr3][j] + h[site_nbr4][j]
        interaction = J[0, i, j] + J[1, i, j] + J[0, site_nbr1, j] + J[1, site_nbr1, j] + J[0, i, site_nbr2] + J[1, i, site_nbr2] + J[0, site_nbr3, j] + J[1, site_nbr3, j] + J[0, site_nbr4, j] + J[1, site_nbr4, j]
        if interaction > 0:
          priorities[i*N+j][0] += 5 - abs(total_spin)
          priorities[i*N+j][1] -= 5 - abs(total_spin) - total_spin
  return(priorities)




#score: {'data2D.txt': -0.09797669753086419}
#island_id: 3
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      site_nbr3 = (i + ((j+N-1)%N - 1)) % N
      site_nbr4 = (i + ((j+N+1)%N - 1)) % N
      
      total_spin = h[site_nbr1][j] + h[i][site_nbr2] + h[site_nbr3][j] + h[i][site_nbr4]
      
      if J[0, i, j] > 0:
        priorities[i*N+j][0] += abs(total_spin) - 1
        priorities[i*N+j][1] -= total_spin
      elif J[0, i, j] < 0:
        priorities[i*N+j][0] -= abs(total_spin) - 1
        priorities[i*N+j][1] += total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([1,-1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.0028489197530864106}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.sum(np.sign(h))
    else:
      priorities[i][1] -= np.sum(np.sign(h))
  return(priorities)




#score: {'data2D.txt': 0.0073470679012345675}
#island_id: 2
#version_generated: 2
#generate time18:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = sum(J[k,i%N,site_nbr] * h[site_nbr,i%N] for k,site_nbr in zip([0,1],[site_nbrs[0],site_nbrs[1]]))
    priorities[i][0] -= spin_interactions
    if np.sum(h) > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.03203101851851852}
#island_id: 0
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += h[neighbor][j]
          if h[neighbor][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          total_spin -= h[neighbor][j]
          if h[neighbor][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if J[3,i,j] > 0:
        total_spin += h[site_nbr][j]
        if h[site_nbr][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      else:
        total_spin -= h[site_nbr][j]
        if h[site_nbr][j] < 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.07898225308641975}
#island_id: 0
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor = (i + ((k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += h[neighbor][j]
          if h[neighbor][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          total_spin -= h[neighbor][j]
          if h[neighbor][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.12799212962962986}
#island_id: 0
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        neighbor = (i + ((k-1)%2 - 1)) % N
        if J[k, i, j] > 0:
          total_spin += h[neighbor][j]
        else:
          total_spin -= h[neighbor][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= abs(total_spin)
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.002730709876543198}
#island_id: 0
#version_generated: 2
#generate time18:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        neighbor = ((i + (k-1)%2 - 1)) % N
        if J[k,i,j] > 0:
          total_spin += h[neighbor][j]
          if h[neighbor][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          total_spin -= h[neighbor][j]
          if h[neighbor][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.016274228395061728}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = [0, 0]
      for k in range(4):
        if J[k, i, j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      
      priority = [total_spin[0], -total_spin[1]]
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3, i, j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3, i, j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1, i, j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1, i, j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i][j-1] > 0 and J[2, i, j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2, i, j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0, i, j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0, i, j] > 0:
        priority[0] -= 1
        priority[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in priority]
      else:
        priorities[i*N+j] = [-x-1 for x in priority]
  
  return(priorities)




#score: {'data2D.txt': -0.003596141975308632}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = [0, 0]
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin[0] += 1
          total_spin[1] -= 1
        else:
          total_spin[0] -= 1
          total_spin[1] += 1
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priorities[i*N+j] = [-x-1 for x in total_spin]
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priorities[i*N+j] = [-x-1 for x in total_spin]
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priorities[i*N+j] = [-x-1 for x in total_spin]
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priorities[i*N+j] = [-x-1 for x in total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1735516975308645}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]

      for k in range(4):
        if J[k,i,j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

      priority = [total_spin, -total_spin]

      site_nbr2 = (i + ((j+1)%2 - 1)) % N

      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1

      if h[i][j-1] > 0 and J[2,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1

      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1

      site_nbr2 = (i + ((j-1)%2 - 1)) % N

      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        priority[0] += 1
        priority[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        priority[0] -= 1
        priority[1] += 1

      priorities[i*N+j] = [x+1 if h[i][j] > 0 else -x-1 for x in priority]

  return(priorities)




#score: {'data2D.txt': 0.1708952160493825}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      
      total_spin = [0, 0]
      
      for k in range(4):
        if J[k,i,j] > 0:
          total_spin[1] += 1
        else:
          total_spin[0] -= 1
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      if h[site_nbr][j] > 0 and J[3,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[site_nbr][j] < 0 and J[3,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[site_nbr2][j] > 0 and J[1,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[site_nbr2][j] < 0 and J[1,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[i][j-1] > 0 and J[2,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[i][j-1] < 0 and J[2,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[i,(j+1)%N] > 0 and J[0,i,j] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      elif h[i,(j+1)%N] < 0 and J[0,i,j] > 0:
        total_spin[0] -= 1
        total_spin[1] += 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [x+1 for x in total_spin]
      else:
        priorities[i*N+j] = [-x-1 for x in total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.006153858024691358}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    
    for j in range(N):
      total_spin = 0
      for k in [0, 1]:
        if J[k, i, (j+k)%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      if h[site_nbr][j] > 0:
        priorities[i*N+j] = [total_spin+1, -total_spin-1]
      else:
        priorities[i*N+j] = [-total_spin-1, total_spin+1]
  
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 1
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1

  return(priorities)




#score: {'data2D.txt': 0.03889583333333317}
#island_id: 3
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.03889583333333317}
#island_id: 3
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.24715787037037037}
#island_id: 3
#version_generated: 2
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.03330910493827159}
#island_id: 3
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      total_spin = h[site_nbr1][j] + h[site_nbr2][i]
      if total_spin > 0:
        priorities[i*N+j][0] += 2 * abs(total_spin)
        priorities[i*N+j][1] -= 2 * abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= 2 * abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.15305447530864197}
#island_id: 3
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      interaction = 0
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      if h[i][site_nbr2] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      interaction = J[0, site_nbr1, j] + J[1, i, site_nbr2]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.24715787037037037}
#island_id: 3
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      interaction = J[0, i, j] + J[1, i, j]
      if interaction > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif interaction < 0:
        priorities[i*N+j][0] -= abs(total_spin)
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = J[0, site_nbr, j] + J[1, i, j]
      if total_spin > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= abs(total_spin)
      elif total_spin < 0:
        priorities[i*N+j][0] -= abs(total_spin)
  for k in range(N):
    site_nbr = (k-1)%N
    total_spin = J[0, site_nbr, k]
    if total_spin > 0:
      priorities[k*N+k][0] += abs(total_spin)
      priorities[k*N+k][1] -= abs(total_spin)
    elif total_spin < 0:
      priorities[k*N+k][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    total_interaction = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] -= total_interaction
      priorities[i][1] += 1 - np.count_nonzero(h == 0)
    else:
      priorities[i][0] += total_interaction
      priorities[i][1] += 1 - np.count_nonzero(h > 0)
  return(priorities)




#score: {'data2D.txt': -0.0030884259259259268}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbr] for k,site_nbr in zip([0,1],site_nbrs)]
    if np.sum(spin_interactions) > 0:
      priorities[i][0] -= np.sum(spin_interactions)
      priorities[i][1] += 1
    else:
      priorities[i][0] -= np.sum(spin_interactions)
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.18647268518518534}
#island_id: 2
#version_generated: 2
#generate time18:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbr] for k,site_nbr in zip([0,1],site_nbrs)]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.1613319444444447}
#island_id: 1
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin += J[3,i%N,i//N]*h[site_nbr2][i%N]
    
    for d in [(1,0), (-1,0), (0,1), (0,-1)]:
      dx, dy = d
      x, y = i % N, i // N
      site_nbr = (x + dx) % N + ((y+dy)%2-1)*N
      if J[3,x,y] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum(J[:,i//N,i%N]), np.sum(J[:,i//N,i%N])]
    else:
      priorities[i] = [-np.sum(J[:,i//N,i%N]), -np.sum(J[:,i//N,i%N])]
  
  return(priorities)




#score: {'data2D.txt': 0.11446250000000013}
#island_id: 1
#version_generated: 2
#generate time18:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for d in [(1,0), (-1,0), (0,1), (0,-1)]:
      dx, dy = d
      x, y = i % N, i // N
      site_nbr = (x + dx) % N + ((y+dy)%2-1)*N
      if J[3,x,y] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for d in [(1,1), (-1,-1), (1,-1), (-1,1)]:
      dx, dy = d
      x, y = i % N, i // N
      site_nbr = (x + dx) % N + ((y+dy)%2-1)*N
      if J[3,x,y] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.019769907407407413}
#island_id: 0
#version_generated: 2
#generate time18:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = sum(J[0,k,j]*h[k][j] for k in [(i + ((k-1)%2 - 1)) % N for k in [j-1,j+1,i-1,i+1]]) + h[i][j]
      
      if J[0, i, j] > 0:
        total_spin += 1
      elif J[0, i, j] < 0:
        total_spin -= 1
      
      priorities[i*N+j][0] = np.abs(total_spin)
      priorities[i*N+j][1] = -np.sign(total_spin) * (total_spin + sum(J[0,k,j]*h[k][j] for k in [(i + ((k-1)%2 - 1)) % N for k in [j-1,j+1,i-1,i+1]]))
  
  return(priorities)




#score: {'data2D.txt': -0.06674459876543229}
#island_id: 0
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        neighbor = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k, i, j] * h[neighbor][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= abs(total_spin)
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += abs(total_spin)
  return(priorities)




#score: {'data2D.txt': 0.3364035493827151}
#island_id: 2
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      priorities[i][0] -= J[k,i//N,site_nbr]*h[site_nbr,i%N]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time18:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,1]]
      spin_interactions = [J[k,i%N,j] for k in [0,1]]
      total_spin = sum([h[site_nbr][j] for site_nbr in site_nbrs])
      if h[i][j] > 0:
        priorities[i*N+j][0] += 2 - np.sum(spin_interactions)
        priorities[i*N+j][1] -= 2
      else:
        priorities[i*N+j][0] -= 2 - np.sum(spin_interactions)
        priorities[i*N+j][1] += 2
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.18647268518518534}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    site_nbr_interactions = [J[k,i%N,site_nbr] for k,site_nbr in zip([0,1],site_nbrs)]
    total_spin_interaction = sum(site_nbr_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] -= total_spin_interaction
      priorities[i][1] += 1
    else:
      priorities[i][0] -= total_spin_interaction
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1

  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1

  return(priority_total + total_spin)




#score: {'data2D.txt': 0.3200520061728387}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    total_spin = sum(spin_interactions)
    priorities[i][0] -= total_spin
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.18934675925925934}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbr] for k,site_nbr in zip([0,1],site_nbrs)]
    total_spin = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] -= total_spin
      priorities[i][1] += 1
    else:
      priorities[i][0] += total_spin
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0002714506172839507}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = sum([J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,0])])
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += sum(2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] -= sum(2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
    else:
      priorities[i][1] -= sum(-2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] += sum(-2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
  return(priorities)




#score: {'data2D.txt': -0.0007032407407407408}
#island_id: 2
#version_generated: 2
#generate time18:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += sum(2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] -= sum(2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
    else:
      priorities[i][1] -= sum(-2*np.sign(h[site_nbrs[0],i%N])*J[:,i%N,site_nbrs[0]])
      priorities[i][1] += sum(-2*np.sign(h[site_nbrs[1],i%N])*J[:,i%N,site_nbrs[1]])
  return(priorities)




#score: {'data2D.txt': -0.0019868827160493827}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate total spin at each site
  total_spin = np.zeros((N,N,2))
  for i in range(N):
    for j in range(N):
      if h[i][j] > 0:
        total_spin[i][j][1] -= 1
      else:
        total_spin[i][j][0] += 1
  
  # Calculate interacting spins along each axis
  interacting_spins = np.zeros((4,N,N,2))  
  for i in range(4):
    if i < 2:
      interacting_spins[i] = np.roll(total_spin, -1, axis=i//2)
    else:
      interacting_spins[i] = np.roll(total_spin, 1, axis=i//2-1)
  
  # Calculate priority at each site based on site interactions and magnetism
  for i in range(N):
    for j in range(N):
      for k in range(4):
        if h[i][j] > 0:
          priorities[i*N+j][1] -= 0.5*J[k,i,j]*interacting_spins[k,i,j][1]
          priorities[i*N+j][0] += 0.5*J[k,i,j]*interacting_spins[k,i,j][0]
        else:
          priorities[i*N+j][0] -= 0.5*J[k,i,j]*interacting_spins[k,i,j][1]
          priorities[i*N+j][1] += 0.5*J[k,i,j]*interacting_spins[k,i,j][0]
  
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = []
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities.append([1, -1])
    else:
      priorities.append([-1, 1])
  return priorities




#score: {'data2D.txt': -0.11814706790123479}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        priorities[i*N+j][0] += -J[k,i,j]*total_spin
  return(priorities)




#score: {'data2D.txt': -0.10279027777777795}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k,i,j]
        if J[k,i,j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.33364212962962864}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] -= J[k,i,j]*total_spin
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] += J[k,i,j]*total_spin
          priorities[i*N+j][1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = h[i][j]
      for k in [(i-1)%N, (i+1)%N]:
        if k != i:
          total_spin += J[0,i,j]*(h[k][j])
      for l in [(j-1)%N, (j+1)%N]:
        if l != j:
          total_spin += J[1,i,j]*(h[i,l])
      priorities[i*N+j] = np.array([-total_spin, 1-total_spin])
  return priorities




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priority_total = [[total_spin[i][1], -total_spin[i][0]] for i in range(N**2)]
  return priority_total




#score: {'data2D.txt': -0.009536882716049383}
#island_id: 0
#version_generated: 2
#generate time18:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    if h[i%N][i//N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for k in range(2):
    site_nbr = (i + ((k-1)%2 - 1)) % N
    total_spin += h[site_nbr][j]
    if h[i][j] > 0:
      priorities[i*N+j][0] += 1
      priorities[i*N+j][1] -= 1
    else:
      priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.15427453703703725}
#island_id: 0
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += J[k,i,j]
          priorities[i*N+j][1] -= J[k,i,j]
        else:
          priorities[i*N+j][0] -= J[k,i,j]

  return(priorities)




#score: {'data2D.txt': 0.01811589506172838}
#island_id: 0
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        priorities[i*N+j][0] += -total_spin
  return(priorities)




#score: {'data2D.txt': -0.19509521604938282}
#island_id: 0
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1

        priorities[i*N+j][0] += -J[k,i,j]*total_spin

      if i < N//2 and j < N//2: 
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

      elif i >= N//2 and j < N//2: 
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

      elif i >= N//2 and j >= N//2: 
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

      elif i < N//2 and j >= N//2: 
        site_nbr = (i + ((j-1)%2 - 1)) % N
        total_spin = h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.19977330246913605}
#island_id: 0
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        total_spin += J[k,i,j]*h[site][j]
      
      priorities[i*N+j][0] -= total_spin
      priorities[i*N+j][1] += total_spin
      
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.count_nonzero(h==h[i//N,i%N])
    else:
      priorities[i][1] -= np.count_nonzero(h==h[i//N,i%N])
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time18:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2,2))
  for i in range(N**2):
    total_spin = 0
    for j in range(2):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][i//N]
      if h[i//N,i%N] > 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.05594768518518519}
#island_id: 1
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    interaction_sum = sum(J[:,i%N,i//N])
    if interaction_sum < 0:
      priorities[i] = [total_spin + abs(interaction_sum), -total_spin - abs(interaction_sum)]
    elif interaction_sum > 0:
      priorities[i] = [-total_spin - abs(interaction_sum), total_spin + abs(interaction_sum)]
    else:
      if h[i//N][i%N] > 0:
        priorities[i] = [total_spin, -total_spin]
      else:
        priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.05594768518518519}
#island_id: 1
#version_generated: 2
#generate time18:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if sum(J[:,i%N,i//N]) < 0:
      priorities[i] = [total_spin + abs(sum(J[:,i%N,i//N])), -total_spin - abs(sum(J[:,i%N,i//N]))]
    elif sum(J[:,i%N,i//N]) > 0:
      priorities[i] = [-total_spin - abs(sum(J[:,i%N,i//N])), total_spin + abs(sum(J[:,i%N,i//N]))]
    else:
      if h[i//N][i%N] > 0:
        priorities[i] = [total_spin + sum(J[:,i%N,i//N]), -total_spin - sum(J[:,i%N,i//N])]
      else:
        priorities[i] = [-total_spin - sum(J[:,i%N,i//N]), total_spin + sum(J[:,i%N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.3413723765432088}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[k,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for k in [0, 1] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': -0.09870725308641984}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    total_spin = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] -= total_spin
      priorities[i][0] += abs(total_spin)
    else:
      priorities[i][1] += total_spin
      priorities[i][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    total_spin = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] -= (1 + total_spin)
      priorities[i][0] += abs(total_spin)
    else:
      priorities[i][1] += (1 - total_spin)
      priorities[i][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.09870725308641984}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])]
    total_spin = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] -= total_spin
      priorities[i][0] += abs(total_spin)
    else:
      priorities[i][1] += total_spin
      priorities[i][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.13178503086419768}
#island_id: 2
#version_generated: 2
#generate time18:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    total_spin = sum(J[k,i%N,site_nbr] * h[site_nbr,i%N] for k,site_nbr in zip([0,1], site_nbrs))
    if h[i//N,i%N] > 0:
      priorities[i][1] -= total_spin
      priorities[i][0] += abs(total_spin)
    else:
      priorities[i][1] += total_spin
      priorities[i][0] -= abs(total_spin)
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 2
        total_spin[i*N+j][1] -= 2
      else:
        total_spin[i*N+j][0] -= 2
        total_spin[i*N+j][1] += 2
  for i in range(N):
    site_nbr = (i + ((N-1)%2 - 1)) % N
    if h[i][N-1] > 0:
      total_spin[i*N+(N-1)][0] -= 1
      total_spin[i*N+(N-1)][1] += 1
    else:
      total_spin[i*N+(N-1)][0] += 1
      total_spin[i*N+(N-1)][1] -= 1
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time19:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.05759922839506175}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      priorities[i*N+j][0] += -total_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        priorities[i*N+j][0] += -total_spin * 4 / (N**2)
  return(priorities)




#score: {'data2D.txt': 0.06826003086419755}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
        priorities[i*N+j][0] += -total_spin
      site_nbr3 = (i + ((j-2)%2 - 1)) % N
      site_nbr4 = (i + ((j+2)%2 - 1)) % N
      if i < N//2:
        total_spin += h[site_nbr3][j] + J[0,i,j]
        priorities[i*N+j][0] += -total_spin
        total_spin = h[site_nbr4][j] + J[1,i,j]
        priorities[i*N+j][0] += -total_spin
      else:
        total_spin = h[site_nbr3][j] + J[2,i,j]
        priorities[i*N+j][0] += -total_spin
        total_spin = h[site_nbr4][j] + J[3,i,j]
        priorities[i*N+j][0] += -total_spin
  return(priorities)




#score: {'data2D.txt': -0.01898348765432101}
#island_id: 0
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = h[site_nbr1][j] + h[i][site_nbr2]
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin += J[k,i,j]
        else:
          total_spin -= J[k,i,j]
      if total_spin > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.08753009259259267}
#island_id: 1
#version_generated: 2
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(1,4):
      site_nbr = (i % N + ((i//N+k-1)%2 - 1)) % N
      if J[k%4,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = np.zeros(2)
    site_neighbors = []
    for k in range(4):
      site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priority_total[0] += h[site_nbr][i%N]
        priority_total[1] -= h[site_nbr][i%N]
      else:
        priority_total[0] -= h[site_nbr][i%N]
        priority_total[1] += h[site_nbr][i%N]
      site_neighbors.append(site_nbr)
    
    if total_spin > 0:
      priorities[i] = [priority_total[0], -priority_total[1]]
    else:
      priorities[i] = [-priority_total[0], priority_total[1]]
  
  return(priorities)




#score: {'data2D.txt': 0.001189969135802469}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the current state
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
    
    # Calculate the priority based on the interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        site_nbr = (i % N + ((i//N+k-1)%2 - 1)) % N
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.00037638888888888954}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N+k)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 17791998524271.793}
#island_id: 1
#version_generated: 2
#generate time19:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.1436705246913582}
#island_id: 1
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in [i%N]:
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      if J[3,i%N,j] > 0:
        if h[site_nbr][j] > 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
        elif h[site_nbr][j] < 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        
      else:
        if h[site_nbr][j] > 0:
          priorities[i][0] += 1
          priorities[i][1] -= 1
        elif h[site_nbr][j] < 0:
          priorities[i][0] -= 1
          priorities[i][1] += 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      if h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      elif h[site_nbr][i%N] < 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.0033665123456790126}
#island_id: 1
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [priorities[i][0], -priorities[i][0]]
    else:
      priorities[i] = [-priorities[i][0], priorities[i][0]]
  
  return(priorities)




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time19:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] += 3
        total_spin[i*N+j][1] -= 3
      else:
        total_spin[i*N+j][0] -= 3
        total_spin[i*N+j][1] += 3
  for k in range(N):
    for i in range(N):
      site_nbr = (i + ((k-1)%2 - 1)) % N
      if h[site_nbr][k] > 0:
        total_spin[i*N+k][0] -= 1
        total_spin[i*N+k][1] += 1
      else:
        total_spin[i*N+k][0] += 1
        total_spin[i*N+k][1] -= 1
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N-1):
      site_nbr = (i + ((j)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 2
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[k,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for k in [0, 1] for site_nbr in [site_nbrs]]
    total_interaction = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] -= total_interaction
      priorities[i][1] += 2 - 2*np.count_nonzero(h[i//N])
    else:
      priorities[i][0] += total_interaction
      priorities[i][1] -= 2 + 2*np.count_nonzero(h[i//N])
  return(priorities)




#score: {'data2D.txt': 0.3413723765432088}
#island_id: 2
#version_generated: 2
#generate time19:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[k,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for k in [0, 1] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.0011760802469135804}
#island_id: 1
#version_generated: 2
#generate time19:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr4 = ((i+N*N-1)%N)
    
    total_spin = h[site_nbr1][i%N] + J[0,i//N,i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr5 = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr5][j]
        priorities[i][1] -= h[site_nbr5][j]
      else:
        priorities[i][0] -= h[site_nbr5][j]
        priorities[i][1] += h[site_nbr5][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
     else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
     site_nbr = (i % N + ((j-1)%2 - 1)) % N
     if J[3,i%N,j] > 0:
      priorities[i][0] += h[site_nbr][j]
      priorities[i][1] -= h[site_nbr][j]
     else:
      priorities[i][0] -= h[site_nbr][j]
      priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.005190277777777778}
#island_id: 2
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = [0, 0]
    for k, site_nbr in enumerate(site_nbrs):
      if h[site_nbr][i%N] > 0:
        total_spin[1] -= J[k][i%N][site_nbr]
      else:
        total_spin[0] += J[k][i%N][site_nbr]
    priorities[i][0] = -total_spin[0]
    priorities[i][1] = -total_spin[1]
  return(priorities)




#score: {'data2D.txt': -0.005306944444444446}
#island_id: 2
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    interacting_spin = h[site_nbr,i%N]
    if J[0,i%N,site_nbr] and J[1,i%N,site_nbr]:
      priorities[i][0] += 2*interacting_spin
      priorities[i][1] -= 2*interacting_spin
    elif J[0,i%N,site_nbr]:
      priorities[i][0] += interacting_spin
      priorities[i][1] -= interacting_spin
    elif J[1,i%N,site_nbr]:
      priorities[i][0] -= interacting_spin
      priorities[i][1] += interacting_spin
  return(priorities)




#score: {'data2D.txt': 0.1975038580246913}
#island_id: 2
#version_generated: 2
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = sum(J[k,i%N,j] * h[site_nbrs[j],i%N] for k,j in itertools.product([0,1],[0,1]))
    row_sum = np.sum(h[i//N:i//N+2,i%N])
    priorities[i][0] -= spin_interactions
    if row_sum > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.1975038580246913}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 1]]
    spin_interactions = sum(J[k,i%N,j] * h[site_nbrs[j],i%N] for k,j in itertools.product([0,1],[0,1]))
    priorities[i][0] -= spin_interactions
    if np.sum(h[i//N:i//N+2,i%N]) > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0, 3]]
    spin_interactions = sum(J[k,i%N,j] * h[site_nbrs[j],i%N] for k,j in itertools.product([0,1],[0,1]))
    priorities[i][0] -= spin_interactions
    if np.sum(h[i//N:i//N+2,i%N]) > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.3309615740740732}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[0,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[1,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.003044290123456792}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[k,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for k in [0, 1] for site_nbr in [site_nbrs]]
    priorities[i][0] = -sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] = np.sum(J[:, i//N, :] * (h[:, i%N] > 0))
    else:
      priorities[i][1] = -np.sum(J[:, i//N, :] * (h[:, i%N] < 0))
  return(priorities)




#score: {'data2D.txt': -0.3315220679012336}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[0,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[1,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for site_nbr in [site_nbrs]]
    priority = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] += -priority
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= priority
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.3309615740740732}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[0,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[1,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[0,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[1,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
    # Add additional spin interaction for the diagonal neighbor
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [N-1]]
    spin_interactions = [J[0,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.15666064814814828}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  priority_total = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[i][0] += 1
      priority_total[i][1] -= 1
    else:
      priority_total[i][0] -= 1
  priorities = total_spin + priority_total
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,1]]
    spin_interactions = [J[0][i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[1][i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for site_nbr in [site_nbrs]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.23246095679012327}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    total_spin_interaction = sum([J[k,i//N%N,site_nbr[0]]*h[site_nbr[0],i%N] + J[k,i//N%N,site_nbr[1]]*h[site_nbr[1],i%N] for k in [0, 1] for site_nbr in [site_nbrs]])
    priorities[i][0] -= total_spin_interaction
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2 - sum([abs(J[k,i//N%N,j])*h[j,i%N] for k in range(4) for j in site_nbrs])
    else:
      priorities[i][1] -= 2 + sum([abs(J[k,i//N%N,j])*h[j,i%N] for k in range(4) for j in site_nbrs])
  return(priorities)




#score: {'data2D.txt': 0.29483348765432044}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.2919415123456784}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    spin_interactions = [J[k][i%N][site_nbr] * h[site_nbr][i%N] for k,site_nbr in zip([0,1,2,3],[site_nbrs[0],site_nbrs[1],site_nbrs[2],site_nbrs[3]])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N][i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.05251033950617286}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2, 2))
  
  for i in range(N2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = [0,0]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin[0] += h[site_nbr][j]
      if h[i//N,j] > 0:
        total_spin[1] -= 1
      else:
        total_spin[1] += 1
    priorities[i][0] = sum(total_spin)
    if sum(h[i//N]) > 0:
      priorities[i][1] += N2
    else:
      priorities[i][1] -= N2
  return(priorities)




#score: {'data2D.txt': -0.0025986111111111114}
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1,2,3],[1,-1,0,0])]
    total_interaction = sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][0] += total_interaction
      priorities[i][1] -= total_interaction
    else:
      priorities[i][0] -= total_interaction
      priorities[i][1] += total_interaction
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr,i%N] > 0:
      priorities[i][0] += J[3,i//N,site_nbr]*h[site_nbr,i%N]
  return(priorities)




#score: {'data2D.txt': 0.26148533950617286}
#island_id: 2
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[0,1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
    for k in range(4):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if h[site_nbr,i%N] > 0:
       priorities[i][0] += J[k,i//N,site_nbr]
       priorities[i][1] -= J[k,i//N,site_nbr]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,(i//N)%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.15475941358024714}
#island_id: 1
#version_generated: 2
#generate time19:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[3,i%N,i//N]
      priorities[i][1] -= J[3,i%N,i//N]
    else:
      priorities[i][0] -= J[3,i%N,i//N]
      priorities[i][1] += J[3,i%N,i//N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,i%N,i//N]
      priorities[i][1] -= J[0,i%N,i//N]
    else:
      priorities[i][0] -= J[0,i%N,i//N]
      priorities[i][1] += J[0,i%N,i//N]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[1,i//N,i%N]
      priorities[i][1] -= J[1,i//N,i%N]
    else:
      priorities[i][0] -= J[1,i//N,i%N]
      priorities[i][1] += J[1,i//N,i%N]
  return(priorities)




#score: {'data2D.txt': -0.0023029320987654318}
#island_id: 1
#version_generated: 2
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if total_spin > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    elif total_spin < 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0, 1]]
    total_spin = h[site_nbrs[0]][i%N] * J[0,i%N,site_nbrs[0]] + h[site_nbrs[1]][i%N] * J[1,i%N,site_nbrs[1]]
    if h[i//N][i%N] > 0:
      priorities[i][0] -= total_spin
      priorities[i][1] += 2
    else:
      priorities[i][0] += total_spin
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': -0.0004304012345679021}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = sum(J[k,i%N,site_nbrs[0]]*h[site_nbrs[0],i%N] + J[k,i%N,site_nbrs[1]]*h[site_nbrs[1],i%N] for k in [0, 1])
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.sum(J[:, i % N, site_nbrs[0]])
      priorities[i][1] -= np.sum(J[:, i % N, site_nbrs[1]])
    else:
      priorities[i][1] -= np.sum(J[:, i % N, site_nbrs[0]])
      priorities[i][1] += np.sum(J[:, i % N, site_nbrs[1]])
  return(priorities)




#score: {'data2D.txt': 0.12943410493827176}
#island_id: 2
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[0]]*h[site_nbrs[0],i%N] + J[k,i%N,site_nbrs[1]]*h[site_nbrs[1],i%N] for k in [0, 1]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.sum(spin_interactions)
    else:
      priorities[i][1] -= np.sum(spin_interactions)
  return(priorities)




#score: {'data2D.txt': 0.11266250000000014}
#island_id: 1
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i//N]
        priorities[i][1] -= h[site_nbr][i//N]
      else:
        priorities[i][0] -= h[site_nbr][i//N]
        priorities[i][1] += h[site_nbr][i//N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.30967206790123386}
#island_id: 3
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      site_interactions = []
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        site_interactions.append(h[site][j])
      avg_interaction = np.mean(site_interactions)
      if avg_interaction > 0:
        priorities[i*N+j][0] += len([x for x in site_interactions if x > 0])
        priorities[i*N+j][1] -= len([x for x in site_interactions if x < 0])
      else:
        priorities[i*N+j][0] -= len([x for x in site_interactions if x > 0])
        priorities[i*N+j][1] += len([x for x in site_interactions if x < 0])
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19697546296296325}
#island_id: 3
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.0975359567901236}
#island_id: 3
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Sum up the magnetism at each site
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Apply the magnetism at each site
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.009599845679012346}
#island_id: 1
#version_generated: 2
#generate time19:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.11740324074074088}
#island_id: 3
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]
        
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      
      # Add diagonal interactions
      site = ((i+1)%N + (j-1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site = ((i+1)%N + (j+1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.0975359567901236}
#island_id: 3
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.1540226851851854}
#island_id: 3
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if h[site][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
        
      if h[i][j] > 0:
        priorities[i*N+j][0] += abs(total_spin)
        priorities[i*N+j][1] -= total_spin
      else:
        priorities[i*N+j][0] -= abs(total_spin)
        priorities[i*N+j][1] += total_spin
      
  return(priorities)




#score: {'data2D.txt': -0.11740324074074088}
#island_id: 3
#version_generated: 2
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N, 2))

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]

      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]

        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1

      # Add diagonal interactions
      site = ((i+1)%N + (j-1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

      site = ((i+1)%N + (j+1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    # Calculate the priority based on the total spin
    if priorities[i][0] > priorities[i][1]:
      priorities[i] = [priorities[i][0], 0.9*priorities[i][1]]
    elif priorities[i][0] < priorities[i][1]:
      priorities[i] = [0.9*priorities[i][0], priorities[i][1]]
    else:
      if np.random.rand() < 0.5:
        priorities[i] = [priorities[i][0], 0]
      else:
        priorities[i] = [0, priorities[i][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.32129645061728307}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = sum([J[k,i//N,site_nbrs[j]]*h[site_nbrs[j],i%N] for k,j in zip([0,1],[1,-1])])
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32115416666666585}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    site_nbrs = [(i % N + ((j+1)%2 - 1)) % N for j in [-1,1]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 2
    else:
      priorities[i][1] -= 2
  return(priorities)




#score: {'data2D.txt': 0.33632546296296195}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,3]]
    spin_interactions = [J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,3],[1,-1])]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32115416666666585}
#island_id: 2
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = sum(J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1]))
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.08195910493827173}
#island_id: 0
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
        
  for i in range(N):
    for j in range(N-1):
      site_nbr = (i + ((j)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
        
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][0] -= 1
        
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': 0.09752453703703716}
#island_id: 0
#version_generated: 2
#generate time19:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
  for i in range(N):
    for j in range(N-1):
      site_nbr = (i + ((j)%2 - 1)) % N
      if h[i][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  for k in range(N):
    site = (k % N + ((k//N-1)%2 - 1)) % N
    for j in range(N):
      if h[site][j] > 0:
        total_spin[k*N+j][0] += 1
        total_spin[k*N+j][1] -= 1
      else:
        total_spin[k*N+j][0] -= 1
        
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = sum(h[(i+((j-1)%2 - 1)) % N][j] for _ in range(4)) + h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.21425138888888906}
#island_id: 3
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site_nbr = (i + ((j+1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site_nbr = (i + ((j-2)%2 - 1)) % N
      if j > 0:
        total_spin += h[site_nbr][j-1]
        if h[i][j-1] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
        
      site_nbr = ((i+1)%N + (j-1)%2) % N
      if i < N-1:
        total_spin += h[site_nbr][j]
        if h[i+1][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
        
      site_nbr = ((i-1)%N + (j+1)%2) % N
      if i > 0:
        total_spin += h[site_nbr][j]
        if h[i-1][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.11740324074074088}
#island_id: 3
#version_generated: 2
#generate time19:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]
        
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      
      # Add diagonal interactions
      site = ((i+1)%N + (j-1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site = ((i+1)%N + (j+1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.11489799382716062}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.0013041666666666661}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]*h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.001026697530864197}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if i % N == 0:
     for j in range(N):
       site_nbr = (i + N - 1, j)
       total_spin = h[site_nbr[0]][site_nbr[1]]
       for k in range(4):
         if J[k,site_nbr[1],site_nbr[0]] > 0:
           total_spin += 1
         else:
           total_spin -= 1
       if h[i//N][i%N] > 0:
         priorities[i*N+j] = [total_spin, -total_spin]
       else:
         priorities[i*N+j] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': -0.11740324074074088}
#island_id: 3
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N_half = N // 2
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site][j]
        
        if h[site][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
        
      # Add diagonal interactions
      site = ((i+1)%N + (j-1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
      site = ((i+1)%N + (j+1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.2842266975308637}
#island_id: 3
#version_generated: 2
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(3):
        site_nbr = ((i+k)%N + (j-k)%2) % N
        total_spin += h[site_nbr][j]
        
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      
      # Add diagonal interactions
      site = ((i+1)%N + (j-1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      site = ((i+1)%N + (j+1)) % N
      if h[site][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': 0.1413282407407409}
#island_id: 2
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = sum(J[k,i%N,site_nbr] for k,site_nbr in zip([0,1],site_nbrs))
    priorities[i][0] -= np.sum(spin_interactions*h[site_nbrs])
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.17068873456790226}
#island_id: 2
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in [0,1,3]]
    spin_interactions = sum(J[k,i%N,j] for j,k in zip(site_nbrs,[0,1]))
    total_spin = h[i//N][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 2 * total_spin
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 2 * total_spin
  return(priorities)




#score: {'data2D.txt': 0.011244907407407407}
#island_id: 2
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1,3]]
    spin_interactions = sum(J[k,i%N,site_nbrs[j]]*h[site_nbrs[j],i//N] for k,j in zip([0,1],[1,-1]))
    priorities[i][0] -= spin_interactions
    if h[i//N,i%N] > 0:
      priorities[i][1] += 1
    else:
      priorities[i][1] -= 1
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    priorities[i][0] -= J[0,site_nbr,i%N]*h[site_nbr,i//N]
    if h[site_nbr,i//N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if h[site][j] > 0 and k == 0 or k == 3:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        elif h[site][j] < 0 and k == 1 or k == 2:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.020026080246913564}
#island_id: 3
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i + ((j-1)%2 - 1)) % N, (i + (j+1)%2) % N, (i-1)%N if i > 0 else N-1, (i+1)%N]
      total_spin = h[site_nbrs[0]][j] if len({k for k in site_nbrs}.intersection({j})) else 0
      for site_nbr in site_nbrs:
        total_spin += h[site_nbr][j]
        if h[i][j] > 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr1][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
      for k in range(2):
        site = (i + ((k)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      if h[site_nbr2][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          total_spin[i*N+j][0] -= 1
          total_spin[i*N+j][1] += 1
        else:
          total_spin[i*N+j][0] += 1
          total_spin[i*N+j][1] -= 1
      
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        total_spin[i*N+j][0] -= 1
        total_spin[i*N+j][1] += 1
      else:
        total_spin[i*N+j][0] += 1
        total_spin[i*N+j][1] -= 1
      
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = np.zeros((N**2,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      
      total_spin[i*N+j][0] += h[site_nbr1][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
      
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          if k%2 == 0:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
          else:
            total_spin[i*N+j][0] -= 1
            total_spin[i*N+j][1] += 1
        else:
          if k%2 == 0:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
          else:
            total_spin[i*N+j][0] += 1
            total_spin[i*N+j][1] -= 1
      
  priorities = np.array([(total_spin[i][0], -total_spin[i][1]) for i in range(N**2)])
  return priorities.tolist()




#score: {'data2D.txt': -0.0012384259259259256}
#island_id: 1
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i//N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': -0.1662359567901237}
#island_id: 1
#version_generated: 2
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
    else:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16585632716049406}
#island_id: 1
#version_generated: 2
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-(i//N)%2 - 1)) % N)
    if J[3,i%N,(i//N)%N] > 0:
      if i//N < N/2:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    else:
      if i//N < N/2:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate interactions with nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Apply magnetism at the site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
        
  return(priorities)




#score: {'data2D.txt': 0.0006214506172839524}
#island_id: 2
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions = [J[k,i%N,site_nbrs[0]]*h[site_nbrs[0],i%N] + J[k,i%N,site_nbrs[1]]*h[site_nbrs[1],i%N] for k in [0, 1]]
    priorities[i][0] -= sum(spin_interactions)
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.sum([J[k,i%N,site_nbr] for k in range(2) for site_nbr in site_nbrs])
    else:
      priorities[i][1] -= np.sum([J[k,i%N,site_nbr] for k in range(2) for site_nbr in site_nbrs])
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in [0,1]]
    spin_interactions_sum = sum(J[k,i%N,site_nbr] * h[site_nbr,i%N] for k in [0, 1] for site_nbr in site_nbrs)
    priorities[i][0] -= spin_interactions_sum
    if h[i//N,i%N] > 0:
      priorities[i][1] += np.sum(np.where(h == 0, 1, -1))
    else:
      priorities[i][1] -= np.sum(np.where(h == 0, 1, -1))
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  total_spin = [[0, 0] for _ in range(N**2)]
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin[i*N+j][0] += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin[i*N+j][1] -= 1
      else:
        total_spin[i*N+j][1] += 1
  return [[spin[0], -spin[1]] for spin in total_spin]




#score: {'data2D.txt': -0.20131095679012337}
#island_id: 3
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if total_spin < 0:
            priorities[i*N+j][0] += 2
            priorities[i*N+j][1] -= 2
          elif total_spin > 0:
            priorities[i*N+j][0] -= 2
            priorities[i*N+j][1] += 2
        else:
          if total_spin < 0:
            priorities[i*N+j][0] -= 2
            priorities[i*N+j][1] += 2
          elif total_spin > 0:
            priorities[i*N+j][0] += 2
            priorities[i*N+j][1] -= 2
  return(priorities)




#score: {'data2D.txt': -0.002702623456790123}
#island_id: 3
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in range(4):
        if abs(h[site_nbr][j]) > abs(h[i][j]):
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= total_spin
  return(priorities)




#score: {'data2D.txt': -0.002702623456790123}
#island_id: 3
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        if abs(h[site_nbr][j]) > abs(h[i][j]):
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] = total_spin * 3
      priorities[i*N+j][1] = -total_spin * 3
  return(priorities)




#score: {'data2D.txt': -0.17288996913580196}
#island_id: 3
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 3
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      for k in [0, 1]:
        if h[site_nbr][j] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= total_spin
  return(priorities)




#score: {'data2D.txt': 0.11928101851851865}
#island_id: 1
#version_generated: 2
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i,j] > 0:
        priorities[i*N+j][0] += h[site_nbr][j]
        priorities[i*N+j][1] -= h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= h[site_nbr][j]
        priorities[i*N+j][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11623101851851865}
#island_id: 1
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    for k in range(3):
      site = (i + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.16273595679012368}
#island_id: 1
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Consider all interactions at once
    total_spin += np.sum(np.where(J[:,i%N,i//N], 1, -1))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.004304475308641975}
#island_id: 1
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with the left and right neighbors
    total_spin += J[0, i%N, i//N] * h[(i+1)%N][i%N]
    total_spin -= J[1, i%N, i//N] * h[(i-1)%N if i else N-1][i%N]
    
    # Calculate the interaction with the top and bottom neighbors
    total_spin += J[2, i%N, i//N] * h[i%(N-1) or 0][(i+1)%N]
    total_spin -= J[3, i%N, i//N] * h[i%(N-1) or 0][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.2689158950617281}
#island_id: 3
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin_left = 0
      total_spin_right = 0
      for k in range(2):
        if h[site_nbr][j] > 0:
          total_spin_left += 1
          total_spin_right -= 1
        else:
          total_spin_left -= 1
          total_spin_right += 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] = total_spin_left * 3 + total_spin_right * 2
      priorities[i*N+j][1] = -total_spin_left * 3 - total_spin_right * 2
  return(priorities)




#score: {'data2D.txt': -0.03803410493827157}
#island_id: 3
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        if abs(h[site_nbr][j]) > abs(h[i][j]):
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] = total_spin * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  interacting_spins = np.zeros((4, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      total_spin = h[(i + ((j-1)%2 - 1)) % N][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.18754922839506175}
#island_id: 0
#version_generated: 2
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N), ((i+1)%N, (j+1)%N)]:
        if h[k[0]][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 0
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[(i + ((j-1)%2 - 1)) % N:(i+1), (j-1)//2:j//2+1].flatten())
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.18350756172839489}
#island_id: 0
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[site_nbr][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.251680709876543}
#island_id: 0
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      if h[i][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N), ((i+1)%N, (j+1)%N)]
      for k in site_nbrs:
        if h[k[0]][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.07164429012345688}
#island_id: 0
#version_generated: 2
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      spin_sum = 0
      for k in [(site_nbr, j), ((i+1)%N, j), (i, (j+1)%N), ((i+1)%N, (j+1)%N)]:
        if h[k[0]][k[1]] > 0:
          spin_sum += 1
        else:
          spin_sum -= 1
      priorities[i*N+j][0] = spin_sum
      priorities[i*N+j][1] = -spin_sum
  return priorities




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  interacting_spins = np.zeros((4,N,N))  
  for i in range(2):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(2):
    interacting_spins[i+2] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1

  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  return(priorities)




#score: {'data2D.txt': -0.15808317901234592}
#island_id: 0
#version_generated: 2
#generate time19:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      if h[site_nbr][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[site_nbr][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      for k in [(i-1, j), (i, (j-1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[site_nbr][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      for k in [(i+1, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[site_nbr][k[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 2
#version_generated: 2
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for k in range(N2):
    site_nbr = (k % N + ((k//N-1)%2 - 1)) % N
    if h[site_nbr][k%N] > 0:
      priorities[k][0] += 1
      priorities[k][1] -= 1
    else:
      priorities[k][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.1912183641975312}
#island_id: 2
#version_generated: 2
#generate time19:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in [(i-1)%N, (i+1)%N]:
        if k == i:
          continue
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin+1
      else:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin+1
        
  return(priorities)




#score: {'data2D.txt': 0.0038356481481481484}
#island_id: 1
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.16223996913580271}
#island_id: 1
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
        
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N, i//N] > 0:
      priorities[i][0] += h[site_nbr][i//N]
      priorities[i][1] -= h[site_nbr][i//N]
    else:
      priorities[i][0] -= h[site_nbr][i//N]
      priorities[i][1] += h[site_nbr][i//N]
      
  return(priorities)




#score: {'data2D.txt': -0.3085236111111104}
#island_id: 3
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if k%2 == 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          if k%2 == 0:
            priorities[i*N+j][0] -= 1
            priorities[i*N+j][1] += 1
          else:
            priorities[i*N+j][0] += 1
  return(priorities)




#score: {'data2D.txt': -0.013065895061728387}
#island_id: 3
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if h[site][j] * h[i][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.001034104938271606}
#island_id: 2
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)//N), ((j+1)//N)]
      total_spin = 0
      for k in site_nbrs:
        if k == i or k == j:
          continue
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin+1
      else:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin-1
        
  return(priorities)




#score: {'data2D.txt': -0.24074614197530855}
#island_id: 2
#version_generated: 2
#generate time19:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin+1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin+1
      
  return(priorities)




#score: {'data2D.txt': 0.15551188271604963}
#island_id: 1
#version_generated: 2
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03803410493827157}
#island_id: 3
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = 0
      for k in range(4):
        if abs(h[site_nbr][j]) > abs(h[i][j]):
          total_spin += 1
        else:
          total_spin -= 1
        site_nbr = ((site_nbr + k) % N + (j-k)%2) % N
      priorities[i*N+j][0] = total_spin * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.00015293209876543197}
#island_id: 3
#version_generated: 2
#generate time19:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = ((i+k)%N + (j-k)%2) % N
        if h[site_nbr][j] * h[i][j] < 0:
          total_spin += 1
        else:
          total_spin -= 1
      priorities[i*N+j][0] += total_spin
      priorities[i*N+j][1] -= total_spin
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.009849845679012348}
#island_id: 1
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16007330246913604}
#island_id: 1
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = sum(1 if J[k,i//N,i//N] == J[3,i//N,i%N] else -1 for k in range(4))
    else:
      total_spin = sum(-1 if J[k,i//N,i//N] == J[3,i//N,i%N] else 1 for k in range(4))
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0019038580246913575}
#island_id: 1
#version_generated: 2
#generate time19:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += total_spin
        priorities[i][1] -= total_spin
      else:
        priorities[i][0] -= total_spin
        priorities[i][1] += total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the effective magnetic field
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the site interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.253476697530864}
#island_id: 3
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(2):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if h[site][j] * h[i][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif k == 0 and abs(h[site][j]) > 0:
          if h[site][j] * h[i][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.17419367283950613}
#island_id: 3
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if h[site][j] * h[i][j] < 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif abs(h[site][j]) == abs(h[i][j]):
          if h[site][j] * h[i][j] < 0:
            priorities[i*N+j][0] += 2
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.19738750000000027}
#island_id: 3
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] * h[i][j] < 0:
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.24674737654320963}
#island_id: 3
#version_generated: 2
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if h[site][j] * h[i][j] < 0:
          if np.abs(h[site][j]) > np.abs(h[i][j]):
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.32721682098765364}
#island_id: 3
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][j] - 2*h[i][j] for _ in range(4))
      priorities[i*N+j][0] = total_spin * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.00019984567901234573}
#island_id: 3
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      for k in range(4):
        site_nbr = ((i + (k-1)%2 - 1)) % N
        if h[site_nbr][j] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.14578101851851866}
#island_id: 3
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          if h[site][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif abs(h[site][j]) < abs(h[i][j]):
          if h[site][j] > 0:
            priorities[i*N+j][0] -= 1
            priorities[i*N+j][1] += 1
          else:
            priorities[i*N+j][0] += 1
        else:
          if h[site][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': -0.0024279320987654327}
#island_id: 3
#version_generated: 2
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
      for k in range(N):
        site = ((i+k)%N + (j-k)%2) % N
        if abs(h[site][j]) > abs(h[i][j]):
          priorities[i*N+j][0] += 1
          priorities[i*N+j][1] -= 1
        else:
          priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.009274228395061727}
#island_id: 2
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': 0.2111958333333334}
#island_id: 0
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.32721682098765364}
#island_id: 3
#version_generated: 2
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + (j+1)%2) % N
      site_nbr3 = (i+1)%N
      site_nbr4 = (i+(j+1)%N) % N
      total_spin = sum(h[site_nbr1][j] - 2*h[i][j] for _ in range(4))
      priorities[i*N+j][0] = total_spin * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.03135787037037038}
#island_id: 3
#version_generated: 2
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][k] - 2*h[i][k] for k in range(N))
      priorities[i*N+j][0] = total_spin
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.005489351851851851}
#island_id: 1
#version_generated: 2
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i % N)
    total_spin = h[site_nbr_row][site_nbr_col]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr_row = (j % N + ((i-1)%2 - 1)) % N
      site_nbr_col = (i % N)
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr_row][site_nbr_col]
      else:
        total_spin -= h[site_nbr_row][site_nbr_col]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      total_spin = total_spin / (abs(total_spin) + 1)
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return priorities




#score: {'data2D.txt': 0.13478070987654353}
#island_id: 0
#version_generated: 2
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      priority_total = [total_spin, -total_spin]
      for k in range(3):
        site = (i + ((k-1)%2 - 1)) % N
        if h[site][j] > 0:
          priority_total[1] -= 1
        else:
          priority_total[1] += 1
      priorities[i*N+j] = priority_total
  return priorities




#score: {'data2D.txt': 0.001034104938271606}
#island_id: 2
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)//N), ((j+1)//N)]
      total_spin = 0
      for k in site_nbrs:
        if k == i or k == j:
          continue
        site_nbr = (k + ((j-1)%2 - 1)) % N
        total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += total_spin+1
      else:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= total_spin-1
      
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    spin_magnetism = 2*h[i//N][i%N]
    nearest_neighbor = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      spin_magnetism += h[nearest_neighbor][i%N]
    else:
      spin_magnetism -= h[nearest_neighbor][i%N]
    
    priorities[i][0] = total_spin + spin_magnetism
    priorities[i][1] = -total_spin + spin_magnetism
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.059264660493827184}
#island_id: 1
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N+1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]

    if J[1,i%N,(i//N)%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr3][i%N]
      priorities[i][1] -= h[site_nbr3][i%N]
    else:
      priorities[i][0] -= h[site_nbr3][i%N]
      priorities[i][1] += h[site_nbr3][i%N]

    if J[3,i//N,(i//N)%N] > 0:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] -= h[i//N][i%N]
      priorities[i][1] += h[i//N][i%N]

  return(priorities)




#score: {'data2D.txt': 0.2111958333333334}
#island_id: 0
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.12243688271604954}
#island_id: 0
#version_generated: 2
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      for k in [(i-1, j), ((i+1)%N, j), (i, j-1), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return priorities




#score: {'data2D.txt': 0.2111958333333334}
#island_id: 0
#version_generated: 2
#generate time19:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16364583333333357}
#island_id: 1
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.1155498456790125}
#island_id: 1
#version_generated: 2
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16480293209876568}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1, 3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr = (i % N + ((2-i%N)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16416959876543233}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.165824228395062}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_col = ((i//N)-1)%N
    
    if J[3,i%N,(i//N)] > 0:
      total_spin += h[site_nbr_row][i%N]
      total_spin -= h[site_nbr_col][i//N]
    else:
      total_spin -= h[site_nbr_row][i%N]
      total_spin += h[site_nbr_col][i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16166496913580272}
#island_id: 1
#version_generated: 2
#generate time19:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
     else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
     priorities[i][0] += h[site_nbr][i%N]
     priorities[i][1] -= h[site_nbr][i%N]
    else:
     priorities[i][0] -= h[site_nbr][i%N]
     priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.016002314814814813}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      priorities[i] = [np.sum(J[:,i//N,i%N]), np.sum(-J[:,i//N,i%N])]
    else:
      priorities[i] = [np.sum(-J[:,i//N,i%N]), np.sum(J[:,i//N,i%N])]
    
  return(priorities)




#score: {'data2D.txt': 0.1647100308641978}
#island_id: 1
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction term from the north and south neighbors
    if i // N > 0:
      if J[3, i%N, (i//N)-1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i // N < N-1:
      if J[3, i%N, i//N+1] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the interaction term from the east and west neighbors
    if i % N > 0:
      if J[2, (i-1)%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if i % N < N-1:
      if J[2, (i+1)%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.19042669753086416}
#island_id: 0
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      spin_sum = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      priorities[i*N+j][0] = spin_sum
      priorities[i*N+j][1] = -spin_sum
  return priorities




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] if h[site_nbr[0]][site_nbr[1]] > 0 else -h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return priorities




#score: {'data2D.txt': -0.055393364197530874}
#island_id: 3
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
      for k in range(4):
        site = ((i+k)%N + (j-k)%2) % N
        if h[site][j] * h[i][j] < 0:
          total_spin += h[site][j]
          if h[site][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
        elif abs(h[site][j]) > abs(h[i][j]):
          total_spin = h[site][j]
          if h[site][j] > 0:
            priorities[i*N+j][0] += 1
            priorities[i*N+j][1] -= 1
          else:
            priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': -0.20149521604938292}
#island_id: 3
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N * N
  priorities = np.zeros((N2, 2))
  
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
        
  for i in range(N2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 3
#version_generated: 2
#generate time19:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = np.sum(h[(i + (k - 1) % N) % N][j] for k in range(4)) + h[i][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11753040123456804}
#island_id: 1
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.17994459876543234}
#island_id: 1
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    if h[site_nbr2][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.00887638888888889}
#island_id: 2
#version_generated: 2
#generate time19:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += J[i%N*N:(i%N+1)*N].sum()
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[i%N*N:(i%N+1)*N].sum()
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.12533348765432115}
#island_id: 0
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      for k in [(i, (j+2)%N), ((i+1)%N, j)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.24236898148148148}
#island_id: 0
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.2111958333333334}
#island_id: 0
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.2111958333333334}
#island_id: 0
#version_generated: 2
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      for k in [(i, j), ((i+1)%N, j), (i, (j+1)%N)]:
        site_nbr = (k[0] + ((k[1]-1)%2 - 1)) % N
        if h[k[0]][k[1]] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      priorities[i*N+j][0] = total_spin
      priorities[i*N+j][1] = -total_spin
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.0021924382716049383}
#island_id: 1
#version_generated: 2
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i % N + (i//N)%2) % N
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr1][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.34315478395061627}
#island_id: 0
#version_generated: 2
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      total_spin = total_spin / (abs(total_spin) + 1)
      priorities[i*N+j][0] = -total_spin
      priorities[i*N+j][1] = total_spin
  return priorities




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0025905864197530866}
#island_id: 1
#version_generated: 2
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -1.0743415451204615e+181}
#island_id: 1
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.23716836419753037}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr1 = (i + ((j-1)%2 - 1)) % N
      site_nbr2 = (i + ((j+1)%2 - 1)) % N
      total_spin = sum(h[site_nbr1][j] + h[i][j] + h[site_nbr2][j] for _ in range(3))
      priorities[i*N+j][0] = total_spin * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.32684706790123386}
#island_id: 3
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][j] - 2*h[i][j] for _ in range(4))
      interaction = J[i*N:(i+1)*N,j*N:(j+1)*N].flatten().sum()
      priorities[i*N+j][0] = (total_spin + interaction) * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, (j-1)%N, (j+1)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': -0.17440416666666692}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      spin_counts = [0] * 3
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      for site_nbr in site_nbrs:
        if h[site_nbr[0]][site_nbr[1]] > 0:
          total_spin += 1
          spin_counts[0] += 1
        elif h[site_nbr[0]][site_nbr[1]] < 0:
          total_spin -= 1
          spin_counts[2] += 1
      priorities[i*N+j][0] = total_spin + (spin_counts[0] - spin_counts[2])
      priorities[i*N+j][1] = -total_spin - (spin_counts[0] - spin_counts[2])
  return priorities




#score: {'data2D.txt': 0.34300694444444335}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def get_neighbor_spin(i, j):
    spins = []
    if i > 0:
      spins.append(h[(i-1)%N][j])
    if j > 0:
      spins.append(h[i][(j-1)%N])
    if i < N - 1:
      spins.append(h[(i+1)%N][j])
    if j < N - 1:
      spins.append(h[i][(j+1)%N])
    return sum(spin for spin in spins) / len(spins)

  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      neighbor_spin = get_neighbor_spin(i, j)
      priorities[i*N+j][0] = total_spin + neighbor_spin
      priorities[i*N+j][1] = -total_spin - neighbor_spin
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
  return(priorities)




#score: {'data2D.txt': -0.10357762345679021}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 0
#version_generated: 2
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= 1
        priorities[i*N+j][1] += 1
      else:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
  return(priorities)




#score: {'data2D.txt': 0.2992202160493821}
#island_id: 0
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def get_neighbor_spins(i, j):
    spins = [h[(i-1)%N][j], h[i][(j-1)%N], h[(i+1)%N][j], h[i][(j+1)%N]]
    return sum(spin for spin in spins) / len([spin for spin in spins if spin > 0])

  priorities = np.zeros((N**2, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i, j), ((i+1)%N, j), (i, (j+1)%N)]
      total_spin = sum(h[site_nbr[0]][site_nbr[1]] for site_nbr in site_nbrs)
      if h[i][j] > 0:
        total_spin -= len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] > 0])
      else:
        total_spin += len([site_nbr for site_nbr in site_nbrs if h[site_nbr[0]][site_nbr[1]] < 0])
      neighbor_spin = get_neighbor_spins(i, j)
      priorities[i*N+j][0] = total_spin + neighbor_spin
      priorities[i*N+j][1] = -total_spin - neighbor_spin
  return priorities




#score: {'data2D.txt': -0.009153240740740741}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += J[i%N*N:(i%N+1)*N].sum() - (J[(i+N)%N*N:(i+N+1)*N].sum() + J[(i-N)%N*N:(i-N+1)*N].sum())
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= J[i%N*N:(i%N+1)*N].sum() - (J[(i+N)%N*N:(i+N+1)*N].sum() + J[(i-N)%N*N:(i-N+1)*N].sum())
      priorities[i][1] += 2
  
  return(priorities)




#score: {'data2D.txt': -0.0011776234567901231}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += J[i%N*N:(i%N+1)*N].sum()
      priorities[i][1] -= (J[i%N*N:(i%N+1)*N].sum() + J[(i-1)%N*N:(i+1)*N].sum()) / 2
    else:
      priorities[i][0] -= J[i%N*N:(i%N+1)*N].sum()
      priorities[i][1] += (J[i%N*N:(i%N+1)*N].sum() + J[(i-1)%N*N:(i+1)*N].sum()) / 2
  
  return(priorities)




#score: {'data2D.txt': -0.00887638888888889}
#island_id: 2
#version_generated: 2
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.34300848765431996}
#island_id: 3
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][j] - 2*h[i][j] for _ in range(4))
      interaction = J[i*N:(i+1)*N,j*N:(j+1)*N].flatten().sum()
      priority = (total_spin + interaction) * 3
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1 - 2 * np.exp(-2*priority)
        priorities[i*N+j][1] -= 1 + 2 * np.exp(-2*priority)
      else:
        priorities[i*N+j][0] -= 1 - 2 * np.exp(-2*priority)
        priorities[i*N+j][1] += 1 + 2 * np.exp(-2*priority)
  return(priorities)




#score: {'data2D.txt': 0.3365063271604929}
#island_id: 3
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i+1)%N, (i-1+N)%N, (j+1)%N, (j-1+N)%N]
      total_spin = sum(h[site_nbr][j] - 2*h[i][j] for site_nbr in site_nbrs)
      interaction = J[i*N:(i+1)*N,j*N:(j+1)*N].flatten().sum()
      priorities[i*N+j][0] = (total_spin + interaction) * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': 0.32684706790123386}
#island_id: 3
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = sum(h[site_nbr][j] - 2*h[i][j] for _ in range(4))
      interaction = J[i*N:(i+1)*N,j*N:(j+1)*N].flatten().sum()
      priorities[i*N+j][0] = (total_spin + interaction) * 3
      if h[i][j] > 0:
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][1] += 1
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_up = total_spin
    priority_down = -total_spin
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_up += h[site_nbr][j]
        priority_down -= h[site_nbr][j]
      else:
        priority_up -= h[site_nbr][j]
        priority_down += h[site_nbr][j]
    
    priorities[i] = [priority_up, priority_down]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0016717592592592598}
#island_id: 1
#version_generated: 2
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(4):
      site_nbr2 = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr2][i%N]
      else:
        total_spin -= h[site_nbr2][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1539337962962965}
#island_id: 0
#version_generated: 2
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': -0.0022853395061728397}
#island_id: 0
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = ((i+1) % N + ((i//N)%2 - 1)) % N
    site_nbr3 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr4 = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      total_spin = h[site_nbr1][i%N]
      total_spin += h[site_nbr3][i%N]
    else:
      total_spin = -h[site_nbr1][i%N]
      total_spin -= h[site_nbr3][i%N]
    
    if J[1,i//N,i%N] > 0:
      total_spin += h[site_nbr2][i%N]
    else:
      total_spin -= h[site_nbr2][i%N]
    
    if J[2,i%N,i//N] > 0:
      total_spin += h[site_nbr1][i%N]
    else:
      total_spin -= h[site_nbr1][i%N]
    
    if J[3,i//N,i%N] > 0:
      total_spin += h[site_nbr4][i%N]
    else:
      total_spin -= h[site_nbr4][i%N]
    
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1044908950617285}
#island_id: 3
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] += [bias, -bias]
    else:
      priorities[i] -= [bias, -bias]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      total_spin = 0
      magnetism = h[i][j]
      if magnetism > 0:
        priorities[i*N+j] += [-1, 1]
      else:
        priorities[i*N+j] += [1, -1]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]
  return(priorities)




#score: {'data2D.txt': 0.1539337962962965}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.1539337962962965}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.147665277777778}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.19763256172839513}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.05788317901234571}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions, prioritizing nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Normalize by the number of neighbors
    total_spin /= sum(J[:,i//N,i%N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012162037037037035}
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i-1)%N)) % N
    site_nbr_right = (i % N + ((i+1)%N)) % N
    
    if J[3,i%N,(i//N)*N+i%N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
    site_nbr_up = (i % N + ((i//N-1)%N)) % N
    site_nbr_down = (i % N + ((i//N+1)%N)) % N
    
    if J[2,i//N,i%N] > 0:
      priorities[i][0] += h[i//N,site_nbr_up]
      priorities[i][1] -= h[i//N,site_nbr_up]
      priorities[i][0] += h[i//N,site_nbr_down]
      priorities[i][1] -= h[i//N,site_nbr_down]
    else:
      priorities[i][0] -= h[i//N,site_nbr_up]
      priorities[i][1] += h[i//N,site_nbr_up]
      priorities[i][0] -= h[i//N,site_nbr_down]
      priorities[i][1] += h[i//N,site_nbr_down]
    
    return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add interactions with neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priorities based on magnetism and spin
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.24074614197530855}
#island_id: 2
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin+1
    else:
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin+1
      
  return(priorities)




#score: {'data2D.txt': 0.19763256172839513}
#island_id: 0
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22132824074074067}
#island_id: 0
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1865779320987655}
#island_id: 0
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16659830246913607}
#island_id: 1
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_row = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr_row][j]
        priorities[i][1] -= h[site_nbr_col][i%N]
      else:
        priorities[i][0] -= h[site_nbr_row][j]
        priorities[i][1] += h[site_nbr_col][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16565200617283976}
#island_id: 1
#version_generated: 2
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = h[i%N][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.012891820987654323}
#island_id: 2
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        total_spin -= sum(spin_count)
        priorities[i*N+j][0] = -total_spin
        priorities[i*N+j][1] = spin_count[1]+1
      else:
        total_spin = sum(spin_count)
        priorities[i*N+j][0] = total_spin
        priorities[i*N+j][1] = spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.19651496913580255}
#island_id: 0
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions, taking into account whether the site is on an edge or not
    for k in range(4):
      j = (i//N + ((k-2)%2 - 1)) % N
      l = (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below, taking into account edge cases
    if i//N > 0:
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i//N - 1) * N + ((i%N+1)%N)
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below, taking into account edge cases
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = (i//N - 1) * N + ((i%N-1)%2 - 1)
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14671250000000013}
#island_id: 0
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22308996913580237}
#island_id: 0
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2236711419753086}
#island_id: 0
#version_generated: 2
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions with all four neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N - k, i%N
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in range(2):
      j, l = i//N - k, (i % N == 0 or i % N == N - 1) and i//N or i//N - k
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (8 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 0
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add magnetism term
    total_spin += h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.002738425925925926}
#island_id: 3
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * (h[i//N][i%N] - J[3, i%N, i//N])
      priorities[i][1] = -(total_spin * (h[i//N][i%N] - J[3, i%N, i//N]))
    else:
      priorities[i][0] = -(total_spin * (h[i//N][i%N] + J[3, i%N, i//N]))
      priorities[i][1] = total_spin * (h[i//N][i%N] + J[3, i%N, i//N])
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + magnetism/2, -total_spin + magnetism/2]
    else:
      priorities[i] = [-total_spin + magnetism/2, total_spin + magnetism/2]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.06275601851851854}
#island_id: 3
#version_generated: 2
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    spin_magnetism = h[i//N][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if spin_magnetism > 0:
      priorities[i] = [total_spin/2 + (spin_magnetism>0), -(total_spin/2 + (spin_magnetism<0))]
    else:
      priorities[i] = [-total_spin/2 - (spin_magnetism<0), total_spin/2 - (spin_magnetism>0)]
  return(priorities)




#score: {'data2D.txt': 0.11348472222222235}
#island_id: 1
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((k-1)%2 - 1)) % N for k in range(4)]
    total_spin = sum(h[site_nbr][i%N] if J[k,i//N,i%N] > 0 else -h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1

  # Add a term based on the magnetism at each site
  for i in range(N):
    for j in range(N):
      priorities[i*N+j][0] += h[i][j]
      priorities[i*N+j][1] -= h[i][j]

  return(priorities)




#score: {'data2D.txt': 0.0016158950617283952}
#island_id: 2
#version_generated: 2
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      total_magnetism = sum(h[k%N][k%N] for k in site_nbrs)
      if total_magnetism > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbr = (i + ((j-1)%2 - 1)) % N
      total_spin = h[site_nbr][j]
      if h[i][j] > 0:
        priorities[i*N+j][0] += 1
        priorities[i*N+j][1] -= 1
      else:
        priorities[i*N+j][0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the priority based on the magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.00033688271604938216}
#island_id: 1
#version_generated: 2
#generate time20:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = np.sum(J[:,i//N,i//N])
      
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
      
      for j in range(N):
        site_nbr = (i % N + ((j-1)%2 - 1)) % N
        
        if J[3,i%N,j] > 0:
          priorities[i][0] += h[site_nbr][j]
          priorities[i][1] -= h[site_nbr][j]
        else:
          priorities[i][0] -= h[site_nbr][j]
          priorities[i][1] += h[site_nbr][j]
    else:
      total_spin = -np.sum(J[:,i//N,i//N])
      
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
      
      for j in range(N):
        site_nbr = (i % N + ((j-1)%2 - 1)) % N
        
        if J[3,i%N,j] > 0:
          priorities[i][0] -= h[site_nbr][j]
          priorities[i][1] += h[site_nbr][j]
        else:
          priorities[i][0] += h[site_nbr][j]
          priorities[i][1] -= h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.1623054012345681}
#island_id: 1
#version_generated: 2
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in [(i-1)%N, (i+1)%N, (i//N-1)%N, (i//N+1)%N]:
      if J[0,i%N,k] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N+1)%2 - 1)) % N
    total_spin += h[site_nbr2][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012513888888888891}
#island_id: 2
#version_generated: 2
#generate time20:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = sum([h[k%N][k%N] if k % N == i else 0 for k in site_nbrs])
      spin_count = [sum(1 for k in site_nbrs if h[k%N][k%N] > 0), 
             sum(1 for k in site_nbrs if h[k%N][k%N] < 0)]
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin + spin_count[1]
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += total_spin - spin_count[0]
        priorities[i*N+j][1] -= spin_count[0]-1

  return(priorities)




#score: {'data2D.txt': 0.09036033950617292}
#island_id: 3
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[:,i//N,i//N]), -total_spin - sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin - sum(J[:,i//N,i//N]), total_spin + sum(J[:,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin + magnetism, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + magnetism]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.00887638888888889}
#island_id: 2
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if total_spin > 0:
      priorities[i][0] += J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      priorities[i][1] += 1
      
  return(priorities)




#score: {'data2D.txt': -0.000513425925925926}
#island_id: 2
#version_generated: 2
#generate time20:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      
      priorities[i][0] += total_spin
      priorities[i][1] -= 1 * (total_spin > 0)
    else:
      total_spin = -J[i%N*N:(i%N+1)*N].sum(axis=1).sum()
      
      priorities[i][0] -= total_spin
      priorities[i][1] += 1 * (total_spin < 0)
  
  return(priorities)




#score: {'data2D.txt': 0.0002125000000000006}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 1
      priority_total = [2, -2]
    else:
      total_spin = -1
      priority_total = [-2, 2]
    
    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        if h[neighbor][i%N] > 0:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
        else:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
      else:
        if h[neighbor][i%N] > 0:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
        else:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
    
    priorities[i][0] = total_spin + np.prod(J[:,i//N,i//N])
    priorities[i][1] = -total_spin + np.prod(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.147665277777778}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.07994583333333335}
#island_id: 0
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [j for j in range(4) if J[j,i//N,i%N] != 0]
    for k in neighbors:
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.prod([J[k,i//N,i%N] for k in neighbors]), -total_spin + np.prod([1-J[k,i//N,i%N] for k in neighbors])]
    else:
      priorities[i] = [-total_spin + np.prod([J[k,i//N,i%N] for k in neighbors]), total_spin + np.prod([1-J[k,i//N,i%N] for k in neighbors])]
  
  return(priorities)




#score: {'data2D.txt': 0.1044908950617285}
#island_id: 3
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] += [bias, -bias]
    else:
      priorities[i] -= [bias, -bias]
    
    # Add a term that favors spins in the same direction as the neighbor
    for k in range(4):
      if J[k,i%N,i//N] > 0 and (k % 2 == 1 or i // N == site_nbr):
        priorities[i][np.sign(total_spin) > 0] += 1
      elif J[k,i%N,i//N] < 0 and (k % 2 == 0 or i // N == site_nbr):
        priorities[i][np.sign(total_spin) < 0] -= 1
  return(priorities)




#score: {'data2D.txt': 0.1044908950617285}
#island_id: 3
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate the priority based on the magnetism and interaction strength
    priority = np.sign(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] += [bias, -bias]
    else:
      priorities[i] -= [bias, -bias]
    
    # Calculate the priority based on the interaction strength
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priority += 1
      else:
        priority -= 1
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    # Add magnetism term
    total_spin += h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.096709413580247}
#island_id: 3
#version_generated: 2
#generate time20:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] += [bias, -bias]
    else:
      priorities[i] -= [bias, -bias]
    
    # Prioritize spins with higher total energy (more interactions in the same direction as the magnetism)
    spin_energy = np.sum(np.abs(J[:, i%N, i//N]))
    if h[site_nbr][i%N] > 0:
      priorities[i] += [spin_energy, -spin_energy]
    else:
      priorities[i] -= [spin_energy, -spin_energy]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    elif total_spin < 0:
      priorities[i] = [-total_spin, total_spin]
    else:
      priorities[i] = [1, -1]
  
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0033665123456790126}
#island_id: 1
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011393518518518515}
#island_id: 1
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the total spin based on nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on magnetism and nearest neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      total_spin += sum(spin_count)
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin
        priorities[i*N+j][1] = total_spin+2
      else:
        priorities[i*N+j][0] = total_spin
        priorities[i*N+j][1] = -total_spin-2
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add bias term to prioritize spins in same direction as magnetism
    bias = np.sign(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  return(priorities)




#score: {'data2D.txt': -0.2574865740740738}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate the priority based on the magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(np.abs(J[:, i%N, i//N])), -total_spin - np.sum(np.abs(J[:, i%N, i//N]))]
    else:
      priorities[i] = [-total_spin - np.sum(np.abs(J[:, i%N, i//N])), total_spin + np.sum(np.abs(J[:, i%N, i//N]))]
  
  return(priorities)




#score: {'data2D.txt': 0.096709413580247}
#island_id: 3
#version_generated: 2
#generate time20:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] += [bias, -bias]
    else:
      priorities[i] -= [bias, -bias]
    
    # Prioritize spins with higher total energy (more interactions in the same direction as the magnetism)
    spin_energy = np.sum(np.abs(J[:, i%N, i//N]))
    if h[site_nbr][i%N] > 0:
      priorities[i] += [spin_energy, -spin_energy]
    else:
      priorities[i] -= [spin_energy, -spin_energy]
    
  return(priorities)




#score: {'data2D.txt': -0.3431964506172828}
#island_id: 3
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k, i%N, i//N]
      else:
        total_spin -= J[k, i%N, i//N]
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + h[i//N][i%N])
      priorities[i][1] = -(total_spin + h[i//N][i%N])
    else:
      priorities[i][0] = -(total_spin - h[i//N][i%N])
      priorities[i][1] = total_spin - h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': -0.002738425925925926}
#island_id: 3
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * (h[i//N][i%N] - J[3, i%N, i//N])
      priorities[i][1] = -(total_spin * (h[i//N][i%N] - J[3, i%N, i//N]))
    else:
      priorities[i][0] = -(total_spin * (h[i//N][i%N] + J[3, i%N, i//N]))
      priorities[i][1] = total_spin * (h[i//N][i%N] + J[3, i%N, i//N])
  return(priorities)




#score: {'data2D.txt': -0.007382253086419753}
#island_id: 3
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    spin_bias = h[i//N][i%N]
    interaction_term = 0
    for k in range(4):
      interaction_term += J[k, i%N, i//N]
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin * (spin_bias - interaction_term)
      priorities[i][1] = -(total_spin * (spin_bias - interaction_term))
    else:
      priorities[i][0] = -(total_spin * (spin_bias + interaction_term))
      priorities[i][1] = total_spin * (spin_bias + interaction_term)
  return(priorities)




#score: {'data2D.txt': -0.1126587962962964}
#island_id: 3
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + 2) * (h[i//N][i%N] - J[3, i%N, i//N])
      priorities[i][1] = -(total_spin + 2) * (h[i//N][i%N] - J[3, i%N, i//N])
    else:
      priorities[i][0] = -(total_spin - 2) * (h[i//N][i%N] + J[3, i%N, i//N])
      priorities[i][1] = total_spin - 2 * (h[i//N][i%N] + J[3, i%N, i//N])
  return(priorities)




#score: {'data2D.txt': 0.0018714506172839524}
#island_id: 0
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      total_spin += J[k,i%N,l]
      
    # Normalize by the number of neighbors
    total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11319830246913594}
#island_id: 1
#version_generated: 2
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = (i % N + ((i//N)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + h[site_nbr][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + h[site_nbr][i%N]]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.11373966049382726}
#island_id: 3
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + 2) * (h[i//N][i%N] - J[3, i%N, i//N])
      priorities[i][1] = -(total_spin + 2) * (h[i//N][i%N] - J[3, i%N, i//N])
    else:
      priorities[i][0] = -(total_spin - 2) * (h[i//N][i%N] + J[3, i%N, i//N])
      priorities[i][1] = total_spin - 2 * (h[i//N][i%N] + J[3, i%N, i//N])
    if site_nbr == i:
      priorities[i][0] += h[i//N][i%N]
      priorities[i][1] -= h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': -0.10946929012345688}
#island_id: 3
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    site_magnetism = h[i//N][i%N]
    priorities[i][0] = (total_spin + site_magnetism) * abs(site_magnetism - J[3, i%N, i//N])
    priorities[i][1] = -(total_spin + site_magnetism) * abs(site_magnetism + J[3, i%N, i//N])
  return(priorities)




#score: {'data2D.txt': 0.059360956790123466}
#island_id: 3
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + np.sum(J[:, i//N, i%N])) * (h[i//N][i%N])
      priorities[i][1] = -(total_spin + np.sum(J[:, i//N, i%N])) * (h[i//N][i%N])
    else:
      priorities[i][0] = -(total_spin - np.sum(J[:, i//N, i%N])) * (h[i//N][i%N])
      priorities[i][1] = total_spin - np.sum(J[:, i//N, i%N]) * (h[i//N][i%N])
  return(priorities)




#score: {'data2D.txt': -0.1126587962962964}
#island_id: 3
#version_generated: 2
#generate time20:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i][0] = (total_spin + 2) * (magnetism - J[3, i%N, i//N])
      priorities[i][1] = -(total_spin + 2) * (magnetism - J[3, i%N, i//N])
    else:
      priorities[i][0] = -(total_spin - 2) * (magnetism + J[3, i%N, i//N])
      priorities[i][1] = total_spin - 2 * (magnetism + J[3, i%N, i//N])
  return(priorities)




#score: {'data2D.txt': 0.08132731481481488}
#island_id: 0
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = np.sum([h[site][i%N] if J[k,i//N,i%N] > 0 else -h[site][i%N] for k, site in zip(range(4), site_nbrs)])

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.000756944444444444}
#island_id: 1
#version_generated: 2
#generate time20:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 1
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[i//N][j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      if J[3,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': -0.3420791666666656}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      total_spin += sum(spin_count)
      priorities[i*N+j][0] = total_spin * (2*h[i][j])
      priorities[i*N+j][1] = -total_spin * (2*h[i][j])
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= sum(spin_count)
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += sum(spin_count)
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      total_spin += sum(spin_count)
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += total_spin
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      site_nbr_sum = sum(spin_count)
      if h[i][j] > 0:
        priorities[i*N+j][0] -= site_nbr_sum
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += site_nbr_sum
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.2455211419753085}
#island_id: 2
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = sum(h[site_nbr][j] for site_nbr in site_nbrs)
      spin_count = [0, 0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      if h[i][j] > 0:
        priorities[i*N+j][0] -= total_spin - spin_count[1]
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += total_spin + spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.1473341049382717}
#island_id: 2
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = 0
      spin_count = [0,0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      site_nbr_sum = sum(spin_count)
      total_spin = np.sum(h[site_nbrs, j])
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (total_spin - site_nbr_sum) + 2*spin_count[1]
        priorities[i*N+j][1] += spin_count[1]+1
      else:
        priorities[i*N+j][0] += (total_spin + site_nbr_sum) - 2*spin_count[0]
        priorities[i*N+j][1] -= spin_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.004814351851851852}
#island_id: 2
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = sum([h[k][j] for k in site_nbrs])
      site_nbr_count = [0, 0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          site_nbr_count[1] += 1
        else:
          site_nbr_count[0] += 1
      magnetism = h[i][j]
      if magnetism > 0:
        priorities[i*N+j][0] -= total_spin + sum(site_nbr_count)
        priorities[i*N+j][1] += site_nbr_count[1]+1
      else:
        priorities[i*N+j][0] += total_spin - sum(site_nbr_count)
        priorities[i*N+j][1] -= site_nbr_count[0]-1
  return(priorities)




#score: {'data2D.txt': 0.08132731481481488}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
            2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.055281944444444474}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.23596496913580245}
#island_id: 0
#version_generated: 2
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[k,i//N,i//N] > 0 else -1 for k in range(4)]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': -0.3431871913580236}
#island_id: 2
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      total_spin = np.sum(h[site_nbrs, j])
      spin_count = [0, 0]
      for k in site_nbrs:
        if h[k%N][k%N] > 0:
          spin_count[1] += 1
        else:
          spin_count[0] += 1
      total_spin -= np.sum(spin_count)
      if h[i][j] > 0:
        priorities[i*N+j][0] = -total_spin + 2*spin_count[1]
        priorities[i*N+j][1] = spin_count[1]
      else:
        priorities[i*N+j][0] = total_spin - 2*spin_count[0]
        priorities[i*N+j][1] = spin_count[0]
  return(priorities)




#score: {'data2D.txt': 0.033689660493827156}
#island_id: 2
#version_generated: 2
#generate time20:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N):
    for j in range(N):
      site_nbrs = [(i-1)%N, (i+1)%N, ((j-1)%N+j)%N, ((j+1)%N+j)%N]
      site_nbr_hamiltonian = np.sum([h[site_nbr][j] if k%2 == 0 else -h[site_nbr][j] for k, site_nbr in enumerate(site_nbrs)])
      if h[i][j] > 0:
        priorities[i*N+j][0] -= (site_nbr_hamiltonian + np.sum([1 if h[k][j] > 0 else -1 for k in range(N)])) + 2*(np.sum([1 if h[site_nbr][j] > 0 else 0 for site_nbr in site_nbrs]) % 2)
        priorities[i*N+j][1] += (np.sum([1 if h[k][j] > 0 else -1 for k in range(N)])) % 2
      else:
        priorities[i*N+j][0] += (site_nbr_hamiltonian - np.sum([1 if h[k][j] > 0 else -1 for k in range(N)])) - 2*(np.sum([1 if h[site_nbr][j] > 0 else 0 for site_nbr in site_nbrs]) % 2)
        priorities[i*N+j][1] -= (np.sum([1 if h[k][j] > 0 else -1 for k in range(N)])) % 2
  return(priorities)




#score: {'data2D.txt': 0.001407253086419753}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += h[site_nbr][i%N] * J[k,i//N,i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.0002140432098765432}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16658040123456816}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]

  return(priorities)




#score: {'data2D.txt': 0.16432114197530887}
#island_id: 1
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.00785354938271605}
#island_id: 0
#version_generated: 2
#generate time20:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i//N,i//N]
      else:
        total_spin -= J[k,i//N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1324677469135804}
#island_id: 0
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16313719135802496}
#island_id: 0
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[0::2,i//N,i//N]), -total_spin + np.sum(J[1::2,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[0::2,i//N,i//N]), total_spin + np.sum(J[1::2,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.22308996913580237}
#island_id: 0
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005258487654320987}
#island_id: 0
#version_generated: 2
#generate time20:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[i][0] += h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      total_spin[i][0] += 1
      total_spin[i][1] -= 1
    else:
      total_spin[i][0] -= 1
      total_spin[i][1] += 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[i][0] += 1
      else:
        total_spin[i][0] -= 1
    
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin[i][0] += 1
        else:
          total_spin[i][0] -= 1
    
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin[i][0] += 1
        else:
          total_spin[i][0] -= 1
    
    priorities[i] = [total_spin[i][0], -total_spin[i][1]]
  
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    total_spin = sum(h[site_nbr][i%N] if J[k,i//N,i%N] > 0 else -h[site_nbr][i%N] for k, site_nbr in enumerate(site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0005270061728395061}
#island_id: 1
#version_generated: 2
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priority_spin = 1
    else:
      priority_spin = -1
      
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priority_spin += h[site_nbr][i%N]
      else:
        priority_spin -= h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_spin += h[site_nbr][j]
      else:
        priority_spin -= h[site_nbr][j]
    
    priorities[i][0] = priority_spin
    priorities[i][1] = -priority_spin
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.22132824074074067}
#island_id: 0
#version_generated: 2
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0007510802469135802}
#island_id: 0
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.20010570987654347}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    total_magnetism = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      if h[i//N][i%N] > 0 and J[k,i%N,i//N] > 0:
        total_magnetism += J[k,i%N,i//N]
      elif h[i//N][i%N] < 0 and J[k,i%N,i//N] > 0:
        total_magnetism -= J[k,i%N,i//N]
    if total_magnetism > 0:
      priorities[i] = [total_spin, -total_spin + total_magnetism]
    else:
      priorities[i] = [-total_spin - total_magnetism, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.10759336419753099}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + (h[site_nbr][i%N]/J[3,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + (h[site_nbr][i%N]/J[3,i//N,i//N])]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time20:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Calculate total spin based on interactions and magnetism
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on total spin
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on total spin
    priorities[i][np.sign(total_spin) > 0] = [total_spin, -total_spin]
    priorities[i][np.sign(total_spin) < 0] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1020668209876544}
#island_id: 3
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Prioritize spins in the same direction as the magnetism and neighbor interactions
    bias = np.sign(total_spin)
    for k in range(4):
      if J[k,i%N,i//N] > 0 and (k % 2 == 1 or i // N == site_nbr):
        total_spin += 1
      elif J[k,i%N,i//N] < 0 and (k % 2 == 0 or i // N == site_nbr):
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] += bias
      priorities[i][1] -= bias
    else:
      priorities[i][0] -= bias
      priorities[i][1] += bias
    
    # Add a term that favors spins in the same direction as the neighbor
    for k in range(4):
      if J[k,i%N,i//N] > 0 and (k % 2 == 1 or i // N == site_nbr):
        priorities[i][np.sign(total_spin) > 0] += 1
      elif J[k,i%N,i//N] < 0 and (k % 2 == 0 or i // N == site_nbr):
        priorities[i][np.sign(total_spin) < 0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.003102623456790124}
#island_id: 3
#version_generated: 2
#generate time20:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add a bias term to prioritize spins in the same direction as the magnetism
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  return(priorities)




#score: {'data2D.txt': 0.19763256172839513}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19763256172839513}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and adjust for magnetism
    total_spin /= (4 + int(i//N > 0))
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.00038996913580246844}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Add magnetism at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [np.sum(J[:,i%N,i//N]), -np.sum(J[:,i%N,i//N])]
    else:
      priorities[i] = [-np.sum(J[:,i%N,i//N]), np.sum(J[:,i%N,i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.19763256172839513}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.10723626543209888}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  # Add an additional term based on the average magnetism
  avg_magnetism = h.flatten().mean()
  for i in range(N**2):
    if avg_magnetism > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.147665277777778}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.08765046296296304}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      for k in range(4):
        priorities[i][0] += J[k,i//N,i//N]
        priorities[i][1] -= J[k,i//N,i//N]
    else:
      for k in range(4):
        priorities[i][0] -= J[k,i//N,i//N]
        priorities[i][1] += J[k,i//N,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 0
#version_generated: 2
#generate time20:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin + np.sum(J[:,i//N,i//N])]
    else:
      priorities[i] = [-total_spin + np.sum(J[:,i//N,i//N]), total_spin + np.sum(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.16624027777777803}
#island_id: 1
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin *= np.sign(h[i//N][i%N])
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    if magnetism > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.1155498456790125}
#island_id: 1
#version_generated: 2
#generate time20:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0015949074074074084}
#island_id: 3
#version_generated: 2
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority by combining the bias term with the total spin
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + 2, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 2]
  
  return(priorities)




#score: {'data2D.txt': -0.0015297839506172833}
#island_id: 3
#version_generated: 2
#generate time20:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  # Sort the priorities based on the absolute value of the spin
  sorted_priorities = np.argsort(np.abs(priorities).sum(axis=1))[::-1]
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.0017643518518518522}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] += J[3,i%N,j]
        priorities[i][1] -= J[3,i%N,j]
      else:
        priorities[i][0] -= J[3,i%N,j]
        priorities[i][1] += J[3,i%N,j]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.1651146604938274}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i//N)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    site_nbr_right = (i % N + ((i//N+1)%2 - 1)) % N
    if J[3,i%N,(i//N+1)%N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  return priorities




#score: {'data2D.txt': 0.16615540123456812}
#island_id: 1
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_row = (i % N + ((i//N)%2 - 1)) % N
    site_nbr_col = (i // N) % N
    if J[3,i%N,i//N] > 0:
      total_spin += h[site_nbr_row][i%N]
      total_spin -= h[site_nbr_col,i//N]
    else:
      total_spin -= h[site_nbr_row][i%N]
      total_spin += h[site_nbr_col,i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    # Calculate priority for each spin state
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0013282407407407405}
#island_id: 2
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    site_nbrs = [(i-1)%N if i%N != 0 else N-1, ((i+N-1)%N) if i%N == N-1 else (i+1)%N]
    for j in range(2):
      total_spin += h[site_nbr][j]
      if h[i//N][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22132824074074067}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.056486882716049416}
#island_id: 0
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    # Add neighbor interactions
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
       total_spin -= 1
     else:
       total_spin += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
     j = i//N - 1
     if J[2, i%N, i%N] > 0:
      total_spin -= 1
     else:
      total_spin += 1
     
     l = i%N
     if J[3, i%N, i%N] > 0:
      total_spin -= 1
     else:
      total_spin += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
     j = i//N - 1
     l = (i%N + 1) % N
     if J[3, i%N, l] > 0:
      total_spin -= 1
     else:
      total_spin += 1
     
     j = i//N - 1
     l = (i%N - 1) % N
     if J[2, i%N, l] > 0:
      total_spin -= 1
     else:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0012581790123456788}
#island_id: 1
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1865640432098768}
#island_id: 1
#version_generated: 2
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add the interactions with nearest neighbors
    if J[0,i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,(i-1)%N//N+i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,(i+1)%N//N+i//N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i//N,(i-1)%N] > 0:
      total_spin += 1
    elif i % N == 0:
      total_spin += 1
    elif i % N == N-1:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if J[3,i//N,(i+1)%N] > 0:
      total_spin += 1
    elif i % N == 0:
      total_spin += 1
    elif i % N == N-1:
      total_spin -= 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.003549228395061729}
#island_id: 1
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
 
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr_even = (i // N) % 2
    for j in range(N):
      site_nbr = (j + ((site_nbr_even - 1)*N)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16610015432098788}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add additional term based on magnetism at the site
    total_spin += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N**2)]
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0.0, 1.0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14490015432098788}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.29864706790123396}
#island_id: 2
#version_generated: 2
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
        
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.1314251543209878}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.1324677469135804}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1324677469135804}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': -0.008383487654320992}
#island_id: 0
#version_generated: 2
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    total_spin = np.sum(J[:,i//N,i//N])
    
    # Normalize by the number of neighbors
    total_spin /= 4
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.prod(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.prod(J[:,i//N,i//N])]
    
  return(priorities)




#score: {'data2D.txt': 0.001407253086419753}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i%N] * h[site_nbr][i%N]
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  return priorities




#score: {'data2D.txt': -0.0015297839506172833}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  # Sort the priorities based on the absolute value of the spin
  sorted_priorities = np.argsort(np.abs(priorities).sum(axis=1))[::-1]
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.002350154320987654}
#island_id: 3
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
    
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.009456018518518518}
#island_id: 0
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
      
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = priorities[site_nbr][0]
    if h[site_nbr][i%N] > 0:
      total_spin += 1
      priorities[i][0] += total_spin
      priorities[i][1] -= total_spin
    else:
      total_spin -= 1
      priorities[i][0] -= total_spin
      priorities[i][1] += total_spin
      
  return(priorities)




#score: {'data2D.txt': -0.004388734567901235}
#island_id: 0
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.15871496913580274}
#island_id: 2
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add the site interaction to the priority
    if total_spin > 0:
      priorities[i][1] += abs(h[i//N][i%N])
    elif total_spin < 0:
      priorities[i][0] += abs(h[i//N][i%N])
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 2
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Correct the priority to account for the site interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0061054012345679014}
#island_id: 2
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add more advanced logic based on magnetism and interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.16166496913580272}
#island_id: 1
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16618256172839535}
#island_id: 1
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%N-1)%N) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr_left][i%N]
      priorities[i][1] -= h[site_nbr_left][i%N]
    else:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    if J[1,i//N,i//N] > 0:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    else:
      priorities[i][0] -= h[site_nbr_right][i%N]
      priorities[i][1] += h[site_nbr_right][i%N]
  return(priorities)




#score: {'data2D.txt': 0.06462083333333338}
#island_id: 0
#version_generated: 2
#generate time20:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Add a correction term based on the number of neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add a correction term based on the number of neighbors with same spin
    same_spin_neighbors = np.sum(neighbors == 1)
    if same_spin_neighbors > 0:
      priorities[i][0] += same_spin_neighbors
      priorities[i][1] -= same_spin_neighbors
    
  return(priorities)




#score: {'data2D.txt': 0.11894799382716062}
#island_id: 0
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': -0.0014729938271604937}
#island_id: 2
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    site_nbrs = [(i-1)%N if i%N != 0 else N-1, ((i+N-1)%N) if i%N == N-1 else (i+1)%N]
    for j in range(2):
      total_spin += h[i//N][j]
      if h[i//N][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
    
    # Prioritize based on site magnetism and neighbor interactions
    for k in range(2):
      if total_spin > 0:
        priorities[i][k] = -1
      elif total_spin < 0:
        priorities[i][k] = 1
      else:
        priorities[i][k] = -np.random.choice([-1, 1])
  
  return(priorities)




#score: {'data2D.txt': -0.0013282407407407405}
#island_id: 2
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    site_nbrs = [(i-1)%N if i%N != 0 else N-1, ((i+N-1)%N) if i%N == N-1 else (i+1)%N]
    for j in range(2):
      total_spin += h[site_nbr][j]
      if h[i//N][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
    
    # Add interactions with diagonally neighboring sites
    for k in range(2):
      site_nbr = (i - N + k) % N**2
      if J[k,i//N,i//N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
  return(priorities)




#score: {'data2D.txt': -0.0013282407407407405}
#island_id: 2
#version_generated: 2
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:,i//N,i//N].sum() + 2)
    
    site_nbrs = [(i-1)%N if i%N != 0 else N-1, ((i+N-1)%N) if i%N == N-1 else (i+1)%N]
    for j in range(2):
      total_spin += h[site_nbr][j]
      if h[i//N][j] > 0:
        priorities[i][j] -= 1
      else:
        priorities[i][j] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.03992916666666667}
#island_id: 0
#version_generated: 2
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    for j in range(4):
      if J[j,i//N,i//N] > 0:
        priorities[i][0] += J[j,site_nbr,i//N]
        priorities[i][1] -= J[j,site_nbr,i//N]
      else:
        priorities[i][0] -= J[j,site_nbr,i//N]
        priorities[i][1] += J[j,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.08565787037037043}
#island_id: 0
#version_generated: 2
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    site_nbrs = [site_nbr]
    for j in range(4):
      if i//N % N != (i//N+N)%N and J[j,i//N,i//N] > 0:
        site_nbrs.append((i//N+N)%N)
      elif i%N != (i+N)%N and J[3*i%4+(j-1)//2,i//N,i//N] > 0:
        site_nbrs.append((i+N)%N)
    
    for site in site_nbrs:
      if h[site][i%N] > 0:
        priorities[i][0] += J[0,site,i//N]
        priorities[i][1] -= J[1,site,i//N]
      else:
        priorities[i][0] -= J[2,site,i//N]
        priorities[i][1] += J[3,site,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.059531944444444464}
#island_id: 0
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Add a correction term based on the number of neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  # Calculate priority based on the number of neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.002350154320987654}
#island_id: 3
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
    
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.00017114197530864183}
#island_id: 3
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs) + h[i//N][i%N]
    
    # Add neighbor interactions and magnetism
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    elif J[1,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    elif J[2,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.001091820987654321}
#island_id: 3
#version_generated: 2
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site-specific magnetism-bias term
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin considering interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Prioritize spins based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.0004316358024691357}
#island_id: 3
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site-specific magnetism-bias term
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.0013674382716049385}
#island_id: 3
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  # Calculate site-specific magnetism-bias term
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))

  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_indices = np.argsort((np.abs(priorities).sum(axis=1)).flatten())
  return priorities[sorted_indices].copy()




#score: {'data2D.txt': 0.0008337962962962961}
#island_id: 3
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site-specific magnetism-bias term
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.0008288580246913584}
#island_id: 3
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate site-specific magnetism-bias term
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = -total_spin - 2 * np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + 2 * np.sum(np.sign(J[:,i%N,i//N]))
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priorities based on energy and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.014959104938271616}
#island_id: 0
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Calculate priority based on the magnetization of the site's neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum([J[0,i//N,j] for j in range(N) if i != j]) 
      priorities[i][1] -= sum([J[1,i//N,j] for j in range(N) if i != j]) 
    else:
      priorities[i][0] -= sum([J[2,i//N,j] for j in range(N) if i != j]) 
      priorities[i][1] += sum([J[3,i//N,j] for j in range(N) if i != j]) 
      
  return(priorities)




#score: {'data2D.txt': 0.08132731481481488}
#island_id: 0
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': -0.1716047839506175}
#island_id: 0
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [J[0,i//N,i//N] if J[0,i//N,i//N] > 0 else -1, 
           J[1,i//N,i//N] if J[1,i//N,i//N] > 0 else -1,
           J[2,i//N,i//N] if J[2,i//N,i//N] > 0 else -1, 
           J[3,i//N,i//N] if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors) * (2 if h[i//N][i%N] > 0 else 1)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.001407253086419753}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    total_bias = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i%N] * h[site_nbr][i%N]
      total_bias += J[k,i//N,i%N] * (h[site_nbr][i%N])**2
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + bias, -total_spin - bias]
    else:
      priorities[i] = [-total_spin - bias, total_spin + bias]
  
  return priorities




#score: {'data2D.txt': -0.03160632716049383}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    up_bias = 0
    down_bias = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
        up_bias -= 1
        down_bias += 1
      else:
        total_spin -= h[site_nbr][i%N]
        up_bias += 1
        down_bias -= 1
    
    # Calculate the priority based on the total spin and bias term
    priorities[i] = [total_spin + up_bias, -total_spin - down_bias]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    bias = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i%N] * h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        bias -= 1
      else:
        bias += 1
    
    # Calculate the priority based on the total spin and bias term
    priorities[i] = [total_spin + bias, -total_spin - bias]
  
  return priorities




#score: {'data2D.txt': 0.002537191358024691}
#island_id: 3
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = J[0,i//N,i%N]*h[site_nbr][i%N]
    
    for k in range(3):
      site_nbr = (i % N + ((k)%2 - 1)) % N
      total_spin += J[k+1,i//N,i%N]*h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return priorities




#score: {'data2D.txt': -0.005442746913580246}
#island_id: 0
#version_generated: 2
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Add neighbor interactions
  for i in range(N**2):
    total_spin = 0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
       total_spin += 1
      else:
       total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
       total_spin += 1
      else:
       total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
     j = i//N - 1
     l = (i%N + 1) % N
     if J[3, i%N, l] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
     j = i//N - 1
     l = (i%N - 1) % N
     if J[2, i%N, l] > 0:
       total_spin += 1
     else:
       total_spin -= 1
  
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_spin = h[site_nbr][i%N]
    
    for k in range(4):
      l = (k+1)%2
      if J[k, i%N, l] > 0:
        neighbor_spin -= 1
      else:
        neighbor_spin += 1
    
    if neighbor_spin > 0:
      priorities[i] = [neighbor_spin, -neighbor_spin]
    else:
      priorities[i] = [-neighbor_spin, neighbor_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16506095679012367}
#island_id: 1
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[3,i%N,i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.03798040123456794}
#island_id: 1
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate total spin based on J tensor
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate priority based on magnetism and interaction
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(N)]
    if h[i//N][i%N] > 0:
      priorities[i][0] += sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
      priorities[i][1] -= sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    else:
      priorities[i][0] -= sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
      priorities[i][1] += sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
  
  return(priorities)




#score: {'data2D.txt': 0.11533317901234581}
#island_id: 1
#version_generated: 2
#generate time20:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.0008526234567901242}
#island_id: 1
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if h[site_nbr][j] > 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
        priorities[i][1] += 1
      else:
        priorities[i][0] += 1
        priorities[i][1] -= 1
    
    if total_spin > 0:
      priorities[i][0] -= 2
      priorities[i][1] += 2
    elif total_spin < 0:
      priorities[i][0] += 2
      priorities[i][1] -= 2
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
  return(priorities)




#score: {'data2D.txt': 0.00017114197530864183}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs) + h[i//N][i%N]
    
    # Add neighbor interactions and magnetism
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    elif J[1,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    elif J[2,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
    
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.00017114197530864183}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs) + h[i//N][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    elif J[1,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    elif J[2,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.0007896604938271607}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs) + h[i//N][i%N]
    
    # Add neighbor interactions and magnetism
    interaction_sum = 0
    for j in range(4):
      interaction_sum += J[j,i%N,i//N]
    if interaction_sum > 0:
      total_spin += 1
    elif interaction_sum < 0:
      total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': 0.00017114197530864183}
#island_id: 3
#version_generated: 2
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs) + h[i//N][i%N]
    
    # Add neighbor interactions and magnetism
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    elif J[1,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    elif J[2,i%N,i//N] < 0:
      total_spin -= 1
    
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    bias = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin + bias
      priorities[i][1] = -total_spin - bias
    else:
      priorities[i][0] = -total_spin - bias
      priorities[i][1] = total_spin + bias
    
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.005408179012345679}
#island_id: 0
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001054475308641975}
#island_id: 0
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
      for k in range(4):
        j, l = i//N + ((k-2)%2 - 1), (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin -= 1
        else:
          total_spin += 1
      
      priorities[i][0] = total_spin
      priorities[i][1] = -total_spin
    else:
      total_spin = -3
      for k in range(4):
        j, l = i//N + ((k-2)%2 - 1), (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      priorities[i][0] = -total_spin
      priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.23033256172839497}
#island_id: 0
#version_generated: 2
#generate time20:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
      
      if J[3,i%N,j] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.03160632716049383}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    neighbor_count = 0
    
    # Calculate the total spin contribution from neighboring sites
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
        neighbor_count += 1
      else:
        total_spin -= h[site_nbr][i%N]
    
    # Calculate the priority for assigning spin up or down
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16662608024691383}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin += h[site_nbr][i%N]
    if J[3,i%N,i//N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.00042793209876543166}
#island_id: 1
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr_row][i%N] + J[0, i%N, i//N] + J[3, i%N, i//N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N
    
    if J[0, i%N, i//N] > 0:
      priorities[i][0] += h[site_nbr_row][i%N]
      priorities[i][1] -= h[site_nbr_row][i%N]
    else:
      priorities[i][0] -= h[site_nbr_row][i%N]
      priorities[i][1] += h[site_nbr_row][i%N]
    
  for i in range(N**2):
    site_nbr_col = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J[3, i%N, i//N] > 0:
      priorities[i][0] += h[site_nbr_col][i//N]
      priorities[i][1] -= h[site_nbr_col][i//N]
    else:
      priorities[i][0] -= h[site_nbr_col][i//N]
      priorities[i][1] += h[site_nbr_col][i//N]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= (3 + np.abs(total_spin))
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = max(0, total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -max(0, total_spin)
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.1667081790123458}
#island_id: 0
#version_generated: 2
#generate time20:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= np.sum(np.abs(J[:,i//N,i%N])) + np.abs(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.000629783950617284}
#island_id: 0
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and magnetism at neighbor sites
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += np.sign(h[site_nbr][j])
      else:
        total_spin -= np.sign(h[site_nbr][j])
    
    # Normalize by the number of neighbors and add a bias term
    total_spin /= 3 + np.abs(total_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005215586419753088}
#island_id: 1
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.012409722222222223}
#island_id: 1
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0,0] for _ in range(N*N)]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
      
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.00216712962962963}
#island_id: 1
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N] * h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.028901388888888897}
#island_id: 1
#version_generated: 2
#generate time20:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = np.sum(J[:,i//N,i//N]) * (2*h[i//N][i%N]-1)
    
    priorities[i] = [total_spin + magnetism, -total_spin - magnetism]
  
  return(priorities)




#score: {'data2D.txt': -0.07574583333333337}
#island_id: 2
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,i%N,i//N]
      else:
        total_spin -= J[k,i%N,i//N]
        
    # Normalize by the number of neighbors
    total_spin /= np.sum(J[:,i%N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 9.92283950617282e-05}
#island_id: 0
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = np.sum(h[site_nbr][(i%N)//N])
    
    if h[site_nbr][i%N] > 0:
      priority_total = [total_spin+np.prod(J[:,(i%N)//N,(i//N)%N]), -total_spin+np.prod(J[:,(i%N)//N,(i//N)%N])]
    else:
      priority_total = [-total_spin+np.prod(J[:,(i%N)//N,(i//N)%N]), total_spin+np.prod(J[:,(i%N)//N,(i//N)%N])]
    
    priorities[i][0] = priority_total[0]
    priorities[i][1] = priority_total[1]
  
  return(priorities)




#score: {'data2D.txt': -0.004682561728395062}
#island_id: 0
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
      
    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      
      if J[k,i//N,i//N] > 0:
        if h[neighbor][i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      else:
        if h[neighbor][i%N] > 0:
          total_spin -= 1
        else:
          total_spin += 1
          
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.0002125000000000006}
#island_id: 0
#version_generated: 2
#generate time20:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = 1
      priority_total = [2, -2]
    else:
      total_spin = -1
      priority_total = [-2, 2]
    
    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        if h[neighbor][i%N] > 0:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
        else:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
      else:
        if h[neighbor][i%N] > 0:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
        else:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
    
    priorities[i][0] = total_spin + np.prod(J[:,i//N,i//N])
    priorities[i][1] = -total_spin + np.prod(J[:,i//N,i//N])
    
  return(priorities)




#score: {'data2D.txt': 0.0011609567901234566}
#island_id: 0
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 1
      priority_total = [2, -2]
    else:
      total_spin = -1
      priority_total = [-2, 2]
    
    for k in range(4):
      neighbor = (site_nbr + ((k-1)%2 - 1)) % N
      
      if J[k,i%N,i//N] > 0:
        if h[neighbor][i%N] > 0:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
        else:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
      else:
        if h[neighbor][i%N] > 0:
          total_spin -= 1
          priority_total[0] -= 1
          priority_total[1] += 1
        else:
          total_spin += 1
          priority_total[0] += 1
          priority_total[1] -= 1
    
    site_nbrs = [(site_nbr + ((k-1)%2 - 1)) % N for k in range(4)]
    
    same = [1 if J[k,i%N,i//N]*h[site_nbrs[k]][i%N]>0 else -1 for k in range(4)]
    different = [1 if (J[k,i%N,i//N]-2)*h[site_nbrs[k]][i%N]>0 else 1 for k in range(4)]
    
    total_spin += np.sum(same)
    priority_total[0] += np.sum(same)
    priority_total[1] -= np.sum(different)
    
    priorities[i][0] = total_spin + np.prod(J[:,i//N,i//N])
    priorities[i][1] = -total_spin + np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Sum the interactions with neighbors and add them to the priority
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.0015646604938271609}
#island_id: 1
#version_generated: 2
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    elif J[0,i%N,i//N] < 0:
      total_spin -= 1
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    elif J[1,i%N,i//N] < 0:
      total_spin -= 1
    if J[2,i%N,i//N] > 0:
      total_spin += 1
    elif J[2,i%N,i//N] < 0:
      total_spin -= 1
    if J[3,i%N,i//N] > 0:
      total_spin += 1
    elif J[3,i%N,i//N] < 0:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.0004316358024691357}
#island_id: 3
#version_generated: 2
#generate time20:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate the priority based on the total spin and bias term
    if h[site_nbr][i%N] > 0:
      priorities[i][0] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
    else:
      priorities[i][0] = total_spin + np.sum(np.sign(J[:,i%N,i//N]))
      priorities[i][1] = -total_spin - np.sum(np.sign(J[:,i%N,i//N]))
  
  # Sort the priorities based on the absolute value of the spin and then by the priority itself
  sorted_priorities = np.array(np.unravel_index(np.argsort((np.abs(priorities).sum(axis=1)).flatten()), (N,N)))[0].T.flatten()
  
  # Return the sorted priorities with the same order as the original priorities
  return priorities[sorted_priorities].copy()




#score: {'data2D.txt': -0.3424467592592582}
#island_id: 0
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0011035493827160497}
#island_id: 0
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = np.sum(h[site_nbr]) + np.sum(J[:,i//N,i%N])
    
    # Normalize by the number of neighbors
    total_spin /= (4 * (h == h[i//N]).sum() + (abs(h - h[i//N]).sum()))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19888163580246918}
#island_id: 0
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19708441358024698}
#island_id: 0
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Calculate the interaction with all nearest neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.0013794753086419757}
#island_id: 1
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.009273611111111118}
#island_id: 0
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:, i//N, i//N])
      priorities[i][1] -= np.prod(J[:, i//N, i//N])
    else:
      priorities[i][0] -= np.prod(J[:, i//N, i//N])
      priorities[i][1] += np.prod(J[:, i//N, i//N])
    
    # Calculate additional priority based on the sum of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] -= total_spin - J[3, i//N, i//N]
      priorities[i][1] += total_spin + J[2, i//N, i//N]
    else:
      priorities[i][0] += total_spin - J[2, i//N, i//N]
      priorities[i][1] -= total_spin + J[3, i//N, i//N]
  
  # Add an additional term based on the average magnetism
  avg_magnetism = h.flatten().mean()
  for i in range(N**2):
    if avg_magnetism > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.08376126543209884}
#island_id: 0
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate total spin for each site based on magnetism and interaction with neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Initialize total spin and priority
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Calculate additional priority based on spin correlations
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Initialize correlation and priority
    correlation = 0
    if h[i//N][i%N] > 0:
      correlation += J[0,i//N,i//N]
    else:
      correlation -= J[3,i//N,i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        correlation += J[k,i//N,i//N]
      else:
        correlation -= J[k-1,i//N,i//N]
    
    # Calculate priority based on spin correlations
    if h[i//N][i%N] > 0:
      priorities[i][0] += correlation
      priorities[i][1] -= correlation
    else:
      priorities[i][0] -= correlation
      priorities[i][1] += correlation
  
  return(priorities)




#score: {'data2D.txt': 0.02060138888888888}
#island_id: 0
#version_generated: 2
#generate time20:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
    
  # Add an additional term based on the average magnetism
  avg_magnetism = h.flatten().mean()
  for i in range(N**2):
    if avg_magnetism > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
  
  # Calculate priority based on the sum of magnetism and interaction
  for i in range(N**2):
    total_spin = h[i//N][i%N]
    if J[0,i//N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i//N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.2109483024691358}
#island_id: 0
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above (if exists)
    if i//N < N-1 and i%N > 0:
      j = i//N + 1
      l = i%N - 1
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below (if exists)
    if i//N < N-1 and i%N < N-1:
      j = i//N + 1
      l = i%N + 1
      if J[0, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (6 - int(i//N > N-2) - int(i%N > N-2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.18250725308641982}
#island_id: 0
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N < N//2:
      j = i//N + N//2 - 1
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int(i//N < N//2))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1379612654320989}
#island_id: 0
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    
    # Add magnetism at the current site
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      above, below = J[3, i%N, :2]
      total_spin += above.sum()
      total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1865779320987655}
#island_id: 0
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (3 + int(i//N > 0))
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    bias = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i%N] * h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        bias -= 1
      else:
        bias += 1
    
    # Calculate the priority based on the total spin and bias term, with some tweaks
    priorities[i] = [total_spin**2 + bias**2, -(total_spin**2 + bias**2)]
  
  return priorities




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    bias = 0
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i//N,i%N] * h[site_nbr][i%N]
      if h[i//N][i%N] > 0:
        bias -= 1
      else:
        bias += 1
    
    # Calculate the priority based on the total spin and bias term
    priorities[i] = [(total_spin + bias) / 2, -(total_spin + bias) / 2]
  
  return priorities




#score: {'data2D.txt': 0.08565787037037043}
#island_id: 0
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if h[site_nbr][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.088284413580247}
#island_id: 0
#version_generated: 2
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  # Add a correction term based on the number of neighbors
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.11884706790123471}
#island_id: 0
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = np.sum(h[i//N%N, i%N])
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.056486882716049416}
#island_id: 0
#version_generated: 2
#generate time20:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    # Add neighbor interactions
    for k in range(4):
     j, l = i//N + ((k-2)%2 - 1), (k+1)%2
     if J[k,i%N,l] > 0:
      total_spin -= 1
     else:
      total_spin += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
     j = i//N - 1
     if J[2, i%N, i%N] > 0:
      total_spin -= 1
     else:
      total_spin += 1
     
     l = i%N
     if J[3, i%N, i%N] > 0:
      total_spin -= 1
     else:
      total_spin += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
     j = i//N - 1
     l = (i%N + 1) % N
     if J[3, i%N, l] > 0:
      total_spin -= 1
     else:
      total_spin += 1
     
     j = i//N - 1
     l = (i%N - 1) % N
     if J[2, i%N, l] > 0:
      total_spin -= 1
     else:
      total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.004432561728395062}
#island_id: 0
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.056486882716049416}
#island_id: 0
#version_generated: 2
#generate time20:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    total_spin = 0
    if h[i//N][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin -= 1
      else:
        total_spin += 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': -0.008936882716049387}
#island_id: 0
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.1191896604938273}
#island_id: 0
#version_generated: 2
#generate time20:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in [0,1,3]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[[0,3],i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[[0,3],i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] -= np.prod(J[[0,1,3],i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[[0,1,3],i//N,i//N])
      priorities[i][1] += np.prod(J[[0,1,3],i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.1314251543209878}
#island_id: 0
#version_generated: 2
#generate time20:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += (np.prod(J[:,i//N,i//N]))
      priorities[i][1] -= (np.prod(J[:,i//N,i//N]))
    else:
      priorities[i][0] -= (np.prod(J[:,i//N,i//N]))
      priorities[i][1] += (np.prod(J[:,i//N,i//N]))

  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_sum = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
        neighbor_sum -= J[k,i%N,i//N]
      else:
        total_spin -= 1
        neighbor_sum += J[k,i%N,i//N]
    priorities[i] = [total_spin + neighbor_sum, -total_spin + neighbor_sum]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.11768194444444459}
#island_id: 1
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum(h[j][i%N] for j in range(N))
      priorities[i][1] = -total_spin + sum(h[j][i%N] for j in range(N))
    else:
      priorities[i][0] = -total_spin + sum(h[j][i%N] for j in range(N))
      priorities[i][1] = total_spin - sum(h[j][i%N] for j in range(N))
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 1
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.13144305555555574}
#island_id: 3
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Make spin priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+J[0,i//N,i//N], -total_spin-J[0,i//N,i//N]]
    else:
      priorities[i] = [-total_spin-J[1,i//N,i//N], total_spin+J[1,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    total_spin += neighbor_interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add J interactions from all 4 directions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Adjust based on site magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16567391975308665}
#island_id: 1
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)//2 - 1)) % N
    
    total_spin = h[site_nbr_row][i%N] + h[site_nbr_col][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.09317824074074085}
#island_id: 1
#version_generated: 2
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if J[3,i%N,i//N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.07758287037037041}
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N

    if J[0,i%N,i//N] > 0:
      h_total = h[site_nbr1][i%N]
    else:
      h_total = -h[site_nbr1][i%N]

    if J[1,i%N,i//N] > 0:
      h_total += h[site_nbr2][i%N]
    else:
      h_total -= h[site_nbr2][i%N]

    if J[2,i//N,i%N] > 0:
      h_total += h[i//N][(i+1)%N]
    else:
      h_total -= h[i//N][(i+1)%N]

    if J[3,i//N,(i+1)%N] > 0:
      h_total += h[i//N][i%N]
    else:
      h_total -= h[i//N][i%N]

    priorities[i] = [h_total, -h_total]

  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    total_spin = sum(h[site_nbr][i%N] if J[j,i//N,i%N]>0 else -h[site_nbr][i%N] for j, site_nbr in enumerate(site_nbrs))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04277947530864198}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    for k in range(4):
      if h[(i+k)%N][i%N] > 0:
        priorities[i][0] += J[k,site_nbr,i//N]
        priorities[i][1] -= J[k,site_nbr,i//N]
      else:
        priorities[i][0] -= J[k,site_nbr,i//N]
        priorities[i][1] += J[k,site_nbr,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.042401697530864195}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += J[k,site,i//N]
        priorities[i][1] -= J[k,site,i//N]
      else:
        priorities[i][0] -= J[k,site,i//N]
        priorities[i][1] += J[k,site,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.042401697530864195}
#island_id: 0
#version_generated: 2
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    for k in range(4):
      site = (i % N + ((k-1)%2 - 1)) % N
      if h[site][i%N] > 0:
        priorities[i][0] += J[k,site,i//N]
        priorities[i][1] -= J[k,site,i//N]
      else:
        priorities[i][0] -= J[k,site,i//N]
        priorities[i][1] += J[k,site,i//N]
  
  return(priorities)




#score: {'data2D.txt': 0.044778549382716054}
#island_id: 0
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    if len(neighbors) > 0:
      priorities[i][0] += np.sum(J[:,site_nbr,i//N])
      priorities[i][1] -= np.sum(J[:,site_nbr,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1413158950617286}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.1104439814814816}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -(total_spin+1)]
    else:
      priorities[i] = [-(total_spin-1), total_spin-1]
  
  return(priorities)




#score: {'data2D.txt': 0.20985941358024707}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N,N), dtype=int)
  
  # Calculate the total spin at each site based on magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[i//N][i%N] += 1
    else:
      total_spin[i//N][i%N] -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j = (k+2)%4 if i % N == 0 else ((i+1) % (N))
      if J[k,i%N,i//N] > 0:
        total_spin[i//N][i%N] += 1
      else:
        total_spin[i//N][i%N] -= 1
  
  # Normalize by the number of neighbors
  for i in range(N):
    for j in range(N):
      total_spin[i][j] /= (2 if sum(J[:,i,j]) > 0 else 1)
  
  # Assign priorities based on the total spin and magnetism at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N][i%N], -total_spin[i//N][i%N]]
    else:
      priorities[i] = [-total_spin[i//N][i%N], total_spin[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin-abs(total_spin), total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1413158950617286}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1413158950617286}
#island_id: 2
#version_generated: 2
#generate time21:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.08515138888888894}
#island_id: 2
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Check if the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and (h[site_nbr][i%N] < 0 or h[i//N][i%N] > 0):
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and (h[site_nbr][i%N] > 0 or h[i//N][i%N] < 0):
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.13382854938271624}
#island_id: 2
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # If the site has more than one neighbor aligned in the same direction, prioritize its own spin
    count_up = 0
    count_down = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        count_up += 1
      elif J[k,i%N,i//N] < 0:
        count_down += 1
    
    if count_up > count_down and h[site_nbr][i%N] < 0:
      priorities[i][0] -= 1
    elif count_down > count_up and h[site_nbr][i%N] > 0:
      priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.1152396604938273}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr_sum = 0
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        site_nbr_sum += 1
      else:
        site_nbr_sum -= 1
        
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[(i + ((j-1)%2 - 1)) % N][j]
      else:
        total_spin -= h[(i + ((j-1)%2 - 1)) % N][j]
        
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + site_nbr_sum, -(total_spin + site_nbr_sum)]
    else:
      priorities[i] = [-total_spin - site_nbr_sum, total_spin + site_nbr_sum]
      
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    if J[0,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    if J[1,i%N,i//N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(2):
     site_nbr = (i % N + ((k-1)%2 - 1)) % N
     if J[k+2,i%N,i//N] > 0:
       total_spin += 1
     else:
       total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.013960648148148149}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = np.sum(J[:,i//N,i%N]) + h[i//N][i%N]
    
    if total_spin > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16234089506172864}
#island_id: 1
#version_generated: 2
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_sum = np.sum(J[:,i//N,i//N]) * h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + priority_sum, -total_spin - priority_sum]
    else:
      priorities[i] = [-total_spin - priority_sum, total_spin + priority_sum]
  
  return(priorities)




#score: {'data2D.txt': 0.1413158950617286}
#island_id: 2
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total magnetism at the site
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.023584413580246908}
#island_id: 2
#version_generated: 2
#generate time21:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and magnetism
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + len([k for k in range(4) if J[k,i%N,i//N] < 0]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + len([k for k in range(4) if J[k,i%N,i//N] > 0])]
  
  return(priorities)




#score: {'data2D.txt': -0.341265586419752}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14671250000000013}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19755416666666673}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.199283487654321}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    j = i//N - 1
    l = i%N
    if i//N > 0:
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17975046296296304}
#island_id: 0
#version_generated: 2
#generate time21:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, k+1
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.19888163580246918}
#island_id: 0
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = (i//N + ((k-2)%2 - 1)) % N, (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and ((i % N == 0 or i % N == N - 1)):
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally below and above (if exists)
    if i//N < N - 1 and ((i % N == 0 or i % N == N - 1)):
      j = i//N + 1
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.1636180555555558}
#island_id: 2
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the total spin at each site based on magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      j = (k+2)%4 if i % N == 0 else ((i+1) % (N))
      if J[k,i%N,i//N] > 0 and h[j//N][j%N] > 0:
        total_spin += 1
      elif J[k,i%N,i//N] < 0 and h[j//N][j%N] < 0:
        total_spin -= 1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.2630584876543207}
#island_id: 2
#version_generated: 2
#generate time21:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  # Calculate the total spin at each site based on magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j = (k+2)%4 if i % N == 0 else ((i+1) % (N))
      site_nbr_j = (j + ((i//N-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N]
    
    # Normalize by the number of neighbors
    total_spin /= sum(J[:,i%N,i//N])
    
    # Assign priorities based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 2
#version_generated: 2
#generate time21:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    total_neighbors = sum(neighbor_spins)
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    if total_neighbors > 0:
      priorities[i][1] += abs(total_spin)
    elif total_neighbors < 0:
      priorities[i][0] -= abs(total_spin)
  
  return(priorities)




#score: {'data2D.txt': 0.0013112654320987659}
#island_id: 2
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors_spin = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    total_spin += sum(neighbors_spin)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors_spin)
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11533317901234581}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.00389675925925926}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr2][i//N]
      priorities[i][1] -= h[site_nbr2][i//N]
    else:
      priorities[i][0] -= h[site_nbr2][i//N]
      priorities[i][1] += h[site_nbr2][i//N]
    
    if J[3,i%N,(i//N)%N] > 0:
      priorities[i][0] += h[(i % N + ((i//N-1)%2 - 1)) % N,(i//N)%N]
      priorities[i][1] -= h[(i % N + ((i//N-1)%2 - 1)) % N,(i//N)%N]
    else:
      priorities[i][0] -= h[(i % N + ((i//N-1)%2 - 1)) % N,(i//N)%N]
      priorities[i][1] += h[(i % N + ((i//N-1)%2 - 1)) % N,(i//N)%N]
    
  return(priorities)




#score: {'data2D.txt': 0.0032915123456790127}
#island_id: 1
#version_generated: 2
#generate time21:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    site_nbr2 = ((i//N+N-1)%N + (i%N-1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [total_spin + h[site_nbr2][i%N], -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + h[site_nbr2][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': -0.005868672839506173}
#island_id: 1
#version_generated: 2
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority_total = [total_spin, -total_spin]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priority_total[0] += 1
      priority_total[1] -= 1
    else:
      priority_total[0] -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority_total[0] += h[site_nbr][j]
        priority_total[1] -= h[site_nbr][j]
      else:
        priority_total[0] -= h[site_nbr][j]
        priority_total[1] += h[site_nbr][j]
    
    priorities[i] = priority_total
  
  return(priorities)




#score: {'data2D.txt': -0.109830401234568}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    magnetism = h[i//N][i%N]
    total_spin = magnetism + neighbor_interactions
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16484367283950643}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    total_spin += neighbor_interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (site_nbr1 + ((i%N-1)%N)) % N
    if h[site_nbr1][i%N] > 0:
      priorities[i, 1] += J[1, i%N, i//N]
    else:
      priorities[i, 0] -= J[1, i%N, i//N]
    if h[site_nbr2][i%N] > 0:
      priorities[i, 1] += J[3, i%N, i//N]
    else:
      priorities[i, 0] -= J[3, i%N, i//N]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    neighbor_interactions = 0
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        neighbor_interactions += 1
      else:
        neighbor_interactions -= 1
    total_spin += neighbor_interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  return(priorities)




#score: {'data2D.txt': 0.11677515432098778}
#island_id: 1
#version_generated: 2
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # calculate total spin considering magnetism and interactions
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # assign priorities based on site's magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # fine-tune the priority by considering nearest neighbors' spins
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11631959876543223}
#island_id: 1
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.19475756172839515}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  N2 = N*N
  priorities = np.zeros((N2,2))
  for i in range(N2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i % N-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr1][i%N]
      priorities[i][1] -= h[site_nbr1][i%N]
    else:
      priorities[i][0] -= h[site_nbr1][i%N]
      priorities[i][1] += h[site_nbr1][i%N]
    
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr2][i%N]
      priorities[i][1] -= h[site_nbr2][i%N]
    else:
      priorities[i][0] -= h[site_nbr2][i%N]
      priorities[i][1] += h[site_nbr2][i%N]

  for i in range(N):
    site_nbr = (i + ((i-1)%2 - 1)) % N
    if J[3,i,N*i:i*N+1].sum() > 0:
      priorities[N*i:N*(i+1)].T[0] += h[i]
      priorities[N*i:N*(i+1)].T[1] -= h[i]
    else:
      priorities[N*i:N*(i+1)].T[0] -= h[i]
      priorities[N*i:N*(i+1)].T[1] += h[i]

  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]

    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]

  return(priorities)




#score: {'data2D.txt': 0.17913533950617289}
#island_id: 0
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 4.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.005408179012345679}
#island_id: 0
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      spin_bias = 1
    else:
      spin_bias = -1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        spin_bias += 1
      else:
        spin_bias -= 1
      
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          spin_bias += 1
        else:
          spin_bias -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          spin_bias += 1
        else:
          spin_bias -= 1
      
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          spin_bias += 1
        else:
          spin_bias -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          spin_bias += 1
        else:
          spin_bias -= 1
    
    # Normalize by the number of neighbors
    priorities[i][0] = spin_bias / 7.5
    priorities[i][1] = -priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': -0.0009347222222222223}
#island_id: 0
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin = 1
    else:
      total_spin = -1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1 if h[j][l] > 0 else -1
      else:
        total_spin -= 1 if h[j][l] > 0 else -1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1 if h[j][l] > 0 else -1
      else:
        total_spin -= 1 if h[j][l] > 0 else -1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1 if h[j][l] > 0 else -1
      else:
        total_spin -= 1 if h[j][l] > 0 else -1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1 if h[j][l] > 0 else -1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1 if h[j][l] > 0 else -1
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    
    # Add neighbor interactions
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.15476219135802488}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total energy and magnetism
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Make spin priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+J[0,i//N,i//N], -total_spin-J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin-J[2,i//N,i//N], total_spin+J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.15616959876543232}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i//N,i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Make spin priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+J[0,i//N,i//N], -total_spin-J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin-J[2,i//N,i//N], total_spin+J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.15476219135802488}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Make spin priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+J[0,i//N,i//N], -total_spin-J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin-J[2,i//N,i//N], total_spin+J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and add magnetism
    total_spin /= 2 + (h[site_nbr][i%N] > 0)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors and magnetism
    total_spin /= (2 + np.abs(h[site_nbr][i%N]))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate the priority based on magnetism and interaction energy
    priorities[i][0] = total_spin + h[site_nbr][i%N]
    priorities[i][1] = -total_spin - h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.002517746913580248}
#island_id: 0
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      site_nbr = (j + ((l-1)%2 - 1)) % N
      if J[k,i%N,l] > 0:
        total_spin += h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]

    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin

  return priorities




#score: {'data2D.txt': -0.010354783950617286}
#island_id: 0
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    for k in [0,1,3]:
      j = (i//N + ((k-2)%2 - 1)) % N
      if J[k,i%N,j] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return priorities




#score: {'data2D.txt': -0.004388734567901235}
#island_id: 0
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin * N**(-1)
    priorities[i][1] = -total_spin * N**(-1)
  
  return priorities




#score: {'data2D.txt': 0.2993325617283954}
#island_id: 3
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.0632868827160494}
#island_id: 3
#version_generated: 2
#generate time21:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Add magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + 1, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + 1]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 3
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism
    total_spin += h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.1657708333333336}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N,N), dtype=int)
  
  # Calculate the total spin at each site based on magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[i//N][i%N] += 1
    else:
      total_spin[i//N][i%N] -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j = (k+2)%4 if i % N == 0 else ((i+1) % (N))
      if J[k,i%N,i//N] > 0:
        total_spin[i//N][i%N] += 1
      else:
        total_spin[i//N][i%N] -= 1
    
    # Calculate the priority based on the total spin and magnetism at each site
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N][i%N], -total_spin[i//N][i%N]]
    else:
      priorities[i] = [-total_spin[i//N][i%N], total_spin[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.0679865740740741}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros((N,N), dtype=int)
  
  # Calculate the total spin at each site based on magnetism and interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[i//N][i%N] += 1
    else:
      total_spin[i//N][i%N] -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j = (k+2)%4 if i % N == 0 else ((i+1) % (N))
      if J[k,i%N,i//N] > 0:
        total_spin[i//N][i%N] += 1
      else:
        total_spin[i//N][i%N] -= 1
    
    # Normalize by the number of neighbors
    if sum(J[:,i//N,i%N]) > 0:
      total_spin[i//N][i%N] /= (2 if sum(J[:,i//N,i%N]) > 0 else 1)
    else:
      total_spin[i//N][i%N] /= (1 if sum(J[:,i//N,i%N]) > 0 else 2)
    
  # Assign priorities based on the total spin and magnetism at each site
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin[i//N][i%N], -total_spin[i//N][i%N]]
    else:
      priorities[i] = [-total_spin[i//N][i%N], total_spin[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.05127453703703705}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[0,i%N,i//N]+J[1,i%N,i//N]+J[2,i%N,i//N]+J[3,i%N,i//N])
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -(total_spin+1)]
    else:
      priorities[i] = [-(total_spin-1), total_spin-1]
  
  return(priorities)




#score: {'data2D.txt': 0.1104439814814816}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -(total_spin+1)]
    else:
      priorities[i] = [-(total_spin-1), total_spin-1]
    
  return(priorities)




#score: {'data2D.txt': 0.04906651234567901}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  # Calculate interaction strengths for each spin
  J_avg = np.mean(J, axis=0)
  J_avg = J_avg.reshape(1, N*N)
  
  # Initialize total magnetization and polarization arrays
  total_spin = np.zeros((N*N,))
  site_magnetism = h.flatten()
  
  # Calculate total spin for each site based on interactions and magnetism
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if J_avg[0,i%N] > 0:
      total_spin[i] += 1
    else:
      total_spin[i] -= 1
      
    if h[i//N][i%N] > 0:
      total_spin[i] += site_magnetism[i]
    else:
      total_spin[i] -= site_magnetism[i]
  
  # Calculate priority for each spin based on its interaction strength
  for i in range(N**2):
    if J_avg[0,i] > 0:
      priorities[i] = [total_spin[i]+1, -(total_spin[i]+1)]
    else:
      priorities[i] = [-(total_spin[i]-1), total_spin[i]-1]
  
  return priorities




#score: {'data2D.txt': 0.17687731481481506}
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # If magnetism is positive, prioritize +1; otherwise prioritize -1
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin+1, -(total_spin+1)]
    else:
      priorities[i] = [-(total_spin-1), total_spin-1]
    
  # Add a trick to make the algorithm more efficient
  for i in range(N**2):
    if h[i//N][i%N] > 0:
      priorities[i] = np.flip(priorities[i])
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': -0.1658578703703706}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    
    priorities[i][0] = -magnetism * total_spin
    priorities[i][1] = magnetism * total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.0022757716049382716}
#island_id: 1
#version_generated: 2
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # calculate interaction with neighbors
    neighbor_interactions = []
    for j in range(4):
      if J[j,i%N,i//N] > 0:
        neighbor_interactions.append(1)
      else:
        neighbor_interactions.append(-1)
    neighbor_interactions = np.array(neighbor_interactions)
    
    # calculate interaction with boundary sites
    boundary_interactions = []
    for j in range(N):
      if J[3,i%N,j] > 0:
        boundary_interactions.append(1)
      else:
        boundary_interactions.append(-1)
    boundary_interactions = np.array(boundary_interactions)
    
    # calculate priority based on interaction and magnetism
    priorities[i][0] = total_spin + sum(neighbor_interactions) + sum(boundary_interactions)
    priorities[i][1] = -total_spin - sum(neighbor_interactions) - sum(boundary_interactions)
  
  return(priorities)




#score: {'data2D.txt': 0.11690570987654333}
#island_id: 1
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate single-site magnetism and vertical neighbors
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate horizontal neighbors
    site_nbr = (i % N + ((2)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        total_spin += h[site_nbr][j]
        priorities[i][0] -= h[site_nbr][j]
      else:
        total_spin -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2993325617283954}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.30503163580246917}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.30503163580246917}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.303956944444444}
#island_id: 3
#version_generated: 2
#generate time21:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.30521651234567876}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin) * np.sum(np.abs(J[:,i//N,i%N])) / 8
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin) * np.sum(np.abs(J[:,i//N,i%N])) / 8
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.303956944444444}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.32610262345678936}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.012232561728395062}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
    
    # Add a bias to the priority based on the current spin
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.tanh(priorities[i][0])
      priorities[i][1] -= np.tanh(priorities[i][0])
    else:
      priorities[i][0] -= np.tanh(-priorities[i][0])
      priorities[i][1] += np.tanh(-priorities[i][0])
  
  return(priorities)




#score: {'data2D.txt': 0.32610262345678936}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
    
  return(priorities)




#score: {'data2D.txt': 0.32610262345678936}
#island_id: 3
#version_generated: 2
#generate time21:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - abs(total_spin)
      priorities[i][1] = priorities[i][0]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': -0.10000324074074084}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
    # Add priority based on magnetism of neighboring sites
    for j in range(4):
      if J[j, i//N, i//N] > 0:
        priorities[i][1 - int(h[i//N][i%N] > 0)] += J[j, i//N, i//N]
  return(priorities)




#score: {'data2D.txt': -0.10130169753086431}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      priorities[i][0] += 1
      priorities[i][1] -= 1
    else:
      priorities[i][0] -= 1
      priorities[i][1] += 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      
      if J[k,i%N,l] > 0:
        priorities[i][0] += 1
        priorities[i][1] -= 1
      else:
        priorities[i][0] -= 1
        priorities[i][1] += 1
  
  return(priorities)




#score: {'data2D.txt': 0.14511188271604952}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Add interactions from the opposite diagonal
    site_nbr_opposite = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3, i%N, site_nbr_opposite] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0019140432098765437}
#island_id: 0
#version_generated: 2
#generate time21:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin[0] += 1
      total_spin[1] -= 1
    else:
      total_spin[0] -= 1
      total_spin[1] += 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    priorities[i] = [total_spin[0], total_spin[1]]
  
  return(priorities)




#score: {'data2D.txt': 0.1979723765432099}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.32596836419753}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.14671250000000013}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.08565787037037043}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a correction term based on the number of neighbors
    site_nbrs = [site_nbr]
    for j in range(4):
     if i//N % N != (i//N+N)%N and J[j,i//N,i//N] > 0:
      site_nbrs.append((i//N+N)%N)
     elif i%N != (i+N)%N and J[3*i%4+(j-1)//2,i//N,i//N] > 0:
      site_nbrs.append((i+N)%N)
    
    for site in site_nbrs:
     if h[site][i%N] > 0:
      priorities[i][0] += J[0,site,i//N]
      priorities[i][1] -= J[1,site,i//N]
     else:
      priorities[i][0] -= J[2,site,i//N]
      priorities[i][1] += J[3,site,i//N]
    
  return(priorities)




#score: {'data2D.txt': -0.19593441358024713}
#island_id: 0
#version_generated: 2
#generate time21:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    # Add magnetism
    if h[i//N][i%N] > 0:
      total_spin -= 1
    else:
      total_spin += 1
    
    # Add neighbor interactions
    for j in range(4):
      site = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i//N] > 0:
        if h[site][i%N] > 0:
          total_spin -= 1
        else:
          total_spin += 1
    
    # Calculate priority based on magnetism and interaction
    priorities[i][0] = -total_spin
    priorities[i][1] = total_spin
  
  return(priorities)




#score: {'data2D.txt': -0.001963117283950617}
#island_id: 0
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate magnetism term
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[0,site_nbr,i//N]
      priorities[i][1] -= J[1,site_nbr,i//N]
    else:
      priorities[i][0] -= J[2,site_nbr,i//N]
      priorities[i][1] += J[3,site_nbr,i//N]
    
    # Calculate interaction term
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    priorities[i][0] += total_spin
    priorities[i][1] -= total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.089842438271605}
#island_id: 3
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3 - np.sum(J[:,i//N,i%N]) / 8
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3 - np.sum(J[:,i//N,i%N]) / 8
      priorities[i][1] = priorities[i][0]
    
    # Add magnetism interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += J[3,i//N,i%N]
      priorities[i][1] -= J[3,i//N,i%N]
    else:
      priorities[i][0] -= J[3,i//N,i%N]
      priorities[i][1] += J[3,i//N,i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.30503163580246917}
#island_id: 3
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = (total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -(total_spin + J[0,i//N,i%N]) / 3
      priorities[i][1] = priorities[i][0]
  
  # Apply a simple heuristic to reduce the number of flips needed
  for i in range(N**2):
    if priorities[i][0] > priorities[i][1]:
      priorities[i] = priorities[i].astype(int)
  
  return(priorities)




#score: {'data2D.txt': 0.16266466049382738}
#island_id: 1
#version_generated: 2
#generate time21:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr_left = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_right = (i % N + ((i//N+1)%N - 1)) % N
    
    if i % N > 0:
      priorities[i][0] -= h[site_nbr_left][i%N]
      priorities[i][1] += h[site_nbr_left][i%N]
    
    if i % N < N-1:
      priorities[i][0] += h[site_nbr_right][i%N]
      priorities[i][1] -= h[site_nbr_right][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.07001064814814822}
#island_id: 1
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin += J[3,i%N,j]
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16553070987654342}
#island_id: 1
#version_generated: 2
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((2-1)%2 - 1)) % N
    if J[2,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((1-1)%2 - 1)) % N
    if J[1,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((0-1)%2 - 1)) % N
    if J[0,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1

  return(priorities)




#score: {'data2D.txt': 0.1272427469135804}
#island_id: 2
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.0569729938271605}
#island_id: 2
#version_generated: 2
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Add a term to prioritize spins that align with the majority of their neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # Add a term to prioritize spins that have higher magnetism
    if h[i//N][i%N] > 0 and total_spin > 0:
      priorities[i][1] += 1
    elif h[i//N][i%N] < 0 and total_spin < 0:
      priorities[i][0] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.14306342592592614}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Consider the site's own spin in case of tie
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.050058487654320985}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.08915262345679019}
#island_id: 2
#version_generated: 2
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
  return(priorities)




#score: {'data2D.txt': -0.09340108024691367}
#island_id: 0
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [(J[0,i//N,i//N] if J[0,i//N,i//N] > 0 else 0) + 
           (J[1,i//N,i//N] if J[1,i//N,i//N] > 0 else -1), 
           (J[2,i//N,i//N] if J[2,i//N,i//N] > 0 else 0) + 
           (J[3,i//N,i//N] if J[3,i//N,i//N] > 0 else -1)]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + sum(1 for x in neighbors if x > 0), -spin + sum(-1 for x in neighbors if x < 0)]
    else:
      priorities[i] = [-spin + sum(-1 for x in neighbors if x > 0), spin + sum(1 for x in neighbors if x < 0)]
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
      
  return(priorities)




#score: {'data2D.txt': 0.07206836419753095}
#island_id: 0
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
            2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.04959706790123461}
#island_id: 0
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin = sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin = np.sign(total_spin)
    if h[i//N][i%N] > 0:
      priorities[i] = [spin + J[0,i//N,i//N], -spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-spin + J[2,i//N,i//N], spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin
    total_spin = h[site_nbr][i%N]
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Calculate the priority based on the site interactions and magnetism
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.015809104938271607}
#island_id: 1
#version_generated: 2
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priority = [total_spin, -total_spin] if np.sum(h[i//N]) > 0 else [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priority[0] += h[site_nbr][i%N]
        priority[1] -= h[site_nbr][i%N]
      else:
        priority[0] -= h[site_nbr][i%N]
        priority[1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priority[0] += h[site_nbr][j]
        priority[1] -= h[site_nbr][j]
      else:
        priority[0] -= h[site_nbr][j]
        priority[1] += h[site_nbr][j]
    
    priorities[i] = priority

  return(priorities)




#score: {'data2D.txt': 0.3269711419753078}
#island_id: 1
#version_generated: 2
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin_h = 0
    total_spin_J = 0
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      total_spin_h += h[site_nbr][j]
      
      if J[3,i%N,j] > 0:
        total_spin_J -= 1
      else:
        total_spin_J += 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_h - total_spin_J, -total_spin - total_spin_h + total_spin_J]
    else:
      priorities[i] = [-total_spin - total_spin_h + total_spin_J, total_spin + total_spin_h - total_spin_J]
  
  return(priorities)




#score: {'data2D.txt': 0.12520632716049396}
#island_id: 1
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  for i in range(N):
    site_nbr = (i % N + ((N-1)%2 - 1)) % N
    for j in range(N):
      if J[3,i,j] > 0:
        priorities[i*N+j][0] += h[site_nbr][j]
        priorities[i*N+j][1] -= h[site_nbr][j]
      else:
        priorities[i*N+j][0] -= h[site_nbr][j]
        priorities[i*N+j][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.11334490740740735}
#island_id: 1
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum(h[j][k] for j in range(N) for k in (j, (i+N-1)%N) if i != N*j)
      priorities[i][1] = -priorities[i][0]
    else:
      priorities[i][0] = -total_spin + sum(h[j][k] for j in range(N) for k in (j, (i+N-1)%N) if i != N*j)
      priorities[i][1] = total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.012957561728395062}
#island_id: 1
#version_generated: 2
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    total_spin = 0
    for j in range(4):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[j,i//N,i%N] > 0:
        total_spin += h[site_nbr][i%N]
      else:
        total_spin -= h[site_nbr][i%N]
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  return(priorities)




#score: {'data2D.txt': 0.33199367283950515}
#island_id: 3
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.002630401234567902}
#island_id: 3
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    total_spin = 0
    for k in range(4):
      site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    priorities[i] = [total_spin, -total_spin]
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors_spin)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0, i//N, i//N], -total_spin + J[1, i//N, i//N]]
    else:
      priorities[i] = [-total_spin + J[2, i//N, i//N], total_spin + J[3, i//N, i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
  return (priorities)




#score: {'data2D.txt': 0.34276682098765326}
#island_id: 0
#version_generated: 2
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i%N] + np.sum(neighbors)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
  return(priorities)




#score: {'data2D.txt': 0.021654475308641973}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 8
    
    # Prioritize spin based on magnetism, energy and majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(1 for j in range(N) if J[0,i%N,j] > 0), -total_spin - sum(-1 for j in range(N) if J[3,i%N,j] < 0)]
    else:
      priorities[i] = [-total_spin - sum(-1 for j in range(N) if J[0,i%N,j] > 0), total_spin + sum(1 for j in range(N) if J[3,i%N,j] < 0)]
  
  return(priorities)




#score: {'data2D.txt': 0.14306342592592614}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Consider the site's own spin in case of tie
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
    
  return(priorities)




#score: {'data2D.txt': 0.15301342592592615}
#island_id: 2
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 1
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 1
    
    # Consider the site's own spin in case of tie
    if total_spin > 0:
      priorities[i][0] += 1
    elif total_spin < 0:
      priorities[i][1] -= 1
    
    # Prioritize sites with high magnetism first
    if h[site_nbr][i%N] > 0:
      priorities[i,0] += 1
    else:
      priorities[i,1] += 1
  
  return(priorities)




#score: {'data2D.txt': -0.0012137345679012345}
#island_id: 1
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 1
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = h[i//N][i%N]
    if magnetism > 0:
      priorities[i] = [total_spin - magnetism, -(total_spin + magnetism)]
    else:
      priorities[i] = [-total_spin - magnetism, total_spin - magnetism]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))

  for i in range(N**2):
    site_nbr_row = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_col = (i // N + ((i%N-1)%2 - 1)) % N

    total_spin_row = h[site_nbr_row][i%N]
    total_spin_col = h[site_nbr_col][i//N]

    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin_row += 1
        total_spin_col -= 1
      else:
        total_spin_row -= 1
        total_spin_col += 1

    priorities[i][0] = total_spin_row + total_spin_col
    priorities[i][1] = -total_spin_row + total_spin_col

  return(priorities)




#score: {'data2D.txt': 0.16618256172839532}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with top and bottom sites (periodic boundary)
    site_nbr_top = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_bottom = (i % N + ((i//N+1)%2 - 1)) % N
    
    if i < N:
      total_spin += h[site_nbr_top][0]
      total_spin /= 3
    elif i >= N**2 - N:
      total_spin += h[site_nbr_bottom][N-1]
      total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Adjust priority based on magnetism
    priorities[i][0] = total_spin + h[i//N][i%N]
    priorities[i][1] = -total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.07264552469135807}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:, i%N, i//N]), -total_spin - np.sum(J[:, i%N, i//N])]
    else:
      priorities[i] = [-total_spin - np.sum(J[:, i%N, i//N]), total_spin + np.sum(J[:, i%N, i//N])]
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - sum([J[k,i%N,i//N] for k in range(4)])
      priorities[i][1] = -(total_spin + sum([J[k,i%N,i//N] for k in range(4)]))
    else:
      priorities[i][0] = -(total_spin + sum([J[k,i%N,i//N] for k in range(4)]))
      priorities[i][1] = total_spin - sum([J[k,i%N,i//N] for k in range(4)])
    
  return(priorities)




#score: {'data2D.txt': 0.1821489197530865}
#island_id: 0
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))

  for i in range(N**2):
    total_spin = 0
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1

    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5

    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]

  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time21:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
      
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.19239336419753092}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[site_nbr][i%N] > 0:
      total_spin = 3
    else:
      total_spin = -3
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.1821489197530865}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    total_spin = 0
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
      
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      l = i%N
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = (i%N + 1) % N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.2175924382716049}
#island_id: 0
#version_generated: 2
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    total_spin = 0
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add neighbor interactions
    if h[site_nbr][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
        
      # Add interaction with the site above and below (if exists)
      if i//N > 0:
        j = i//N - 1
        l = i%N
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        l = (i%N + 1) % N
        if J[3, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
      # Add interaction with the site diagonally above and below (if exists)
      if i//N > 0 and i % N < N-1:
        j = i//N - 1
        l = (i%N + 1) % N
        if J[3, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
        
        j = i//N - 1
        l = (i%N - 1) % N
        if J[2, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
          
    # Normalize by the number of neighbors
    total_spin /= 4
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.056133487654321}
#island_id: 0
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
    else:
      priorities[i][0] += (h[i//N][i%N]+J[2,i//N,i//N]-J[3,i//N,i//N])
  return(priorities)




#score: {'data2D.txt': 0.06462083333333338}
#island_id: 0
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
      
  return(priorities)




#score: {'data2D.txt': 0.06462083333333338}
#island_id: 0
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
  return(priorities)




#score: {'data2D.txt': 0.20334089506172864}
#island_id: 0
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = np.where(J[:,:,i//N] > 0, 1, -1).flatten()
    total_spin += np.sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add a bias towards the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= h[i//N][i%N]
    else:
      priorities[i][0] += h[i//N][i%N]
    
    # Check if priority for spin -1 is higher than the one for spin 1
    if priorities[i][0] > priorities[i][1]:
      if h[i//N][i%N] > 0:
        priorities[i] = [priorities[i][1], priorities[i][0]]
      else:
        priorities[i] = [priorities[i][0], priorities[i][1]]
    
  return(priorities)




#score: {'data2D.txt': 0.16618256172839532}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Add interactions with top and bottom sites (periodic boundary)
    site_nbr_top = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr_bottom = (i % N + ((i//N+1)%2 - 1)) % N
    
    if i < N:
      total_spin += h[site_nbr_top][0]
      total_spin /= 3
    elif i >= N**2 - N:
      total_spin += h[site_nbr_bottom][N-1]
      total_spin /= 3
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.006192438271604939}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    if h[i//N][i%N] > 0:
      total_spin = J[3,i//N,i%N]
    else:
      total_spin = -J[3,i//N,i%N]
    
    for k in range(4):
      site_nbr_k = (i % N + ((k-1)%2 - 1)) % N
      if J[k,site_nbr_k,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data2D.txt': 0.16583904320987677}
#island_id: 3
#version_generated: 2
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + abs(total_spin), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + abs(total_spin)]
  
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 1
#version_generated: 2
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[site_nbr][i%N] > 0:
      priorities[i] = [h[site_nbr][i%N], -h[site_nbr][i%N]]
    else:
      priorities[i] = [-h[site_nbr][i%N], h[site_nbr][i%N]]

    for k in range(4):
      site_nbr2 = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += J[k,i%N,i//N]
        priorities[i][1] -= J[k,i%N,i//N]
      else:
        priorities[i][0] -= J[k,i%N,i//N]
        priorities[i][1] += J[k,i%N,i//N]

  return(priorities)




#score: {'data2D.txt': -0.006164351851851852}
#island_id: 1
#version_generated: 2
#generate time21:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = 2 * (h[i//N][i%N] > 0) - 1
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      total_spin += J[k,i%N,i//N] * magnetism * h[site_nbr][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.04247206790123459}
#island_id: 0
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
            2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Add a correction term based on the site's own magnetism
    if h[i//N][i%N] > 0:
      priorities[i][1] -= total_spin
    else:
      priorities[i][0] += total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.055281944444444474}
#island_id: 0
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 
           1 if J[1,i//N,i//N] > 0 else -1, 
           2 if J[2,i//N,i//N] > 0 else -1, 
           3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.055281944444444474}
#island_id: 0
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
           2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    spin_moment = h[i//N][i%N]
    if spin_moment > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
  return(priorities)




#score: {'data2D.txt': 0.05398935185185188}
#island_id: 0
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[0,i//N,i//N] > 0 else -1, 1 if J[1,i//N,i//N] > 0 else -1,
            2 if J[2,i//N,i//N] > 0 else -1, 3 if J[3,i//N,i//N] > 0 else -1]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[0,i//N,i//N], -total_spin + J[1,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[2,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Adjust the priority based on the interaction with the current site
    if J[0,i//N,i//N] > 0:
      priorities[i][1] -= J[0,i//N,i//N]
    else:
      priorities[i][0] += J[0,i//N,i//N]
    
    # Additional adjustment based on the interaction with diagonal neighbors
    site_nbr_diagonal = (i % N + ((i//N-2)%2 - 1)) % N
    if i % N > 0:
      priorities[i][0] += J[3, i//N, i%N]
    else:
      priorities[i][1] -= J[3, i//N, i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.07122021604938274}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbrs = [(i % N + ((j-1)%2 - 1)) % N for j in range(4)]
    
    # Calculate the total spin based on magnetism and energy
    total_spin = sum(h[site_nbr][i%N] for site_nbr in site_nbrs)
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k, site_nbr in enumerate(site_nbrs):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 4
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  return(priorities)




#score: {'data2D.txt': -0.0006575617283950618}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
  
  # Sort the priority list based on the first element
  indices = np.argsort(priorities[:,0])
  priorities = priorities[indices]
  
  return(priorities)




#score: {'data2D.txt': 0.08911712962962968}
#island_id: 2
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(J[k,i%N,i//N] for k in range(4)), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(J[k,i%N,i//N] for k in range(4))]
    
  # Normalize the priorities
  priorities /= np.linalg.norm(priorities, axis=1)[:,None]
  
  return priorities




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': -0.005163734567901235}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = -total_spin - h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.006471141975308642}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k, i%N, i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] == 0:  # If the site has no magnetism, prioritize -1 spin
      priorities[i] = [total_spin - h[site_nbr][i%N], total_spin + h[site_nbr][i%N]]
    else:
      priorities[i] = [(total_spin - h[site_nbr][i%N])**2, (total_spin + h[site_nbr][i%N])**2]
  
  return(priorities)




#score: {'data2D.txt': 0.33199367283950515}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.33184922839506076}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  return(priorities)




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the bias term
    total_spin = h[site_nbr][i%N]
    
    # Calculate the neighbor interactions
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (J[:, i//N, :].sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.22132824074074067}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on the number of neighbors
    neighbor_count = int(i//N > 0)
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.22258719135802466}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.025841820987654335}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin based on magnetism and interaction
    total_spin = h[site_nbr][i%N] + np.sum(J[:,i//N,i//N])
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate additional priority based on the product of magnetism and interaction
    prod_spin = np.prod(J[:,i//N,i//N])
    if h[i//N][i%N] > 0:
      priorities[i][0] += prod_spin
      priorities[i][1] -= prod_spin
    else:
      priorities[i][0] -= prod_spin
      priorities[i][1] += prod_spin
  
  return(priorities)




#score: {'data2D.txt': 0.1324677469135804}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': 0.1324677469135804}
#island_id: 0
#version_generated: 2
#generate time21:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(J[:,i//N,i//N]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(J[:,i//N,i//N])]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.005139043209876555}
#island_id: 0
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += np.sum(J[k-1:i,k-1:i])
      else:
        total_spin -= np.sum(J[k-1:i,k-1:i])
    
    # Normalize by the number of neighbors
    total_spin /= (4*(i % N == 0) + 3*(i % N > 0))
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Calculate additional priority based on the product of magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i][0] += np.prod(J[:,i//N,i//N])
      priorities[i][1] -= np.prod(J[:,i//N,i//N])
    else:
      priorities[i][0] -= np.prod(J[:,i//N,i//N])
      priorities[i][1] += np.prod(J[:,i//N,i//N])
  
  return(priorities)




#score: {'data2D.txt': -0.007831327160493827}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total magnetism and neighbor interactions
    J_sum = J[:, i//N, :].sum()
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [(total_spin - h[i//N][i%N]) * (J_sum + 1), 
             -(total_spin + h[i//N][i%N]) * (J_sum + 1)]
  
  return(priorities)




#score: {'data2D.txt': 0.3320146604938262}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum.sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
    
  return(priorities)




#score: {'data2D.txt': -0.0010248456790123458}
#island_id: 3
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum.sum() + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin - 2, total_spin]
    else:
      priorities[i] = [total_spin, total_spin + 2]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': -0.001367438271604938}
#island_id: 0
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if h[i//N][i%N] > 0:
      total_spin[0] += 1
      total_spin[1] -= 1
    else:
      total_spin[0] -= 1
      total_spin[1] += 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        priorities[i][0] += total_spin[0]
        priorities[i][1] -= total_spin[1]
      else:
        priorities[i][0] -= total_spin[0]
        priorities[i][1] += total_spin[1]
    
  return(priorities)




#score: {'data2D.txt': -0.009547067901234548}
#island_id: 0
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin[0] += h[i//N][i%N]
    
    if h[i//N][i%N] > 0:
      for k in range(4):
        j, l = i//N + ((k-2)%2 - 1), (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin[0] -= 1
          break
        elif J[k,i%N,l] < 0:
          total_spin[0] += 1
          break
        
      priorities[i][0] = total_spin[0]
      priorities[i][1] = -total_spin[0]
    else:
      for k in range(4):
        j, l = i//N + ((k-2)%2 - 1), (k+1)%2
        if J[k,i%N,l] < 0:
          total_spin[0] += 1
          break
        elif J[k,i%N,l] > 0:
          total_spin[0] -= 1
          break
        
      priorities[i][0] = -total_spin[0]
      priorities[i][1] = total_spin[0]
  
  return(priorities)




#score: {'data2D.txt': -0.0018205246913580253}
#island_id: 0
#version_generated: 2
#generate time21:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin = np.zeros(2)
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin[0] += 1
      total_spin[1] -= 1
    else:
      total_spin[0] -= 1
      total_spin[1] += 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin[0] += 1
        total_spin[1] -= 1
      else:
        total_spin[0] -= 1
        total_spin[1] += 1
    
    # Normalize the priority by the absolute value of the magnetism
    priorities[i][0] = total_spin[0] / abs(total_spin[0])
    priorities[i][1] = total_spin[1] / abs(total_spin[1])
  
  return(priorities)




#score: {'data2D.txt': -0.011561265432098766}
#island_id: 1
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    magnetism = np.sum(J[:,i//N,i//N])
    
    priorities[i][0] = total_spin + magnetism/2
    priorities[i][1] = -total_spin + magnetism/2
  
  return(priorities)




#score: {'data2D.txt': 0.1637804012345681}
#island_id: 1
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.16558811728395084}
#island_id: 1
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    site_nbr = (i % N + ((3-1)%2 - 1)) % N
    if J[3,i%N,i//N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
  
  return(priorities)




#score: {'data2D.txt': -0.0005819444444444406}
#island_id: 0
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i // N].flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
  return (priorities)




#score: {'data2D.txt': -0.0005819444444444406}
#island_id: 0
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = J[:, :, i // N].flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time21:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
  return (priorities)




#score: {'data2D.txt': 0.3427671296296286}
#island_id: 0
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    neighbors_spin = np.where(J[:, :, i // N] > 0, 1, -1).flatten()
    total_spin = h[site_nbr][i % N] + np.sum(neighbors_spin)
    
    if h[i // N][i % N] > 0:
      priorities[i] = [total_spin + np.sum(neighbors_spin), -total_spin + np.sum(neighbors_spin)]
    else:
      priorities[i] = [-total_spin + np.sum(neighbors_spin), total_spin + np.sum(neighbors_spin)]
      
  return (priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 2
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
    else:
      priorities[i] = [-total_spin - sum(neighbor) for neighbor in [[-1,-1,-1,-1],[1,1,1,1]]]
  
  return(priorities)




#score: {'data2D.txt': -0.0012986111111111102}
#island_id: 2
#version_generated: 2
#generate time21:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy and neighbor alignment
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum(1 for j in range(N) if J[0,i%N,j] > 0 or J[1,i%N,j] > 0), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum(-1 for j in range(N) if J[0,i%N,j] < 0 or J[1,i%N,j] < 0)]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
  
  return(priorities)




#score: {'data2D.txt': 0.11612484567901248}
#island_id: 2
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism, energy, and majority vote of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 2
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 2
    
    # Add a bonus for alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += np.sum([1 if J[k,i%N,i//N] < 0 and k % 2 == 1 else -1 for k in range(4)])
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= np.sum([1 if J[k,i%N,i//N] > 0 and k % 2 == 1 else -1 for k in range(4)])
  
  return(priorities)




#score: {'data2D.txt': 0.23596496913580245}
#island_id: 0
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[k,i//N,i//N] > 0 else -1 for k in range(4)]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
    # Add additional term to account for neighboring sites
    site_nbr_up = (i % N) - 1 if i % N != 0 else N-1
    site_nbr_down = (i % N) + 1 if i % N != N-1 else 0
    total_spin += h[i//N][site_nbr_up] + h[i//N][site_nbr_down]
    
  return(priorities)




#score: {'data2D.txt': -0.03643163580246916}
#island_id: 0
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate total spin
    total_spin = sum([h[site_nbr][j] for j in range(N)]) if h[site_nbr][i%N] > 0 else -sum([h[site_nbr][j] for j in range(N)])
    
    # Add neighbor interactions
    neighbors = [J[k,i//N,i//N] if J[k,i//N,i//N] > 0 else -1 for k in [0, 2]] + [-1 if J[k,i//N,i//N] < 0 else 1 for k in [1, 3]]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors) // 2
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
  
  return(priorities)




#score: {'data2D.txt': 0.23596496913580245}
#island_id: 0
#version_generated: 2
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    neighbors = [0 if J[k,i//N,i//N] > 0 else -1 for k in range(4)]
    total_spin += sum(neighbors)
    
    # Normalize by the number of neighbors
    total_spin /= len(neighbors)
    
    # Calculate priority based on magnetism and interaction
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + J[1,i//N,i//N], -total_spin + J[2,i//N,i//N]]
    else:
      priorities[i] = [-total_spin + J[0,i//N,i//N], total_spin + J[3,i//N,i//N]]
    
  return(priorities)




#score: {'data2D.txt': 0.183339351851852}
#island_id: 0
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same row (if exists)
    if i % N < N - 1:
      j = i//N
      if J[0, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)) + (int(i % N < N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.34267145061728294}
#island_id: 0
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += J[k,i%N,l]
      else:
        total_spin -= J[k,i%N,l]
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += J[2, i%N, i%N]
      else:
        total_spin -= J[2, i%N, i%N]
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += J[3, i%N, i%N]
      else:
        total_spin -= J[3, i%N, i%N]
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += J[1, i%N, i%N]
      else:
        total_spin -= J[1, i%N, i%N]
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.16840077160493838}
#island_id: 0
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4)
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.20172391975308646}
#island_id: 0
#version_generated: 2
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions with nearest neighbors
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and (i % N == 0 or i % N == N - 1):
      j = i//N - 1
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site at the same column (if exists)
    if i % N > 0:
      j = i//N
      if J[1, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)) + (int(i % N > 0)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.17980293209876552}
#island_id: 0
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, k+1
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add a bias term based on the site's own magnetism
    total_spin += h[i//N][i%N]
    
    # Normalize by the number of neighbors
    if i % N != 0 and i % N != N - 1 and i // N < N - 1:
      total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0495726851851852}
#island_id: 0
#version_generated: 2
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in range(2):
      j, l = i//N + k - 1, k+1
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add bias term to the priority
    total_spin += h[i//N][i%N]
    
    priorities[i] = [total_spin, -total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.11361651234567914}
#island_id: 1
#version_generated: 2
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr][i%N]
        priorities[i][1] -= h[site_nbr][i%N]
      else:
        priorities[i][0] -= h[site_nbr][i%N]
        priorities[i][1] += h[site_nbr][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
  return(priorities)




#score: {'data2D.txt': 0.11432885802469138}
#island_id: 1
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i][0] = total_spin - np.sum(h[:i//N,:])
      priorities[i][1] = -total_spin + np.sum(h[:i//N,:])
    else:
      priorities[i][0] = -total_spin - np.sum(h[:i//N,:])
      priorities[i][1] = total_spin - np.sum(h[:i//N,:])
    
  return(priorities)




#score: {'data2D.txt': 0.16480293209876568}
#island_id: 1
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0,1,3]: # only need to check horizontal and diagonal neighbors
     if J[k,i%N,i//N] > 0:
      total_spin += 1
     else:
      total_spin -= 1
    
    if h[i//N][i%N] > 0:
     priorities[i] = [total_spin, -total_spin]
    else:
     priorities[i] = [-total_spin, total_spin]
    
  return(priorities)




#score: {'data2D.txt': 0.29163780864197475}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J[k,k,i//N]
      else:
        total_spin -= J[k,k,i//N]
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [(total_spin - h[i//N][i%N]) * 10, -(total_spin - h[i//N][i%N])]
  return(priorities)




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    if total_spin > 0.5:
      priorities[i] = [total_spin - h[i//N][i%N], total_spin]
    else:
      priorities[i] = [total_spin, total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.34290787037036935}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum(axis=0)
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += J_sum[k]
      else:
        total_spin -= J_sum[k]
    
    # Normalize by the number of interacting neighbors
    total_spin /= np.count_nonzero(J[:, i//N, :])
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.33214861111111016}
#island_id: 3
#version_generated: 2
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    J_sum = J[:, i//N, :].sum()
    for k in [0, 1]:
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of interacting neighbors
    total_spin /= (J_sum + 1)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i] = [total_spin - h[i//N][i%N], total_spin + h[i//N][i%N]]
  
  return(priorities)




#score: {'data2D.txt': 0.22081990740740753}
#island_id: 2
#version_generated: 2
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + sum([1 if J[k,i%N,i//N]>0 else -1 for k in range(4)]), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + sum([1 if J[k,i%N,i//N]<0 else -1 for k in range(4)])]
    
  return(priorities)




#score: {'data2D.txt': 0.211548302469136}
#island_id: 2
#version_generated: 2
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 1
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 1
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    if total_spin * h[site_nbr][i%N] > 0:
      priorities[i][int(total_spin > 0)] += 1
    
    # Consider the site's own spin in case of tie
    if abs(total_spin) < 1e-6:  # Avoid division by zero
      priorities[i][0] += total_spin
    
  return(priorities)




#score: {'data2D.txt': 0.05705015432098766}
#island_id: 2
#version_generated: 2
#generate time21:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    # Consider the alignment with the majority of neighbors
    neighbor_spins = [h[(i-1)%N][j] if j != i else 0 for j in range(N)] + [h[(i+1)%N][j] if j != N-1 else 0 for j in range(N)]
    if sum(neighbor_spins) > 0:
      priorities[i][1] += 2
    elif sum(neighbor_spins) < 0:
      priorities[i][0] -= 2
    
    # If the site is already aligned with its neighbors, prioritize its own spin
    for k in range(4):
      if J[k,i%N,i//N] > 0 and h[site_nbr][i%N] < 0:
        priorities[i][1] += 3
      elif J[k,i%N,i//N] < 0 and h[site_nbr][i%N] > 0:
        priorities[i][0] -= 3
    
    # Consider the site's own spin in case of tie
    if total_spin > 0.5:
      priorities[i][0] += 1
    elif total_spin < -0.5:
      priorities[i][1] -= 1
  
  return(priorities)




#score: {'data2D.txt': 0.3309180555555546}
#island_id: 3
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize
    for k in [0,1]:  
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    total_spin /= (J[:, i//N, :].sum() + 2)
    
    # Calculate priority based on magnetism and neighbor interactions
    priorities[i][0] = total_spin - h[i//N][i%N]
    priorities[i][1] = total_spin + h[i//N][i%N]
  
  return(priorities)




#score: {'data2D.txt': 0.1982621913580247}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1,3]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': 0.33543873456790024}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  total_spin_sum = np.zeros(2)
  
  # Add neighbor interactions
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in [0, 1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [0, 2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-2)%2 - 1)
      if j >= 0 and j < N:
        l = (k+1)%2
        if J[k,i%N,l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    if i//N > 0: total_spin_sum[0] += total_spin
    if i % N == 0 or i % N == N - 1: total_spin_sum[1] += total_spin
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + total_spin_sum[0]/2, -total_spin - total_spin_sum[1]/2]
    else:
      priorities[i] = [-total_spin - total_spin_sum[0]/2, total_spin + total_spin_sum[1]/2]
  
  return(priorities)




#score: {'data2D.txt': 0.16757484567901243}
#island_id: 0
#version_generated: 2
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions
    for k in [0,1]:
      j, l = i//N + ((k-1)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for k in [1]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for k in [2]:
      j = i//N + ((k-1)%2 - 1)
      if j >= 0 and j < N:
        l = i%N
        if J[k, i%N, l] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i % N == 0 or i % N == N - 1)))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  return(priorities)




#score: {'data2D.txt': -0.0008415123456790122}
#island_id: 0
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
      
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    for d in [(i//N-1, i%N), (i//N+1, i%N)]:
      if 0 <= d[0] < N:
        if J[2, i%N, i%N] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    for d in [(i//N-1, (i%N+1) % N), (i//N+1, (i%N-1) % N)]:
      if 0 <= d[0] < N and 0 <= d[1] < N:
        if J[3, i%N, d[1]] > 0:
          total_spin += 1
        else:
          total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (4 + int(i//N > 0) + int((i//N+1)%N > 0) + int((i%N+1) % N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': -0.0007510802469135802}
#island_id: 0
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = 0
    
    # Add magnetism at the current site
    if h[i//N][i%N] > 0:
      total_spin += 1
    else:
      total_spin -= 1
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= (3 + int(i//N > 0))
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': -0.0007510802469135802}
#island_id: 0
#version_generated: 2
#generate time21:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[i//N][i%N]
    
    # Add neighbor interactions
    for k in range(4):
      j, l = i//N + ((k-2)%2 - 1), (k+1)%2
      if J[k,i%N,l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site above and below (if exists)
    if i//N > 0:
      j = i//N - 1
      if J[2, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      l = i%N
      if J[3, i%N, i%N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Add interaction with the site diagonally above and below (if exists)
    if i//N > 0 and i % N < N-1:
      j = i//N - 1
      l = (i%N + 1) % N
      if J[3, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
      
      j = i//N - 1
      l = (i%N - 1) % N
      if J[2, i%N, l] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    # Normalize by the number of neighbors
    total_spin /= 3.5
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
  
  # Sort by the priority in descending order
  priorities = priorities[np.argsort(priorities[:, 0])[::-1]]
  
  return priorities




#score: {'data2D.txt': 0.11223904320987667}
#island_id: 1
#version_generated: 2
#generate time21:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N,2))
  
  for i in range(N**2):
    site_nbr1 = (i % N + ((i//N-1)%2 - 1)) % N
    site_nbr2 = (i // N + ((i%N-1)%2 - 1)) % N
    total_spin = h[site_nbr1][i%N] + h[site_nbr2][i//N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for k in range(3):
      site_nbr1 = (i % N + ((k-1)%2 - 1)) % N
      if J[k,i%N,i//N] > 0:
        priorities[i][0] += h[site_nbr1][i%N]
        priorities[i][1] -= h[site_nbr1][i%N]
      else:
        priorities[i][0] -= h[site_nbr1][i%N]
        priorities[i][1] += h[site_nbr1][i%N]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
  
  return(priorities)




#score: {'data2D.txt': 0.10264274691358037}
#island_id: 1
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    total_spin = h[site_nbr][i%N]
    
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin, -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin]
    
    for j in range(N):
      site_nbr = (i % N + ((j-1)%2 - 1)) % N
      if J[3,i%N,j] > 0:
        priorities[i][0] += h[site_nbr][j]
        priorities[i][1] -= h[site_nbr][j]
      else:
        priorities[i][0] -= h[site_nbr][j]
        priorities[i][1] += h[site_nbr][j]
    
    site_nbr = (i // N + ((i % N-1)%2 - 1)) % N
    if J[0,i//N,i%N] > 0:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    else:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    if J[1,i//N,i%N] > 0:
      priorities[i][0] += h[site_nbr][i%N]
      priorities[i][1] -= h[site_nbr][i%N]
    else:
      priorities[i][0] -= h[site_nbr][i%N]
      priorities[i][1] += h[site_nbr][i%N]
    
  return(priorities)




#score: {'data2D.txt': 0.13779398148148167}
#island_id: 2
#version_generated: 2
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N*N, 2))
  
  for i in range(N**2):
    site_nbr = (i % N + ((i//N-1)%2 - 1)) % N
    
    # Calculate the total spin based on magnetism and energy
    total_spin = h[site_nbr][i%N]
    
    # Add neighbor interactions and normalize by the number of neighbors
    for k in range(4):
      if J[k,i%N,i//N] > 0:
        total_spin += 1
      else:
        total_spin -= 1
    
    total_spin /= 2
    
    # Prioritize spin based on magnetism and energy, considering the majority of neighbors
    if h[i//N][i%N] > 0:
      priorities[i] = [total_spin + np.sum(np.sign(J[:,i//N,i//N])), -total_spin]
    else:
      priorities[i] = [-total_spin, total_spin + np.sum(np.sign(J[:,i//N,i//N]))]
    
  return(priorities)




